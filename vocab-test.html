<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自适应词汇量测试</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
        }

        .container {
            max-width: 600px;
            width: 90%;
            padding: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2em;
            background: linear-gradient(90deg, #00d2ff, #3a7bd5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 30px;
            font-size: 0.95em;
        }

        /* Loading State */
        .loading {
            text-align: center;
            padding: 60px 20px;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top-color: #3a7bd5;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Test UI */
        .test-container {
            display: none;
        }

        .progress-panel {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .progress-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .progress-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9em;
        }

        .progress-value {
            font-weight: 600;
            color: #00d2ff;
        }

        .confidence-bar-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            height: 30px;
            position: relative;
            overflow: hidden;
        }

        .confidence-bar {
            position: absolute;
            height: 100%;
            background: linear-gradient(90deg, #3a7bd5, #00d2ff);
            border-radius: 10px;
            transition: left 0.3s, width 0.3s;
        }

        .confidence-marker {
            position: absolute;
            height: 100%;
            width: 3px;
            background: #fff;
            border-radius: 2px;
            transition: left 0.3s;
        }

        .confidence-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.5);
        }

        .word-display {
            text-align: center;
            padding: 40px 20px;
            margin-bottom: 30px;
        }

        .current-word {
            font-size: 3em;
            font-weight: 700;
            letter-spacing: 2px;
            text-transform: lowercase;
            background: linear-gradient(90deg, #fff, #e0e0e0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .word-rank {
            margin-top: 10px;
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.5);
        }

        .button-group {
            display: flex;
            gap: 15px;
        }

        .btn {
            flex: 1;
            padding: 18px 24px;
            border: none;
            border-radius: 12px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-know {
            background: linear-gradient(135deg, #11998e, #38ef7d);
            color: #fff;
            box-shadow: 0 4px 15px rgba(56, 239, 125, 0.3);
        }

        .btn-know:hover {
            box-shadow: 0 6px 20px rgba(56, 239, 125, 0.4);
        }

        .btn-unknown {
            background: linear-gradient(135deg, #eb3349, #f45c43);
            color: #fff;
            box-shadow: 0 4px 15px rgba(235, 51, 73, 0.3);
        }

        .btn-unknown:hover {
            box-shadow: 0 6px 20px rgba(235, 51, 73, 0.4);
        }

        .btn-uncertain {
            background: linear-gradient(135deg, #f7971e, #ffd200);
            color: #333;
            box-shadow: 0 4px 15px rgba(247, 151, 30, 0.3);
        }

        .btn-uncertain:hover {
            box-shadow: 0 6px 20px rgba(247, 151, 30, 0.4);
        }

        /* Results UI */
        .results-container {
            display: none;
            text-align: center;
        }

        .result-number {
            font-size: 4em;
            font-weight: 700;
            background: linear-gradient(90deg, #00d2ff, #3a7bd5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 20px 0 10px;
        }

        .result-range {
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 30px;
        }

        .result-label {
            font-size: 1.1em;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 5px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 30px 0;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 15px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: 600;
            color: #00d2ff;
        }

        .stat-label {
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 5px;
        }

        .btn-restart {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: #fff;
            padding: 15px 40px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .btn-restart:hover {
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        /* Error state */
        .error {
            text-align: center;
            color: #f45c43;
            padding: 40px 20px;
        }

        .error-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }

        /* Keyboard hints */
        .keyboard-hints {
            text-align: center;
            margin-top: 20px;
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.5);
        }

        kbd {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 10px;
            border-radius: 6px;
            font-family: inherit;
            margin: 0 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>词汇量测试</h1>
        <p class="subtitle">基于 COCA 词频的自适应词汇量估算</p>

        <!-- Loading State -->
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>正在加载词汇表...</p>
        </div>

        <!-- Error State -->
        <div class="error" id="error" style="display: none;">
            <div class="error-icon">⚠️</div>
            <p>词汇表加载失败，请刷新页面。</p>
        </div>

        <!-- Test UI -->
        <div class="test-container" id="testContainer">
            <div class="progress-panel">
                <div class="progress-row">
                    <span class="progress-label">已测试单词</span>
                    <span class="progress-value" id="wordsTestedCount">0</span>
                </div>
                <div class="progress-row">
                    <span class="progress-label">当前批次</span>
                    <span class="progress-value" id="batchProgress">1 / 3</span>
                </div>
                <div class="progress-row">
                    <span class="progress-label">当前估算</span>
                    <span class="progress-value" id="currentEstimate">—</span>
                </div>
                <div class="progress-row">
                    <span class="progress-label">估算范围</span>
                    <span class="progress-value" id="estimateRange">—</span>
                </div>
                <div class="progress-row">
                    <span class="progress-label">置信度</span>
                    <span class="progress-value" id="confidencePercent">0%</span>
                </div>
                <div class="confidence-bar-container">
                    <div class="confidence-bar" id="confidenceBar"></div>
                    <div class="confidence-marker" id="confidenceMarker"></div>
                </div>
                <div class="confidence-labels">
                    <span>0</span>
                    <span>15,000</span>
                    <span>30,000</span>
                    <span>45,000</span>
                    <span>60,000</span>
                </div>
            </div>

            <div class="word-display">
                <div class="current-word" id="currentWord">—</div>
                <div class="word-rank" id="wordRank"></div>
            </div>

            <div class="button-group">
                <button class="btn btn-know" id="btnKnow">认识</button>
                <button class="btn btn-uncertain" id="btnUncertain">不确定</button>
                <button class="btn btn-unknown" id="btnUnknown">不认识</button>
            </div>

            <div class="keyboard-hints">
                按 <kbd>→</kbd> 或 <kbd>Y</kbd> 认识，<kbd>↓</kbd> 或 <kbd>M</kbd> 不确定，<kbd>←</kbd> 或 <kbd>N</kbd> 不认识
            </div>
        </div>

        <!-- Results UI -->
        <div class="results-container" id="resultsContainer">
            <p class="result-label">您的预估词汇量</p>
            <div class="result-number" id="resultNumber">—</div>
            <div class="result-range" id="resultRange">—</div>

            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-value" id="statWordsTested">—</div>
                    <div class="stat-label">测试单词数</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="statAccuracy">—</div>
                    <div class="stat-label">认识单词数</div>
                </div>
            </div>

            <button class="btn btn-restart" id="btnRestart">重新测试</button>
        </div>
    </div>

    <script>
        // ============================================
        // Vocabulary Test - Bayesian Adaptive Algorithm
        // ============================================

        class VocabularyTest {
            constructor() {
                this.words = [];
                this.totalWords = 0;
                
                // Bayesian inference parameters
                this.k = 800; // Transition smoothness
                this.binSize = 100; // Discretize vocabulary sizes into bins
                this.numBins = 0;
                this.logPosterior = []; // Log probabilities for numerical stability
                
                // Test state
                this.testedWords = new Map(); // rank -> known (boolean)
                this.currentWordRank = 0;
                this.isComplete = false;
                
                // Batch sampling parameters (reduces randomness by updating after multiple samples)
                // Early batches are larger to quickly narrow down the estimate
                this.initialBatchSize = 8; // First batch size
                this.minBatchSize = 1; // Minimum batch size for later batches
                this.batchCount = 0; // Number of batches completed
                this.pendingResponses = []; // Accumulate responses: [{rank, response}]
                this.currentBatch = []; // Current batch of words to test
                this.currentBatchIndex = 0; // Index within current batch
                
                // Stopping criteria
                this.minWords = 10;
                this.maxWords = 200;
                this.targetConfidenceWidth = 0.10; // 10% of estimate
                
                // Boundary validation state
                this.boundaryValidationDone = false;
                this.boundaryValidationInProgress = false;
                this.boundaryValidationResults = []; // Track results of boundary checks
                
                // Error tolerance parameters (accounts for user mistakes)
                // slip: probability of saying "don't know" when actually knowing
                // guess: probability of saying "know" when actually not knowing
                this.slip = 0.02;  // 2% chance of accidental "don't know"
                this.guess = 0.10; // 10% chance of accidental "know" (or lucky guess)
                
                // UI elements
                this.elements = {};
                
                this.init();
            }

            async init() {
                this.cacheElements();
                this.bindEvents();
                
                try {
                    await this.loadWordList();
                    this.startTest();
                } catch (error) {
                    console.error('Failed to initialize:', error);
                    this.showError();
                }
            }

            cacheElements() {
                this.elements = {
                    loading: document.getElementById('loading'),
                    error: document.getElementById('error'),
                    testContainer: document.getElementById('testContainer'),
                    resultsContainer: document.getElementById('resultsContainer'),
                    wordsTestedCount: document.getElementById('wordsTestedCount'),
                    batchProgress: document.getElementById('batchProgress'),
                    currentEstimate: document.getElementById('currentEstimate'),
                    estimateRange: document.getElementById('estimateRange'),
                    confidencePercent: document.getElementById('confidencePercent'),
                    confidenceBar: document.getElementById('confidenceBar'),
                    confidenceMarker: document.getElementById('confidenceMarker'),
                    currentWord: document.getElementById('currentWord'),
                    wordRank: document.getElementById('wordRank'),
                    btnKnow: document.getElementById('btnKnow'),
                    btnUncertain: document.getElementById('btnUncertain'),
                    btnUnknown: document.getElementById('btnUnknown'),
                    btnRestart: document.getElementById('btnRestart'),
                    resultNumber: document.getElementById('resultNumber'),
                    resultRange: document.getElementById('resultRange'),
                    statWordsTested: document.getElementById('statWordsTested'),
                    statAccuracy: document.getElementById('statAccuracy')
                };
            }

            bindEvents() {
                this.elements.btnKnow.addEventListener('click', () => this.respond('know'));
                this.elements.btnUncertain.addEventListener('click', () => this.respond('uncertain'));
                this.elements.btnUnknown.addEventListener('click', () => this.respond('unknown'));
                this.elements.btnRestart.addEventListener('click', () => this.restart());
                
                document.addEventListener('keydown', (e) => {
                    if (this.isComplete) return;
                    if (e.key === 'ArrowRight' || e.key === 'y' || e.key === 'Y') {
                        this.respond('know');
                    } else if (e.key === 'ArrowDown' || e.key === 'm' || e.key === 'M') {
                        this.respond('uncertain');
                    } else if (e.key === 'ArrowLeft' || e.key === 'n' || e.key === 'N') {
                        this.respond('unknown');
                    }
                });
            }

            async loadWordList() {
                const response = await fetch('https://huiget.github.io/COCA60000.txt');
                if (!response.ok) throw new Error('Failed to fetch word list');
                
                const text = await response.text();
                this.words = text.split('\n')
                    .map(line => line.trim())
                    .filter(word => word.length > 0);
                
                this.totalWords = this.words.length;
                this.numBins = Math.ceil(this.totalWords / this.binSize);
                
                console.log(`Loaded ${this.totalWords} words`);
            }

            showError() {
                this.elements.loading.style.display = 'none';
                this.elements.error.style.display = 'block';
            }

            startTest() {
                // Initialize uniform prior (log probabilities)
                this.logPosterior = new Array(this.numBins).fill(-Math.log(this.numBins));
                this.testedWords.clear();
                this.isComplete = false;
                
                // Reset batch state
                this.batchCount = 0;
                this.pendingResponses = [];
                this.currentBatch = [];
                this.currentBatchIndex = 0;
                
                // Reset boundary validation state
                this.boundaryValidationDone = false;
                this.boundaryValidationInProgress = false;
                this.boundaryValidationResults = [];
                
                // Show test UI
                this.elements.loading.style.display = 'none';
                this.elements.error.style.display = 'none';
                this.elements.resultsContainer.style.display = 'none';
                this.elements.testContainer.style.display = 'block';
                
                this.selectNextBatch();
                this.showCurrentWord();
                this.updateUI();
            }

            // Raw sigmoid function: P(actually know word at rank r | vocabulary size V)
            sigmoidRaw(r, V) {
                const x = (V - r) / this.k;
                // Numerical stability
                if (x > 20) return 1;
                if (x < -20) return 0;
                return 1 / (1 + Math.exp(-x));
            }

            // P(say "know" | rank r, vocab V) with error tolerance
            // Accounts for: guessing when don't know, slipping when do know
            // P(say know) = guess + (1 - guess - slip) * P(actually know)
            pSayKnow(r, V) {
                const pActuallyKnow = this.sigmoidRaw(r, V);
                return this.guess + (1 - this.guess - this.slip) * pActuallyKnow;
            }

            // Get vocabulary size for a bin index
            binToVocab(binIndex) {
                return (binIndex + 0.5) * this.binSize;
            }

            // Get posterior probabilities from log probabilities
            getPosterior() {
                const maxLog = Math.max(...this.logPosterior);
                return this.logPosterior.map(lp => Math.exp(lp - maxLog));
            }

            // Calculate mean and confidence interval
            getEstimate() {
                const posterior = this.getPosterior();
                const sum = posterior.reduce((a, b) => a + b, 0);
                
                // Normalize
                const normalized = posterior.map(p => p / sum);
                
                // Mean
                let mean = 0;
                for (let i = 0; i < this.numBins; i++) {
                    mean += normalized[i] * this.binToVocab(i);
                }
                
                // Find 95% confidence interval (2.5% and 97.5% quantiles)
                let cumSum = 0;
                let lower = 0;
                let upper = this.totalWords;
                
                for (let i = 0; i < this.numBins; i++) {
                    cumSum += normalized[i];
                    if (cumSum >= 0.025 && lower === 0) {
                        lower = this.binToVocab(i);
                    }
                    if (cumSum >= 0.975) {
                        upper = this.binToVocab(i);
                        break;
                    }
                }
                
                return { mean, lower, upper };
            }

            // Calculate dynamic batch size based on test progress
            getCurrentBatchSize() {
                // First few batches are larger to quickly narrow down the estimate
                // Gradually decrease: 8 → 6 → 5 → 4 → 3 → 2 → 2 → 2 → 1...
                if (this.batchCount === 0) return this.initialBatchSize;
                if (this.batchCount === 1) return 6;
                if (this.batchCount === 2) return 5;
                if (this.batchCount === 3) return 4;
                if (this.batchCount === 4) return 3;
                if (this.batchCount <= 7) return 2;
                return this.minBatchSize;
            }

            // Select a batch of words with randomness while maintaining adaptive nature
            selectNextBatch() {
                const estimate = this.getEstimate();
                const mean = estimate.mean;
                const currentBatchSize = this.getCurrentBatchSize();
                
                // Strategy: collect candidates near the boundary, then randomly select
                // multiple words for the batch
                
                // Define search range with random offset for variety
                // Larger range for early batches to explore more broadly
                const baseRange = this.batchCount < 2 ? 8000 : 4000;
                const searchRange = Math.max(baseRange, (estimate.upper - estimate.lower) * 1.5);
                const randomOffset = (Math.random() - 0.5) * 500; // Random shift ±250
                const searchCenter = Math.max(1, Math.min(this.totalWords, mean + randomOffset));
                
                // Collect more candidates for batch selection
                // Need more candidates for larger batches
                const minCandidates = Math.max(40, currentBatchSize * 5);
                const candidates = [];
                const stepSize = 15 + Math.floor(Math.random() * 25); // Random step 15-40
                
                for (let offset = 0; offset < searchRange; offset += stepSize) {
                    // Add randomness to each offset
                    const jitter = Math.floor(Math.random() * stepSize);
                    const ranks = [
                        Math.round(searchCenter + offset + jitter),
                        Math.round(searchCenter - offset - jitter)
                    ];
                    
                    for (const rank of ranks) {
                        if (rank > 0 && rank <= this.totalWords && !this.testedWords.has(rank)) {
                            candidates.push(rank);
                        }
                    }
                    
                    if (candidates.length >= minCandidates) break;
                }
                
                // If no candidates near mean, search more broadly with random start
                if (candidates.length === 0) {
                    const randomStart = 1 + Math.floor(Math.random() * 100);
                    for (let rank = randomStart; rank <= this.totalWords; rank += 100) {
                        if (!this.testedWords.has(rank)) {
                            candidates.push(rank);
                        }
                    }
                }
                
                // Score candidates by information gain (closer to P=0.5 is better)
                const scored = candidates.map(rank => {
                    const p = this.pSayKnow(rank, mean);
                    // Information gain score: higher is better (max at p=0.5)
                    const entropy = -p * Math.log2(p + 1e-10) - (1-p) * Math.log2(1-p + 1e-10);
                    return { rank, score: entropy };
                });
                
                // Sort by score and take more top candidates for batch selection
                scored.sort((a, b) => b.score - a.score);
                const topCandidates = scored.slice(0, Math.min(currentBatchSize * 3, scored.length));
                
                // Weighted random selection of batchSize words from top candidates
                // Use softmax-like weighting
                const temperature = 0.5;
                const selectedBatch = [];
                const usedIndices = new Set();
                
                for (let b = 0; b < currentBatchSize && topCandidates.length > usedIndices.size; b++) {
                    // Calculate weights excluding already selected
                    const availableCandidates = topCandidates
                        .map((c, i) => ({ ...c, index: i }))
                        .filter(c => !usedIndices.has(c.index));
                    
                    if (availableCandidates.length === 0) break;
                    
                    const weights = availableCandidates.map(c => Math.exp(c.score / temperature));
                    const totalWeight = weights.reduce((a, b) => a + b, 0);
                    
                    let random = Math.random() * totalWeight;
                    let selectedIdx = 0;
                    
                    for (let i = 0; i < availableCandidates.length; i++) {
                        random -= weights[i];
                        if (random <= 0) {
                            selectedIdx = i;
                            break;
                        }
                    }
                    
                    const selected = availableCandidates[selectedIdx];
                    usedIndices.add(selected.index);
                    selectedBatch.push(selected.rank);
                }
                
                // Fallback if batch is empty
                if (selectedBatch.length === 0) {
                    selectedBatch.push(Math.round(mean));
                }
                
                // Shuffle the batch for variety in presentation order
                for (let i = selectedBatch.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [selectedBatch[i], selectedBatch[j]] = [selectedBatch[j], selectedBatch[i]];
                }
                
                this.currentBatch = selectedBatch;
                this.currentBatchIndex = 0;
                
            }

            // Show the current word from the batch
            showCurrentWord() {
                if (this.currentBatchIndex < this.currentBatch.length) {
                    this.currentWordRank = this.currentBatch[this.currentBatchIndex];
                }
            }

            // Check if we should stop testing
            shouldStop() {
                const numTested = this.testedWords.size;
                
                if (numTested < this.minWords) return false;
                if (numTested >= this.maxWords) return true;
                
                const estimate = this.getEstimate();
                const width = estimate.upper - estimate.lower;
                const relativeWidth = width / Math.max(estimate.mean, 1000);
                
                const confidenceReached = relativeWidth < this.targetConfidenceWidth;
                
                // If confidence reached but boundary validation not done, trigger it
                if (confidenceReached && !this.boundaryValidationDone && !this.boundaryValidationInProgress) {
                    return this.triggerBoundaryValidation();
                }
                
                // If boundary validation is in progress, don't stop yet
                if (this.boundaryValidationInProgress) {
                    return false;
                }
                
                return confidenceReached && this.boundaryValidationDone;
            }
            
            // Trigger boundary validation to verify the estimate
            triggerBoundaryValidation() {
                const estimate = this.getEstimate();
                const testedRanks = Array.from(this.testedWords.keys());
                const minTestedRank = Math.min(...testedRanks);
                
                // Check if we've tested words significantly below the estimate
                // If the lowest tested word is too close to the estimate, we need to validate
                const validationNeeded = minTestedRank > estimate.lower * 0.7;
                
                if (!validationNeeded) {
                    // Already tested words well below the estimate, no validation needed
                    this.boundaryValidationDone = true;
                    return true; // Can stop now
                }
                
                // Need to validate - select boundary validation batch
                this.boundaryValidationInProgress = true;
                this.selectBoundaryValidationBatch();
                return false; // Don't stop yet
            }
            
            // Select words for boundary validation
            // Test words at different levels below the current estimate
            selectBoundaryValidationBatch() {
                const estimate = this.getEstimate();
                const mean = estimate.mean;
                const lower = estimate.lower;
                
                // Test at multiple levels: 30%, 50%, 70% of the estimated lower bound
                const validationLevels = [0.3, 0.5, 0.7, 0.85];
                const validationBatch = [];
                
                for (const level of validationLevels) {
                    const targetRank = Math.round(lower * level);
                    // Find an untested word near this rank
                    for (let offset = 0; offset < 500; offset += 10) {
                        const candidates = [targetRank + offset, targetRank - offset].filter(
                            r => r > 0 && r <= this.totalWords && !this.testedWords.has(r)
                        );
                        if (candidates.length > 0) {
                            validationBatch.push(candidates[0]);
                            break;
                        }
                    }
                }
                
                // Also add a couple words between lower bound and mean
                const midLevels = [0.9, 0.95];
                for (const level of midLevels) {
                    const targetRank = Math.round(lower + (mean - lower) * level);
                    for (let offset = 0; offset < 200; offset += 5) {
                        const candidates = [targetRank + offset, targetRank - offset].filter(
                            r => r > 0 && r <= this.totalWords && !this.testedWords.has(r)
                        );
                        if (candidates.length > 0) {
                            validationBatch.push(candidates[0]);
                            break;
                        }
                    }
                }
                
                this.currentBatch = validationBatch;
                this.currentBatchIndex = 0;
                this.boundaryValidationResults = [];
            }
            
            // Process boundary validation results
            processBoundaryValidationResults() {
                const estimate = this.getEstimate();
                const lower = estimate.lower;
                
                // Count how many "should know" words the user actually knows
                let shouldKnowCount = 0;
                let actuallyKnowCount = 0;
                
                for (const result of this.boundaryValidationResults) {
                    // Words well below the estimate (< 70% of lower) should be known
                    if (result.rank < lower * 0.8) {
                        shouldKnowCount++;
                        if (result.response === 'know') {
                            actuallyKnowCount++;
                        }
                    }
                }
                
                // If user doesn't know many words they "should" know, the estimate is too high
                const knowRatio = shouldKnowCount > 0 ? actuallyKnowCount / shouldKnowCount : 1;
                const estimateNeedsAdjustment = knowRatio < 0.6; // Less than 60% known
                
                this.boundaryValidationInProgress = false;
                this.boundaryValidationDone = true;
                
                if (estimateNeedsAdjustment) {
                    // Continue testing to refine the estimate
                    this.boundaryValidationDone = false; // Will need to validate again
                    return false; // Don't stop
                }
                
                return true; // Can stop now
            }

            // Process user response: 'know', 'uncertain', or 'unknown'
            respond(response) {
                if (this.isComplete) return;
                
                // Record response
                this.testedWords.set(this.currentWordRank, response);
                this.pendingResponses.push({ rank: this.currentWordRank, response });
                
                // Track boundary validation results if in progress
                if (this.boundaryValidationInProgress) {
                    this.boundaryValidationResults.push({ rank: this.currentWordRank, response });
                }
                
                // Move to next word in batch
                this.currentBatchIndex++;
                
                // Check if batch is complete
                if (this.currentBatchIndex >= this.currentBatch.length) {
                    // Batch complete - update posterior with all responses
                    this.updatePosteriorBatch(this.pendingResponses);
                    this.pendingResponses = [];
                    this.batchCount++;
                    
                    // If boundary validation batch just completed, process results
                    if (this.boundaryValidationInProgress) {
                        const canStop = this.processBoundaryValidationResults();
                        if (canStop && this.shouldStop()) {
                            this.completeTest();
                            return;
                        }
                        // Continue with normal batch selection
                        this.selectNextBatch();
                    } else {
                        // Check stopping criteria (may trigger boundary validation)
                        const wasValidationInProgress = this.boundaryValidationInProgress;
                        if (this.shouldStop()) {
                            this.completeTest();
                            return;
                        }
                        
                        // If boundary validation was just triggered, don't override the batch
                        if (this.boundaryValidationInProgress && !wasValidationInProgress) {
                            // Boundary validation batch was just set by triggerBoundaryValidation
                            // Don't call selectNextBatch - use the validation batch
                        } else {
                            // Select next batch normally
                            this.selectNextBatch();
                        }
                    }
                }
                
                // Show next word
                this.showCurrentWord();
                this.updateUI();
            }

            // Update posterior with a batch of responses (reduces noise from individual responses)
            updatePosteriorBatch(responses) {
                if (responses.length === 0) return;
                
                // Accumulate log likelihoods from all responses in the batch
                const batchLogLikelihoods = new Array(this.numBins).fill(0);
                
                // Weight for uncertain responses (lower weight = less influence on posterior)
                const uncertainWeight = 0.3;
                
                for (const { rank, response } of responses) {
                    for (let i = 0; i < this.numBins; i++) {
                        const V = this.binToVocab(i);
                        const pKnow = this.pSayKnow(rank, V);
                        
                        let likelihood;
                        let weight = 1.0;
                        
                        if (response === 'know') {
                            likelihood = pKnow;
                        } else if (response === 'unknown') {
                            likelihood = 1 - pKnow;
                        } else {
                            // Uncertain: treat as weak evidence towards 50-50
                            // Use a likelihood closer to 0.5 to reduce impact
                            likelihood = 0.4 * pKnow + 0.3; // Maps pKnow [0,1] to [0.3, 0.7]
                            weight = uncertainWeight;
                        }
                        
                        batchLogLikelihoods[i] += weight * Math.log(Math.max(likelihood, 1e-10));
                    }
                }
                
                // Update log posterior with batch likelihoods
                for (let i = 0; i < this.numBins; i++) {
                    this.logPosterior[i] += batchLogLikelihoods[i];
                }
                
                // Normalize (log-sum-exp trick)
                const maxLog = Math.max(...this.logPosterior);
                const sumExp = this.logPosterior.reduce((sum, lp) => sum + Math.exp(lp - maxLog), 0);
                const logNorm = maxLog + Math.log(sumExp);
                
                for (let i = 0; i < this.numBins; i++) {
                    this.logPosterior[i] -= logNorm;
                }
                
            }

            // Update the UI with current state
            updateUI() {
                const estimate = this.getEstimate();
                const numTested = this.testedWords.size;
                
                // Words tested
                this.elements.wordsTestedCount.textContent = numTested;
                
                // Batch progress
                const batchNum = this.currentBatchIndex + 1;
                const batchTotal = this.currentBatch.length;
                this.elements.batchProgress.textContent = `${batchNum} / ${batchTotal}`;
                
                // Current estimate
                this.elements.currentEstimate.textContent = 
                    numTested > 0 ? Math.round(estimate.mean).toLocaleString() : '—';
                
                // Estimate range (lower - upper bounds)
                this.elements.estimateRange.textContent = 
                    numTested > 0 ? `${Math.round(estimate.lower).toLocaleString()} — ${Math.round(estimate.upper).toLocaleString()}` : '—';
                
                // Confidence (inverse of relative interval width)
                const width = estimate.upper - estimate.lower;
                const relativeWidth = width / Math.max(estimate.mean, 1000);
                const confidence = Math.max(0, Math.min(100, (1 - relativeWidth / 0.5) * 100));
                this.elements.confidencePercent.textContent = `${Math.round(confidence)}%`;
                
                // Confidence bar
                const barLeft = (estimate.lower / this.totalWords) * 100;
                const barWidth = ((estimate.upper - estimate.lower) / this.totalWords) * 100;
                const markerPos = (estimate.mean / this.totalWords) * 100;
                
                this.elements.confidenceBar.style.left = `${barLeft}%`;
                this.elements.confidenceBar.style.width = `${barWidth}%`;
                this.elements.confidenceMarker.style.left = `${markerPos}%`;
                
                // Current word
                const word = this.words[this.currentWordRank - 1] || '—';
                this.elements.currentWord.textContent = word;
                this.elements.wordRank.textContent = `排名：${this.currentWordRank.toLocaleString()} / ${this.totalWords.toLocaleString()}`;
            }

            // Complete the test and show results
            completeTest() {
                this.isComplete = true;
                
                const estimate = this.getEstimate();
                const numTested = this.testedWords.size;
                const responses = Array.from(this.testedWords.values());
                const numKnown = responses.filter(v => v === 'know').length;
                const numUncertain = responses.filter(v => v === 'uncertain').length;
                
                // Show results
                this.elements.testContainer.style.display = 'none';
                this.elements.resultsContainer.style.display = 'block';
                
                this.elements.resultNumber.textContent = Math.round(estimate.mean).toLocaleString();
                this.elements.resultRange.textContent = 
                    `95% 置信区间：${Math.round(estimate.lower).toLocaleString()} — ${Math.round(estimate.upper).toLocaleString()} 个单词`;
                
                this.elements.statWordsTested.textContent = numTested;
                this.elements.statAccuracy.textContent = numUncertain > 0 
                    ? `${numKnown} 认识 / ${numUncertain} 不确定`
                    : `${numKnown} / ${numTested}`;
            }

            // Restart the test
            restart() {
                this.startTest();
            }
        }

        // Initialize the test when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            new VocabularyTest();
        });
    </script>
</body>
</html>
