<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÁîµÂ≠ê‰π¶ÈòÖËØªÂô®</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://unpkg.com/compromise@14.14.5/builds/compromise.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // ÈÖçÁΩÆ PDF.js worker - ÂøÖÈ°ªÂú®‰ΩøÁî®ÂâçËÆæÁΩÆ
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }
    </script>
    <!-- WebLLM for local AI translation -->
    <script type="module">
        import { CreateMLCEngine, prebuiltAppConfig } from 'https://esm.run/@mlc-ai/web-llm';
        window.CreateMLCEngine = CreateMLCEngine;
        window.webLLMPrebuiltAppConfig = prebuiltAppConfig;
        // Ëß¶Âèë WebLLM Âä†ËΩΩÂÆåÊàê‰∫ã‰ª∂
        window.dispatchEvent(new Event('webllm-ready'));
    </script>
    <style>
        /* CSS ÂèòÈáè - Áªü‰∏ÄÁÆ°ÁêÜÈ¢úËâ≤ÂíåÂ∞∫ÂØ∏ */
        :root {
            --primary-color: #3498db;
            --primary-hover: #2980b9;
            --success-color: #27ae60;
            --success-hover: #219a52;
            --danger-color: #e74c3c;
            --danger-hover: #c0392b;
            --purple-color: #9b59b6;
            --purple-hover: #8e44ad;
            --gray-color: #607d8b;
            --gray-hover: #546e7a;
            --teal-color: #16a085;
            --teal-hover: #138d75;
            
            --sidebar-bg: #2c3e50;
            --sidebar-header-bg: #1a252f;
            --sidebar-border: #34495e;
            --text-primary: #2c3e50;
            --text-secondary: #7f8c8d;
            --text-muted: #95a5a6;
            --border-color: #ecf0f1;
            --bg-light: #f5f5f5;
            --bg-lighter: #f8f9fa;
            
            --font-system: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 12px;
            --radius-pill: 20px;
            --transition-fast: 0.2s;
            --transition-normal: 0.3s;
            --shadow-sm: 0 2px 10px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 20px rgba(0,0,0,0.08);
            --shadow-lg: 0 10px 40px rgba(0,0,0,0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            max-width: 100vw;
            overflow-x: hidden;
        }

        body {
            font-family: var(--font-system);
            background: var(--bg-light);
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            max-width: 100vw;
            overflow-x: hidden;
        }

        /* ÈÄöÁî®ÊåâÈíÆÊ†∑Âºè */
        .btn {
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 14px;
            transition: background var(--transition-fast);
        }
        
        .btn-primary { background: var(--primary-color); }
        .btn-primary:hover { background: var(--primary-hover); }
        .btn-success { background: var(--success-color); }
        .btn-success:hover { background: var(--success-hover); }
        .btn-danger { background: var(--danger-color); }
        .btn-danger:hover { background: var(--danger-hover); }
        .btn-purple { background: var(--purple-color); }
        .btn-purple:hover { background: var(--purple-hover); }
        .btn-gray { background: var(--gray-color); }
        .btn-gray:hover { background: var(--gray-hover); }
        .btn-teal { background: var(--teal-color); }
        .btn-teal:hover { background: var(--teal-hover); }

        /* ÈÄöÁî®ÊåáÁ§∫Âô®Ê†∑Âºè */
        .indicator {
            display: none;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            border-radius: var(--radius-pill);
            font-size: 13px;
        }
        .indicator.active { display: flex; }
        .indicator .icon { font-size: 14px; }
        .indicator .value { font-weight: 600; }
        .indicator .unit { font-size: 11px; }

        /* ÁªüËÆ°ÊåáÁ§∫Âô®ÂÆπÂô® */
        .stats-group {
            display: flex;
            align-items: center;
            gap: 8px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 6px 10px;
            border-radius: 12px;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.06);
        }

        /* Áªü‰∏ÄÁöÑÁªüËÆ°ÊåáÁ§∫Âô®Ê†∑Âºè */
        .time-indicator,
        .speed-indicator,
        .read-count-indicator,
        .word-count-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 1px solid rgba(255,255,255,0.8);
            backdrop-filter: blur(4px);
        }

        .time-indicator:hover,
        .speed-indicator:hover,
        .read-count-indicator:hover,
        .word-count-indicator:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
        }

        /* ÂõæÊ†áÊ†∑Âºè */
        .time-icon, .speed-icon, .read-count-icon, .word-count-icon {
            font-size: 15px;
            filter: drop-shadow(0 1px 1px rgba(0,0,0,0.1));
        }

        /* Êï∞ÂÄºÊ†∑Âºè */
        .time-value, .speed-value, .read-count-value, .word-count-value {
            font-weight: 700;
            font-size: 14px;
            letter-spacing: -0.3px;
        }

        /* Âçï‰ΩçÊ†∑Âºè */
        .speed-unit, .read-count-unit, .word-count-unit {
            font-size: 11px;
            opacity: 0.75;
            font-weight: 500;
        }

        /* ‰æßËæπÊ†èÊ†∑Âºè */
        .sidebar {
            width: 280px;
            min-width: 280px;
            background: var(--sidebar-bg);
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            transition: transform var(--transition-normal) ease;
            z-index: 100;
        }

        .sidebar.collapsed {
            transform: translateX(-280px);
            margin-left: -280px;
        }
        
        /* ‰æßËæπÊ†èÈÅÆÁΩ© - ‰ªÖÁßªÂä®Á´Ø‰ΩøÁî® */
        .sidebar-overlay {
            display: none;
        }

        .sidebar-header {
            padding: 20px;
            background: var(--sidebar-header-bg);
            border-bottom: 1px solid var(--sidebar-border);
        }

        .sidebar-header h2 {
            font-size: 16px;
            font-weight: 500;
            color: #bdc3c7;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .toc-container {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
        }

        .toc-item {
            padding: 12px 20px;
            cursor: pointer;
            transition: background var(--transition-fast), border-left var(--transition-fast);
            border-left: 3px solid transparent;
            font-size: 14px;
            line-height: 1.5;
        }

        .toc-item:hover { background: var(--sidebar-border); }
        .toc-item.active {
            background: var(--primary-color);
            border-left-color: var(--danger-color);
        }

        .toc-item.level-1 { padding-left: 20px; }
        .toc-item.level-2 { padding-left: 35px; font-size: 13px; }
        .toc-item.level-3 { padding-left: 50px; font-size: 12px; }

        /* ‰∏ªÂÜÖÂÆπÂå∫ */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
            min-width: 0;
            max-width: 100%;
        }

        /* È°∂ÈÉ®Â∑•ÂÖ∑Ê†è */
        .toolbar {
            background: white;
            padding: 15px 25px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: var(--shadow-sm);
            z-index: 10;
        }

        .toggle-sidebar {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 14px;
            transition: background var(--transition-fast);
        }
        .toggle-sidebar:hover { background: var(--primary-hover); }

        .book-title {
            flex: 1;
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .upload-btn {
            background: var(--success-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 14px;
            transition: background var(--transition-fast);
        }
        .upload-btn:hover { background: var(--success-hover); }

        #file-input { display: none; }

        /* ËÆæÁΩÆÊåâÈíÆ */
        .settings-btn {
            background: var(--purple-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 14px;
            transition: background var(--transition-fast);
        }
        .settings-btn:hover { background: var(--purple-hover); }

        /* ËÆæÁΩÆÈù¢Êùø */
        .settings-panel {
            position: fixed;
            top: 70px;
            right: 25px;
            background: white;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            padding: 25px;
            width: 320px;
            max-width: calc(100vw - 50px);
            max-height: calc(100vh - 90px);
            overflow-y: auto;
            z-index: 200;
            display: none;
        }
        .settings-panel.active { display: block; }

        .settings-panel h3 {
            font-size: 16px;
            color: var(--text-primary);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .setting-group {
            margin-bottom: 20px;
        }
        .setting-group:last-child { margin-bottom: 0; }

        .setting-label {
            display: block;
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            font-weight: 500;
        }

        .setting-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .setting-row input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--border-color);
            border-radius: 3px;
            outline: none;
        }

        .setting-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
            transition: background var(--transition-fast);
        }
        .setting-row input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--primary-hover);
        }
        
        /* Firefox ÂÖºÂÆπÊÄß */
        .setting-row input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .setting-value {
            min-width: 50px;
            text-align: right;
            font-size: 14px;
            color: var(--text-primary);
            font-weight: 600;
        }

        .font-select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
            color: var(--text-primary);
            background: white;
            cursor: pointer;
            outline: none;
            transition: border-color var(--transition-fast);
        }
        .font-select:hover, .font-select:focus {
            border-color: var(--primary-color);
        }

        .settings-overlay {
            position: fixed;
            inset: 0;
            z-index: 150;
            display: none;
        }
        .settings-overlay.active { display: block; }

        /* ÈòÖËØªËøõÂ∫¶ */
        .progress-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            background: var(--bg-lighter);
            border-radius: var(--radius-pill);
            font-size: 13px;
            color: #5a6c7d;
        }

        .progress-indicator .progress-text {
            font-weight: 600;
            color: var(--text-primary);
            min-width: 45px;
            text-align: center;
        }

        .progress-bar-container {
            width: 80px;
            height: 6px;
            background: #e0e5ea;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), #2ecc71);
            border-radius: 3px;
            transition: width 0.15s ease-out;
            width: 0%;
        }

        /* ÂêÑÁ±ªÊåáÁ§∫Âô®È¢úËâ≤‰∏ªÈ¢ò */
        .time-indicator {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            color: #155724;
            border-color: rgba(40, 167, 69, 0.2);
        }
        .time-indicator .time-value { color: #28a745; }

        .speed-indicator {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeeba 100%);
            color: #856404;
            border-color: rgba(255, 193, 7, 0.3);
        }
        .speed-indicator .speed-value { color: #d39e00; }

        .read-count-indicator {
            background: linear-gradient(135deg, #e2d5f1 0%, #d4c4e8 100%);
            color: #5a3d7a;
            border-color: rgba(102, 51, 153, 0.2);
        }
        .read-count-indicator .read-count-value { color: #6f42c1; }

        .word-count-indicator {
            background: linear-gradient(135deg, #cce5ff 0%, #b8daff 100%);
            color: #004085;
            border-color: rgba(0, 123, 255, 0.2);
        }
        .word-count-indicator .word-count-value { color: #007bff; }

        /* ‰π¶Êû∂ÊåâÈíÆ */
        .library-btn {
            background: var(--gray-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 14px;
            transition: background var(--transition-fast);
        }
        .library-btn:hover { background: var(--gray-hover); }

        /* ÈÄöÁî®Ê®°ÊÄÅÊ°ÜÊ†∑Âºè */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            border-radius: var(--radius-lg);
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 1px solid #eee;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 18px;
            color: var(--text-primary);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--text-muted);
            padding: 5px;
        }
        .modal-close:hover { color: var(--text-primary); }

        /* ‰π¶Êû∂Ê®°ÊÄÅÊ°Ü */
        .library-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .library-content {
            background: linear-gradient(135deg, #fefefe 0%, #f8f9fa 100%);
            border-radius: 16px;
            width: 90%;
            max-width: 640px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            animation: slideUp 0.3s ease;
        }

        .library-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 24px 28px;
            background: linear-gradient(135deg, var(--primary-color) 0%, #5a9fd4 100%);
            color: white;
        }

        .library-header h2 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            color: white;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .library-close {
            background: rgba(255,255,255,0.2);
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        .library-close:hover { 
            background: rgba(255,255,255,0.3);
            transform: rotate(90deg);
        }

        .library-books {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .library-books::-webkit-scrollbar {
            width: 6px;
        }
        .library-books::-webkit-scrollbar-track {
            background: transparent;
        }
        .library-books::-webkit-scrollbar-thumb {
            background: #ddd;
            border-radius: 3px;
        }

        .library-empty {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-muted);
            font-size: 14px;
        }
        .library-empty::before {
            content: 'üìñ';
            display: block;
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        /* ‰π¶Á±çÂç°Áâá */
        .library-book {
            display: flex;
            align-items: center;
            padding: 16px 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            transition: all 0.2s ease;
            border: 1px solid rgba(0,0,0,0.04);
        }
        .library-book:hover {
            box-shadow: 0 8px 24px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        /* ËØçÊ±áË°®Ê®°ÊÄÅÊ°Ü - ‰∏é‰π¶Êû∂Ê†∑ÂºèÁªü‰∏Ä */
        .vocab-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 0.2s ease;
        }

        .vocab-content {
            background: linear-gradient(135deg, #fefefe 0%, #f8f9fa 100%);
            border-radius: 16px;
            width: 90%;
            max-width: 700px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            animation: slideUp 0.3s ease;
        }

        .vocab-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 24px 28px;
            background: linear-gradient(135deg, var(--teal-color) 0%, #1abc9c 100%);
            color: white;
        }

        /* Â∑≤Êü•ËØ¢ËØçË°®‰ΩøÁî®Á¥´Ëâ≤ */
        .looked-up-modal .vocab-header {
            background: linear-gradient(135deg, var(--purple-color) 0%, #a569bd 100%);
        }

        .vocab-header h2 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            color: white;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .vocab-close {
            background: rgba(255,255,255,0.2);
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        .vocab-close:hover { 
            background: rgba(255,255,255,0.3);
            transform: rotate(90deg);
        }

        .vocab-list {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .vocab-list::-webkit-scrollbar {
            width: 6px;
        }
        .vocab-list::-webkit-scrollbar-track {
            background: transparent;
        }
        .vocab-list::-webkit-scrollbar-thumb {
            background: #ddd;
            border-radius: 3px;
        }

        /* ÈÄöÁî®ÂàóË°®È°πÊ†∑Âºè */
        .list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 25px;
            border-bottom: 1px solid #f5f5f5;
            transition: background var(--transition-fast);
        }
        .list-item:hover { background: var(--bg-lighter); }

        .list-body {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
        }

        /* ÈÄöÁî®Â∞èÊåâÈíÆ */
        .btn-sm {
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 12px;
            transition: background var(--transition-fast);
        }

        /* ‰π¶Êû∂ÂÜÖÂÆπ - Â§çÁî® .list-body Âíå .list-item Ê†∑Âºè */

        .book-info {
            flex: 1;
            min-width: 0;
        }

        .book-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .book-title-text {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
            min-width: 0;
        }

        .file-type-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 0.5px;
            flex-shrink: 0;
        }
        .file-type-badge.epub { 
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%); 
            color: #2e7d32; 
            box-shadow: 0 2px 4px rgba(46, 125, 50, 0.15);
        }
        .file-type-badge.pdf { 
            background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%); 
            color: #c62828; 
            box-shadow: 0 2px 4px rgba(198, 40, 40, 0.15);
        }

        .book-meta {
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 13px;
            color: var(--text-muted);
        }

        .book-author {
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .book-progress { 
            color: var(--primary-color); 
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .book-progress-bar {
            width: 60px;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
        }
        .book-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color) 0%, #5a9fd4 100%);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .book-time { 
            color: var(--success-color);
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .book-time::before {
            content: '‚è±';
            font-size: 12px;
        }

        .book-actions {
            display: flex;
            gap: 10px;
            margin-left: 20px;
            flex-shrink: 0;
        }

        .book-open, .book-delete {
            padding: 10px 18px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            color: white;
        }

        .book-open {
            background: linear-gradient(135deg, var(--primary-color) 0%, #5a9fd4 100%);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
        .book-open:hover { 
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(52, 152, 219, 0.4);
        }

        .book-delete {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
        }
        .book-delete:hover { 
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(231, 76, 60, 0.4);
        }

        /* ÈÄâËØçÊµÆÂä®ÊåâÈíÆ */
        .word-action-btn {
            position: fixed;
            background: var(--success-color);
            color: white;
            border: none;
            padding: 8px 14px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.4);
            z-index: 10000;
            display: none;
            transition: all var(--transition-fast);
            white-space: nowrap;
        }
        .word-action-btn:hover {
            background: var(--success-hover);
            transform: translateY(-1px);
        }
        .word-action-btn.remove {
            background: var(--danger-color);
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
        }
        .word-action-btn.remove:hover { background: var(--danger-hover); }

        /* Â∑≤Áü•ËØçÊ±áÊåâÈíÆ */
        .vocab-btn {
            background: var(--teal-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 14px;
            transition: background var(--transition-fast);
        }
        .vocab-btn:hover { background: var(--teal-hover); }

        /* Â∑≤Êü•ËØ¢ËØçË°®ÊåâÈíÆ */
        .looked-up-btn {
            background: var(--purple-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 14px;
            transition: background var(--transition-fast);
        }
        .looked-up-btn:hover { background: var(--purple-hover); }

        .vocab-header-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .vocab-search {
            padding: 10px 16px;
            border: none;
            border-radius: 20px;
            font-size: 14px;
            width: 200px;
            outline: none;
            background: rgba(255,255,255,0.2);
            color: white;
            transition: all 0.2s ease;
        }
        .vocab-search::placeholder {
            color: rgba(255,255,255,0.7);
        }
        .vocab-search:focus { 
            background: rgba(255,255,255,0.3);
            box-shadow: 0 0 0 3px rgba(255,255,255,0.2);
        }

        /* .vocab-close Â§çÁî® .modal-close Ê†∑Âºè */

        .vocab-stats {
            padding: 14px 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            font-size: 13px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .vocab-stats::before {
            content: 'üìä';
            font-size: 14px;
        }

        /* ËØçÊ±áÂç°ÁâáÊ†∑Âºè */
        .vocab-word {
            padding: 14px 18px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            transition: all 0.2s ease;
            border: 1px solid rgba(0,0,0,0.04);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .vocab-word:hover {
            box-shadow: 0 6px 20px rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }

        .vocab-word-text {
            font-size: 16px;
            color: var(--text-primary);
            font-weight: 600;
        }

        .vocab-word-meta {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .vocab-word-date {
            font-size: 12px;
            color: var(--text-muted);
            background: #f1f3f4;
            padding: 4px 10px;
            border-radius: 12px;
        }

        .vocab-word-delete {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(231, 76, 60, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .vocab-word:hover .vocab-word-delete { opacity: 1; }
        .vocab-word-delete:hover { 
            transform: translateY(-1px) scale(1.1);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4);
        }

        .vocab-empty {
            text-align: center;
            padding: 60px 25px;
            color: var(--text-muted);
            font-size: 14px;
            line-height: 1.6;
        }
        .vocab-empty::before {
            content: 'üìù';
            display: block;
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        .looked-up-modal .vocab-empty::before {
            content: 'üîç';
        }

        .vocab-footer {
            padding: 18px 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border-top: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .vocab-export-btn {
            background: linear-gradient(135deg, var(--primary-color) 0%, #5a9fd4 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
        .vocab-export-btn:hover { 
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(52, 152, 219, 0.4);
        }

        .vocab-clear-btn {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
        }
        .vocab-clear-btn:hover { 
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(231, 76, 60, 0.4);
        }

        /* Â∑≤Êü•ËØ¢ËØçË°®ÁâπÊúâÊ†∑Âºè */
        .looked-up-word {
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
        }

        .looked-up-main {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            width: 100%;
        }

        .looked-up-translation {
            color: var(--text-secondary);
            font-size: 14px;
            flex: 1;
            white-space: pre-line;
        }

        .looked-up-rank {
            color: white;
            font-size: 11px;
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
        }

        .looked-up-count {
            color: var(--purple-color);
            font-size: 12px;
            font-weight: 600;
            background: #f3e5f5;
            padding: 4px 10px;
            border-radius: 12px;
        }

        .looked-up-word .vocab-word-meta {
            width: 100%;
            justify-content: flex-end;
        }

        /* ÈòÖËØªÂå∫Âüü */
        .reader-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 40px;
            background: #f9f9f9;
            max-width: 100%;
        }

        .reader-content {
            max-width: 800px;
            width: 100%;
            margin: 0 auto;
            background: white;
            padding: 60px 80px;
            border-radius: 8px;
            box-shadow: var(--shadow-md);
            line-height: 1.8;
            font-size: 17px;
            color: #333;
        }

        .reader-content h1, .reader-content h2, .reader-content h3 {
            margin-top: 1.5em;
            margin-bottom: 0.8em;
            color: var(--text-primary);
            line-height: 1.4;
        }

        .reader-content h1 { font-size: 2em; }
        .reader-content h2 { font-size: 1.6em; }
        .reader-content h3 { font-size: 1.3em; }

        .reader-content p {
            margin-bottom: 1.2em;
            text-align: justify;
        }

        .reader-content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
            border-radius: var(--radius-sm);
        }

        .reader-content a {
            color: var(--primary-color);
            text-decoration: none;
        }
        .reader-content a:hover { text-decoration: underline; }

        .chapter-section {
            margin-bottom: 60px;
            padding-bottom: 40px;
            border-bottom: 1px solid #eee;
        }
        .chapter-section:last-child { border-bottom: none; }

        /* Ê¨¢ËøéÁïåÈù¢ */
        .welcome-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            color: var(--text-secondary);
        }

        .welcome-screen svg {
            width: 120px;
            height: 120px;
            margin-bottom: 30px;
            opacity: 0.6;
        }

        .welcome-screen h2 {
            font-size: 24px;
            color: #34495e;
            margin-bottom: 15px;
        }

        .welcome-screen p {
            font-size: 16px;
            margin-bottom: 30px;
        }

        .drop-zone {
            border: 3px dashed #bdc3c7;
            border-radius: var(--radius-lg);
            padding: 60px 80px;
            cursor: pointer;
            transition: all var(--transition-normal);
        }

        .drop-zone:hover, .drop-zone.drag-over {
            border-color: var(--primary-color);
            background: rgba(52, 152, 219, 0.05);
        }

        /* Âä†ËΩΩÂä®Áîª */
        .loading {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(255,255,255,0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        .loading.active { display: flex; }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading p {
            margin-top: 20px;
            color: var(--text-secondary);
            font-size: 16px;
        }

        /* ÊªöÂä®Êù°Ê†∑Âºè */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb {
            background: #c0c0c0;
            border-radius: var(--radius-sm);
        }
        ::-webkit-scrollbar-thumb:hover { background: #a0a0a0; }

        .toc-container::-webkit-scrollbar-track { background: var(--sidebar-bg); }
        .toc-container::-webkit-scrollbar-thumb { background: #4a6278; }

        /* ÂìçÂ∫îÂºèËÆæËÆ° - Âπ≥Êùø */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                bottom: 0;
                width: 280px;
                z-index: 1000;
                /* ÁßªÂä®Á´ØÈªòËÆ§ÈöêËóèÁõÆÂΩï */
                transform: translateX(-100%);
            }
            .sidebar.expanded {
                transform: translateX(0);
            }
            .sidebar.collapsed {
                transform: translateX(-100%);
                margin-left: 0;
            }
            
            /* ‰æßËæπÊ†èÊâìÂºÄÊó∂ÁöÑÈÅÆÁΩ© */
            .sidebar-overlay {
                display: none;
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 999;
            }
            .sidebar-overlay.active {
                display: block;
            }

            /* Â∑•ÂÖ∑Ê†è - ÂÖÅËÆ∏Êç¢Ë°å */
            .toolbar {
                padding: 10px 12px;
                flex-wrap: wrap;
                gap: 8px;
            }
            
            .settings-panel { 
                right: 10px; 
                left: 10px; 
                width: auto;
                top: auto;
                bottom: 10px;
                max-height: 70vh;
            }
            
            .book-title { display: none; }
            
            .progress-indicator { 
                padding: 6px 10px;
                order: 10;
            }
            .progress-bar-container { width: 50px; }

            /* ÁªüËÆ°ÊåáÁ§∫Âô®ÂÆπÂô®Êç¢Ë°å */
            .stats-group {
                padding: 4px 6px;
                gap: 4px;
                border-radius: 10px;
                flex-wrap: wrap;
                justify-content: center;
            }

            /* Áªü‰∏ÄÊåáÁ§∫Âô®ÁßªÂä®Á´ØÊ†∑Âºè */
            .indicator,
            .speed-indicator,
            .time-indicator,
            .word-count-indicator,
            .read-count-indicator {
                padding: 5px 8px;
                font-size: 11px;
                gap: 3px;
                border-radius: 8px;
            }
            
            .time-value, .speed-value, .read-count-value, .word-count-value {
                font-size: 12px;
            }
            
            .speed-unit, .read-count-unit, .word-count-unit {
                font-size: 9px;
            }
            
            .time-icon, .speed-icon, .read-count-icon, .word-count-icon {
                font-size: 12px;
            }

            /* ÊåâÈíÆÁßªÂä®Á´ØÊ†∑Âºè - Êõ¥Á¥ßÂáë */
            .toggle-sidebar {
                padding: 8px 12px;
                font-size: 13px;
            }
            
            .settings-btn,
            .library-btn,
            .vocab-btn,
            .looked-up-btn,
            .upload-btn {
                padding: 8px 10px;
                font-size: 12px;
            }

            /* ÈòÖËØªÂå∫ÂüüÁßªÂä®Á´ØÈÄÇÈÖç */
            .reader-container {
                padding: 15px;
            }
            
            .reader-content {
                padding: 25px 20px;
                border-radius: 6px;
            }

            /* Ê¨¢ËøéÁïåÈù¢ÁßªÂä®Á´Ø */
            .drop-zone {
                padding: 40px 30px;
            }
            
            .welcome-screen svg {
                width: 80px;
                height: 80px;
            }
            
            .welcome-screen h2 {
                font-size: 20px;
            }
            
            .welcome-screen p {
                font-size: 14px;
            }

            /* Ê®°ÊÄÅÊ°ÜÁßªÂä®Á´ØÈÄÇÈÖç */
            .library-content,
            .vocab-content,
            .modal-content {
                width: 95%;
                max-height: 90vh;
            }

            .library-book {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
                padding: 14px 16px;
            }

            .library-book .book-title {
                display: flex !important;
                font-size: 15px;
            }

            .book-meta {
                flex-wrap: wrap;
                gap: 10px;
            }

            .book-actions {
                margin-left: 0;
                width: 100%;
                gap: 8px;
            }
            .book-actions button { 
                flex: 1; 
                padding: 12px 16px;
            }

            .vocab-header {
                flex-direction: column;
                gap: 12px;
                align-items: stretch;
                padding: 20px;
            }

            .vocab-header h2 {
                font-size: 18px;
            }

            .vocab-header-actions { 
                width: 100%;
                flex-direction: row-reverse;
            }
            .vocab-search { 
                flex: 1; 
                width: auto;
                padding: 10px 14px;
            }
            .vocab-word { 
                padding: 12px 14px;
            }
            .vocab-word-delete { opacity: 1; }

            .vocab-word-meta {
                flex-wrap: wrap;
                gap: 8px;
            }

            .looked-up-word .vocab-word-meta {
                justify-content: flex-start;
            }

            .vocab-footer {
                flex-direction: column;
                gap: 10px;
                padding: 16px;
            }
            .vocab-footer button { 
                width: 100%;
                padding: 14px 20px;
            }
            
            /* ËØçÊ±áÊ†áÊ≥®ÊµÆÁ™óÁßªÂä®Á´Ø */
            .annotation-tooltip {
                min-width: 150px;
                max-width: 280px;
                font-size: 13px;
                padding: 8px 12px;
            }
        }
        
        /* ÂìçÂ∫îÂºèËÆæËÆ° - ÊâãÊú∫ */
        @media (max-width: 480px) {
            /* Â∑•ÂÖ∑Ê†èÊõ¥Á¥ßÂáë */
            .toolbar {
                padding: 8px 10px;
                gap: 6px;
            }
            
            /* ÁªüËÆ°ÊåáÁ§∫Âô® - ÈöêËóèÈÉ®ÂàÜÊñáÂ≠ó */
            .stats-group {
                padding: 3px 5px;
                gap: 3px;
            }
            
            .speed-unit, .read-count-unit, .word-count-unit {
                display: none;
            }
            
            .indicator,
            .speed-indicator,
            .time-indicator,
            .word-count-indicator,
            .read-count-indicator {
                padding: 4px 6px;
                font-size: 10px;
                gap: 2px;
            }
            
            .time-value, .speed-value, .read-count-value, .word-count-value {
                font-size: 11px;
            }
            
            .time-icon, .speed-icon, .read-count-icon, .word-count-icon {
                font-size: 11px;
            }
            
            /* ÊåâÈíÆÂè™ÊòæÁ§∫ÂõæÊ†á */
            .toggle-sidebar {
                padding: 8px 10px;
                font-size: 14px;
            }
            .toggle-sidebar::after {
                content: none;
            }
            
            .settings-btn,
            .library-btn,
            .vocab-btn,
            .looked-up-btn,
            .upload-btn {
                padding: 8px;
                font-size: 14px;
                min-width: 36px;
                text-align: center;
            }
            
            /* ÈöêËóèÊåâÈíÆÊñáÂ≠óÔºåÂè™‰øùÁïôÂõæÊ†á */
            .settings-btn { font-size: 0; }
            .settings-btn::before { content: '‚öô'; font-size: 16px; }
            
            .library-btn { font-size: 0; }
            .library-btn::before { content: 'üìö'; font-size: 16px; }
            
            .vocab-btn { font-size: 0; }
            .vocab-btn::before { content: 'üìñ'; font-size: 16px; }
            
            .looked-up-btn { font-size: 0; }
            .looked-up-btn::before { content: 'üîç'; font-size: 16px; }
            
            .upload-btn { font-size: 0; }
            .upload-btn::before { content: 'üìÇ'; font-size: 16px; }
            
            .toggle-sidebar { font-size: 0; }
            .toggle-sidebar::before { content: '‚ò∞'; font-size: 16px; }
            
            /* ÈòÖËØªÂå∫Âüü */
            .reader-container {
                padding: 10px;
            }
            
            .reader-content {
                padding: 20px 15px;
                font-size: 16px;
                line-height: 1.7;
            }
            
            .reader-content h1 { font-size: 1.6em; }
            .reader-content h2 { font-size: 1.4em; }
            .reader-content h3 { font-size: 1.2em; }
            
            /* Ê¨¢ËøéÁïåÈù¢ */
            .drop-zone {
                padding: 30px 20px;
            }
            
            .welcome-screen svg {
                width: 60px;
                height: 60px;
                margin-bottom: 20px;
            }
            
            .welcome-screen h2 {
                font-size: 18px;
            }
            
            .welcome-screen p {
                font-size: 13px;
                margin-bottom: 20px;
            }
            
            /* ‰æßËæπÊ†è */
            .sidebar {
                width: 85vw;
                max-width: 300px;
            }
            
            .sidebar-header {
                padding: 15px;
            }
            
            .toc-item {
                padding: 10px 15px;
                font-size: 13px;
            }
            
            /* ËÆæÁΩÆÈù¢Êùø */
            .settings-panel {
                right: 5px;
                left: 5px;
                padding: 20px 15px;
                max-height: 65vh;
            }
            
            .setting-group {
                margin-bottom: 15px;
            }
            
            /* Ê®°ÊÄÅÊ°Ü */
            .library-content,
            .vocab-content,
            .modal-content {
                width: 98%;
                max-height: 95vh;
                border-radius: 12px;
            }
            
            .library-header,
            .vocab-header {
                padding: 16px;
            }
            
            .library-header h2,
            .vocab-header h2 {
                font-size: 16px;
            }
            
            .library-book {
                padding: 12px;
            }
            
            .book-actions button {
                padding: 10px 12px;
                font-size: 12px;
            }
            
            /* ËØçÊ±áÊ†áÊ≥®ÊµÆÁ™ó */
            .annotation-tooltip {
                min-width: 120px;
                max-width: 200px;
                font-size: 12px;
                padding: 6px 10px;
            }
            
            /* ËøõÂ∫¶ÊåáÁ§∫Âô® */
            .progress-indicator {
                padding: 4px 8px;
                font-size: 11px;
            }
            
            .progress-bar-container {
                width: 40px;
            }
        }
        
        /* Ë∂ÖÂ∞èÂ±èÂπï */
        @media (max-width: 360px) {
            .toolbar {
                padding: 6px 8px;
                gap: 4px;
            }
            
            .stats-group {
                display: none;
            }
            
            .settings-btn,
            .library-btn,
            .vocab-btn,
            .looked-up-btn,
            .upload-btn,
            .toggle-sidebar {
                padding: 6px;
                min-width: 32px;
            }
            
            .reader-content {
                padding: 15px 12px;
                font-size: 15px;
            }
        }
        
        /* Ëß¶Êë∏ËÆæÂ§á‰ºòÂåñ */
        @media (hover: none) and (pointer: coarse) {
            /* Â¢ûÂ§ßËß¶Êë∏ÁõÆÊ†á */
            .toc-item {
                min-height: 44px;
                display: flex;
                align-items: center;
            }
            
            .btn,
            .settings-btn,
            .library-btn,
            .vocab-btn,
            .looked-up-btn,
            .upload-btn,
            .toggle-sidebar {
                min-height: 44px;
            }
            
            /* ËØçÊ±áÈ°πËß¶Êë∏‰ºòÂåñ */
            .vocab-word {
                min-height: 48px;
            }
            
            .vocab-word-delete {
                opacity: 1;
                min-width: 44px;
                min-height: 44px;
            }
            
            /* ÁßªÈô§hoverÊïàÊûúÁöÑÂª∂Ëøü */
            .annotation-word:hover .annotation-tooltip {
                transition-delay: 0s;
            }
        }
        
        /* iOS Safari ÁÇπÂáª‰øÆÂ§ç */
        button, 
        .btn,
        .settings-btn,
        .library-btn,
        .vocab-btn,
        .looked-up-btn,
        .upload-btn,
        .toggle-sidebar,
        .toc-item,
        .library-book,
        .vocab-word,
        [onclick],
        [role="button"] {
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0.1);
            -webkit-touch-callout: none;
            touch-action: manipulation;
        }
        
        /* Á°Æ‰øùÊåâÈíÆÂèØÁÇπÂáª */
        button:not(:disabled) {
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
        }
        
        /* Ê®™Â±èÊâãÊú∫‰ºòÂåñ */
        @media (max-height: 500px) and (orientation: landscape) {
            .toolbar {
                padding: 6px 10px;
            }
            
            .reader-container {
                padding: 10px;
            }
            
            .reader-content {
                padding: 15px 20px;
            }
            
            .settings-panel {
                max-height: 80vh;
                top: 50px;
                bottom: auto;
            }
            
            .modal-content,
            .library-content,
            .vocab-content {
                max-height: 90vh;
            }
        }

        /* ËØçÊ±áÊ†áÊ≥®ÊµÆÁ™óÊ†∑Âºè */
        /* ËØçÈ¢ë ‚â• ÈòàÂÄº - ‰ªÖÁªøËâ≤‰∏ãÂàíÁ∫øÔºåÊó†ËÉåÊôØ */
        .annotation-word {
            position: relative;
            border-bottom: 1px dashed #27ae60;
            cursor: help;
            color: inherit;
        }

        .annotation-word:hover {
            background-color: rgba(39, 174, 95, 0.025);
        }

        /* ËØçÈ¢ë < ÈòàÂÄº - ÁªøËâ≤‰∏ãÂàíÁ∫ø + ËÉåÊôØ */
        .annotation-word.low-freq {
            background-color: rgba(39, 174, 95, 0.065);
            border-radius: 2px;
            padding: 0 1px;
        }

        .annotation-word.low-freq:hover {
            background-color: rgba(39, 174, 96, 0.2);
        }

        .annotation-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #2c3e50;
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 14px;
            white-space: pre-line;
            min-width: 200px;
            max-width: 400px;
            width: max-content;
            text-align: left;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            pointer-events: none;
            margin-bottom: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .annotation-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #2c3e50;
        }

        .annotation-word:hover .annotation-tooltip {
            opacity: 1;
            visibility: visible;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="spinner"></div>
        <p>Ê≠£Âú®Âä†ËΩΩÊñá‰ª∂...</p>
    </div>

    <!-- ÈÄâËØçÊµÆÂä®ÊåâÈíÆ -->
    <button class="word-action-btn" id="word-action-btn">+ Âä†ÂÖ•Â∑≤Áü•ËØçÊ±áË°®</button>

    <div class="container">
        <div class="sidebar-overlay" id="sidebar-overlay"></div>
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h2>ÁõÆÂΩï</h2>
            </div>
            <nav class="toc-container" id="toc">
                <div style="padding: 20px; color: #7f8c8d; text-align: center;">
                    ËØ∑ÂÖà‰∏ä‰º† EPUB Êñá‰ª∂
                </div>
            </nav>
        </aside>

        <main class="main-content">
            <div class="toolbar">
                <button class="toggle-sidebar" id="toggle-sidebar">‚ò∞ ÁõÆÂΩï</button>
                <span class="book-title" id="book-title">ÁîµÂ≠ê‰π¶ÈòÖËØªÂô®</span>
                <div class="progress-indicator" id="progress-indicator" style="display: none;">
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="progress-bar"></div>
                    </div>
                    <span class="progress-text" id="progress-text">0%</span>
                </div>
                <div class="stats-group">
                    <div class="time-indicator" id="time-indicator">
                        <span class="time-icon">‚è±Ô∏è</span>
                        <span class="time-value" id="time-value">0ÂàÜÈíü</span>
                    </div>
                    <div class="speed-indicator" id="speed-indicator">
                        <span class="speed-icon">‚ö°</span>
                        <span class="speed-value" id="speed-value">--</span>
                        <span class="speed-unit">ËØç/ÂàÜÈíü</span>
                    </div>
                    <div class="read-count-indicator" id="read-count-indicator">
                        <span class="read-count-icon">üëÅÔ∏è</span>
                        <span class="read-count-value" id="read-count-value">0</span>
                        <span class="read-count-unit">Â∑≤ËØª</span>
                    </div>
                    <div class="word-count-indicator" id="word-count-indicator">
                        <span class="word-count-icon">üìù</span>
                        <span class="word-count-value" id="word-count-value">0</span>
                        <span class="word-count-unit">ÊÄªËØç</span>
                    </div>
                </div>
                <button class="settings-btn" id="settings-btn">‚öô ËÆæÁΩÆ</button>
                <button class="library-btn" id="library-btn">üìö ‰π¶Êû∂</button>
                <button class="vocab-btn" id="vocab-btn">üìñ Â∑≤Áü•ËØçÊ±áË°®</button>
                <button class="looked-up-btn" id="looked-up-btn">üîç Â∑≤Êü•ËØ¢ËØçË°®</button>
                <label class="upload-btn" for="file-input">üìÇ ÊâìÂºÄÊñá‰ª∂</label>
                <input type="file" id="file-input" accept=".epub,.pdf">
            </div>

            <div class="settings-overlay" id="settings-overlay"></div>
            <div class="settings-panel" id="settings-panel">
                <h3>ÈòÖËØªËÆæÁΩÆ</h3>
                
                <div class="setting-group">
                    <label class="setting-label">Â≠ó‰Ωì</label>
                    <select class="font-select" id="font-family">
                        <option value="system">Á≥ªÁªüÈªòËÆ§</option>
                        <option value="serif">Ë°¨Á∫ø‰Ωì (Serif)</option>
                        <option value="sans-serif">Êó†Ë°¨Á∫ø‰Ωì (Sans-serif)</option>
                        <option value="'Noto Serif SC', 'Source Han Serif SC', serif">ÊÄùÊ∫êÂÆã‰Ωì</option>
                        <option value="'Noto Sans SC', 'Source Han Sans SC', sans-serif">ÊÄùÊ∫êÈªë‰Ωì</option>
                        <option value="'LXGW WenKai', cursive">ÈúûÈπúÊñáÊ•∑</option>
                        <option value="Georgia, serif">Georgia</option>
                        <option value="'Palatino Linotype', serif">Palatino</option>
                        <option value="'Times New Roman', serif">Times New Roman</option>
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="Verdana, sans-serif">Verdana</option>
                    </select>
                </div>

                <div class="setting-group">
                    <label class="setting-label">Â≠óÂè∑</label>
                    <div class="setting-row">
                        <input type="range" id="font-size" min="12" max="28" value="17" step="1">
                        <span class="setting-value" id="font-size-value">17px</span>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">Ë°åÈ´ò</label>
                    <div class="setting-row">
                        <input type="range" id="line-height" min="1.2" max="2.5" value="1.8" step="0.1">
                        <span class="setting-value" id="line-height-value">1.8</span>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">ÂÜÖÂÆπÂÆΩÂ∫¶</label>
                    <div class="setting-row">
                        <input type="range" id="content-width" min="500" max="1200" value="800" step="50">
                        <span class="setting-value" id="content-width-value">800px</span>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">‰æßËæπË∑ù</label>
                    <div class="setting-row">
                        <input type="range" id="padding" min="20" max="120" value="80" step="10">
                        <span class="setting-value" id="padding-value">80px</span>
                    </div>
                </div>

                <div class="setting-group" style="border-top: 1px solid #eee; padding-top: 15px; margin-top: 15px;">
                    <label class="setting-label" style="display: flex; align-items: center; justify-content: space-between;">
                        <span>ËØçÊ±áÊ†áÊ≥®</span>
                        <input type="checkbox" id="annotation-toggle" checked style="width: 18px; height: 18px; cursor: pointer;">
                    </label>
                </div>

                <div class="setting-group" id="freq-range-group">
                    <label class="setting-label">COCAËØçÈ¢ëËåÉÂõ¥</label>
                    <div class="setting-row" style="gap: 8px;">
                        <input type="number" id="freq-min" value="10000" min="1" max="60000" style="width: 70px; padding: 6px 8px; border: 2px solid #ecf0f1; border-radius: 6px; font-size: 13px;">
                        <span style="color: #7f8c8d;">-</span>
                        <input type="number" id="freq-max" value="60000" min="1" max="60000" style="width: 70px; padding: 6px 8px; border: 2px solid #ecf0f1; border-radius: 6px; font-size: 13px;">
                    </div>
                    <div style="font-size: 11px; color: #95a5a6; margin-top: 6px;">Êï∞Â≠óË∂äÂ§ßË°®Á§∫Ë∂äÁîüÂÉªÁöÑËØçÊ±á</div>
                </div>
                <div class="setting-group" id="learning-threshold-group">
                    <label class="setting-label">Â≠¶‰π†ËØçÈ¢ëÈòàÂÄº <span style="color: #e74c3c;">‚óè</span></label>
                    <div class="setting-row" style="gap: 8px;">
                        <input type="number" id="learning-threshold" value="20000" min="1" max="60000" style="width: 100px; padding: 6px 8px; border: 2px solid #ecf0f1; border-radius: 6px; font-size: 13px;">
                    </div>
                    <div style="font-size: 11px; color: #95a5a6; margin-top: 6px;">ËØçÈ¢ë‰Ωé‰∫éÊ≠§ÈòàÂÄºÁöÑÂçïËØçÊòæÁ§∫Á∫¢Ëâ≤‰∏ãÂàíÁ∫ø</div>
                </div>
                
                <div class="setting-group" style="border-top: 1px solid #eee; padding-top: 15px; margin-top: 15px;">
                    <label class="setting-label">Á¶ªÁ∫øËØçÂÖ∏ (ECDICT)</label>
                    <div style="font-size: 12px; color: #7f8c8d; margin-bottom: 8px;">
                        ÂΩì Google ÁøªËØë API Â§±ÊïàÊó∂Ëá™Âä®‰ΩøÁî®
                    </div>
                    <div id="dict-status" style="font-size: 11px; color: #27ae60; margin-top: 6px;"></div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px;">
                        <button id="reload-dict-btn" style="padding: 6px 12px; background: #3498db; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">ÈáçÊñ∞Âä†ËΩΩ</button>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px; margin-top: 12px;">
                        <label class="toggle-switch">
                            <input type="checkbox" id="offline-dict-priority">
                            <span class="toggle-slider"></span>
                        </label>
                        <span style="font-size: 13px; color: #34495e;">Á¶ªÁ∫øËØçÂÖ∏‰ºòÂÖà</span>
                    </div>
                    <div style="font-size: 11px; color: #95a5a6; margin-top: 6px;">ÂºÄÂêØÂêé‰ºòÂÖà‰ΩøÁî®Á¶ªÁ∫øËØçÂÖ∏ÁøªËØëÔºåÊü•‰∏çÂà∞Êó∂ÂÜçÁî® Google ÁøªËØë</div>
                </div>
                
                <div class="setting-group" style="border-top: 1px solid #eee; padding-top: 15px; margin-top: 15px;">
                    <label class="setting-label">AI ‰∏ä‰∏ãÊñáÁøªËØë (Qwen3-4B)</label>
                    <div style="font-size: 12px; color: #7f8c8d; margin-bottom: 8px;">
                        Ê†πÊçÆÂè•Â≠ê‰∏ä‰∏ãÊñáÔºåÂ∞ÜÂçïËØçÁøªËØë‰∏∫ÊúÄÂêàÈÄÇÁöÑ‰∏≠ÊñáÈáä‰πâ
                    </div>
                    <div id="llm-status" style="font-size: 11px; color: #95a5a6; margin-top: 6px;">Ê®°ÂûãÊú™Âä†ËΩΩ</div>
                    <div id="llm-progress" style="display: none; margin-top: 8px;">
                        <div style="background: #ecf0f1; border-radius: 4px; height: 6px; overflow: hidden;">
                            <div id="llm-progress-bar" style="background: #9b59b6; height: 100%; width: 0%; transition: width 0.3s;"></div>
                        </div>
                        <div id="llm-progress-text" style="font-size: 10px; color: #7f8c8d; margin-top: 4px;">‰∏ãËΩΩ‰∏≠...</div>
                    </div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px;">
                        <button id="load-llm-btn" style="padding: 6px 12px; background: #9b59b6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">Âä†ËΩΩÊ®°Âûã</button>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px; margin-top: 12px;">
                        <label class="toggle-switch">
                            <input type="checkbox" id="llm-enabled" disabled>
                            <span class="toggle-slider"></span>
                        </label>
                        <span style="font-size: 13px; color: #34495e;">ÂêØÁî® AI ‰∏ä‰∏ãÊñáÁøªËØë</span>
                    </div>
                    <div style="font-size: 11px; color: #95a5a6; margin-top: 6px;">ÈúÄË¶Å WebGPU ÊîØÊåÅÔºàChrome 113+Ôºâ„ÄÇÂ∑≤ÁºìÂ≠òÁöÑÊ®°Âûã‰ºöÂú®ÊâìÂºÄÈòÖËØªÂô®Êó∂Ëá™Âä®Âä†ËΩΩ</div>
                </div>
            </div>

            <div class="reader-container" id="reader-container">
                <div class="welcome-screen" id="welcome-screen">
                    <div class="drop-zone" id="drop-zone">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <path d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"/>
                        </svg>
                        <h2>ÁîµÂ≠ê‰π¶ÈòÖËØªÂô®</h2>
                        <p>ÊãñÊîæ EPUB Êàñ PDF Êñá‰ª∂Âà∞Ê≠§Â§ÑÔºåÊàñÁÇπÂáª‰∏äÊñπÊåâÈíÆÈÄâÊã©Êñá‰ª∂</p>
                    </div>
                </div>
                <div class="reader-content" id="reader-content" style="display: none;"></div>
            </div>
        </main>
    </div>

    <script>
        // ==================== ÂÖ®Â±ÄÈîôËØØÂ§ÑÁêÜ ====================
        window.onerror = function(message, source, lineno, colno, error) {
            console.error('ÂÖ®Â±ÄÈîôËØØ:', message, source, lineno, colno, error);
            // Âú®ÂºÄÂèëÊó∂ÂèØ‰ª•ÊòæÁ§∫ÈîôËØØ
            // alert('ÂèëÁîüÈîôËØØ: ' + message);
            return false;
        };
        
        window.addEventListener('unhandledrejection', function(event) {
            console.error('Êú™Â§ÑÁêÜÁöÑPromiseÊãíÁªù:', event.reason);
        });
        
        // ==================== Â§ñÈÉ®Â∫ìÊ£ÄÊü• ====================
        const checkLibraries = () => {
            const missing = [];
            if (typeof JSZip === 'undefined') missing.push('JSZip');
            if (typeof pdfjsLib === 'undefined') missing.push('PDF.js');
            if (typeof nlp === 'undefined') missing.push('Compromise');
            
            if (missing.length > 0) {
                console.warn('‰ª•‰∏ãÂ∫ìÊú™ËÉΩÂä†ËΩΩ:', missing.join(', '));
                // Êüê‰∫õÂäüËÉΩÂèØËÉΩÂèóÈôêÔºå‰ΩÜ‰∏çÈòªÊ≠¢Â∫îÁî®ËøêË°å
            }
            return missing;
        };
        
        // Âª∂ËøüÊ£ÄÊü•Â∫ìÂä†ËΩΩÔºàÁªôCDN‰∏Ä‰∫õÊó∂Èó¥Ôºâ
        setTimeout(checkLibraries, 2000);
        
        // ==================== Â∏∏ÈáèÂÆö‰πâ ====================
        const CONFIG = {
            // Êï∞ÊçÆÂ∫ìÈÖçÁΩÆ
            DB_NAME: 'EPUBReaderDB',
            DB_VERSION: 6,
            STORES: {
                BOOKS: 'books',
                PROGRESS: 'progress',
                KNOWN_WORDS: 'knownWords',
                OFFLINE_DICT: 'offlineDict',
                LOOKED_UP_WORDS: 'lookedUpWords'
            },
            
            // Êó∂Èó¥Èó¥ÈöîÔºàÊØ´ÁßíÔºâ
            INTERVALS: {
                SAVE_PROGRESS: 60000,      // ‰øùÂ≠òËøõÂ∫¶Èó¥Èöî
                UPDATE_TIME_DISPLAY: 10000, // Êõ¥Êñ∞Êó∂Èó¥ÊòæÁ§∫Èó¥Èöî
                UPDATE_SPEED: 3000,         // Êõ¥Êñ∞ÈòÖËØªÈÄüÂ∫¶Èó¥Èöî
                CHECK_READ: 500,            // Ê£ÄÊü•Â∑≤ËØªÊÆµËêΩÈó¥Èöî
                SAVE_DEBOUNCE: 500          // ‰øùÂ≠òËøõÂ∫¶Èò≤Êäñ
            },
            
            // ÈòÖËØªËøΩË∏™ÈÖçÁΩÆ
            READING: {
                SPEED_HISTORY_MINUTES: 5,   // ‰øùÁïôÈòÖËØªÈÄüÂ∫¶ÂéÜÂè≤Êó∂Èïø
                SPEED_CALC_MINUTES: 2,      // ËÆ°ÁÆóÈÄüÂ∫¶‰ΩøÁî®ÁöÑÊó∂Èó¥ËåÉÂõ¥
                MIN_SPEED_TIME: 0.25,       // ÊúÄÂ∞èËÆ°ÁÆóÊó∂Èó¥ÔºàÂàÜÈíüÔºâ
                MIN_WPM: 5,                 // ÊúÄÂ∞èÂêàÁêÜÈòÖËØªÈÄüÂ∫¶
                MAX_WPM: 2000,              // ÊúÄÂ§ßÂêàÁêÜÈòÖËØªÈÄüÂ∫¶
                WORDS_PER_SECOND: 5,        // ÂÅáËÆæÈòÖËØªÈÄüÂ∫¶
                ANNOTATION_GAP: 10          // ËØçÊ±áÊ†áÊ≥®ÂéªÈáçÊÆµËêΩÈó¥Èöî
            },
            
            // COCA ËØçÈ¢ëÈÖçÁΩÆ
            COCA: {
                DEFAULT_MIN: 10000,
                DEFAULT_MAX: 60000,
                DEFAULT_THRESHOLD: 20000
            },
            
            // ÈªòËÆ§ÈòÖËØªËÆæÁΩÆ
            DEFAULT_SETTINGS: {
                fontFamily: 'system',
                fontSize: 17,
                lineHeight: 1.8,
                contentWidth: 800,
                padding: 80
            },
            
            // Â§ñÈÉ®ËµÑÊ∫êURL
            URLS: {
                COCA: 'https://huiget.github.io/filtered_COCA60000.txt',
                DICT: [
                    'https://cdn.jsdelivr.net/gh/weirany/ecdict_json_import@master/words_bnc_only.json',
                    'https://raw.githubusercontent.com/weirany/ecdict_json_import/master/words_bnc_only.json'
                ],
                PDF_WORKER: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js'
            }
        };

        // ==================== iOS/Safari ÂÖºÂÆπÊÄß‰øÆÂ§ç ====================
        // Polyfill for File.arrayBuffer() - Êüê‰∫õÊóßÁâà iOS Safari ‰∏çÊîØÊåÅ
        if (!File.prototype.arrayBuffer) {
            File.prototype.arrayBuffer = function() {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = () => reject(reader.error);
                    reader.readAsArrayBuffer(this);
                });
            };
        }
        
        // Polyfill for Blob.arrayBuffer() - Êüê‰∫õÊóßÁâà iOS Safari ‰∏çÊîØÊåÅ
        if (!Blob.prototype.arrayBuffer) {
            Blob.prototype.arrayBuffer = function() {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = () => reject(reader.error);
                    reader.readAsArrayBuffer(this);
                });
            };
        }

        // ==================== Â∑•ÂÖ∑ÂáΩÊï∞ ====================
        const Utils = {
            // Èò≤ÊäñÂáΩÊï∞
            debounce(fn, delay) {
                let timer = null;
                return function(...args) {
                    clearTimeout(timer);
                    timer = setTimeout(() => fn.apply(this, args), delay);
                };
            },
            
            // ËäÇÊµÅÂáΩÊï∞
            throttle(fn, limit) {
                let inThrottle = false;
                return function(...args) {
                    if (!inThrottle) {
                        fn.apply(this, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                };
            },
            
            // ÂÆâÂÖ®ÁöÑ JSON Ëß£Êûê
            safeJsonParse(str, fallback = null) {
                try {
                    return JSON.parse(str);
                } catch {
                    return fallback;
                }
            },
            
            // Ê†ºÂºèÂåñÊï∞Â≠óÔºàÊ∑ªÂä†ÂçÉ‰ΩçÂàÜÈöîÁ¨¶Ôºâ
            formatNumber(num) {
                return num.toLocaleString();
            },
            
            // Ê†ºÂºèÂåñÊó∂Èó¥
            formatReadingTime(ms) {
                const seconds = Math.floor(ms / 1000);
                const minutes = Math.floor(seconds / 60);
                const hours = Math.floor(minutes / 60);
                
                if (hours > 0) return `${hours}Â∞èÊó∂${minutes % 60}ÂàÜÈíü`;
                if (minutes > 0) return `${minutes}ÂàÜÈíü`;
                return `${seconds}Áßí`;
            },
            
            // Ê†ºÂºèÂåñÊó•Êúü
            formatDate(timestamp) {
                const date = new Date(timestamp);
                const now = new Date();
                const diffDays = Math.floor((now - date) / (1000 * 60 * 60 * 24));
                
                if (diffDays === 0) return '‰ªäÂ§©';
                if (diffDays === 1) return 'Êò®Â§©';
                if (diffDays < 7) return `${diffDays}Â§©Ââç`;
                return date.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });
            },
            
            // ËÆ°ÁÆóÂçïËØçÊï∞
            countWords(text) {
                if (!text) return 0;
                return text.trim().split(/\s+/).filter(w => w.length > 0).length;
            },
            
            // Ëé∑Âèñ DOM ÂÖÉÁ¥†ÔºàÂ∏¶ÁºìÂ≠òÔºâ
            getElement: (() => {
                const cache = new Map();
                return (id) => {
                    if (!cache.has(id)) {
                        cache.set(id, document.getElementById(id));
                    }
                    return cache.get(id);
                };
            })(),
            
            // Ê∏ÖÈô§ÂÖÉÁ¥†ÁºìÂ≠òÔºàÁî®‰∫éÂä®ÊÄÅÂÜÖÂÆπÔºâ
            clearElementCache() {
                this.getElement = (() => {
                    const cache = new Map();
                    return (id) => {
                        if (!cache.has(id)) {
                            cache.set(id, document.getElementById(id));
                        }
                        return cache.get(id);
                    };
                })();
            },
            
            // ÂàõÂª∫ Promise ÂåÖË£ÖÁöÑ IndexedDB ËØ∑Ê±Ç
            promisifyRequest(request) {
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            },
            
            // ÂàõÂª∫ Promise ÂåÖË£ÖÁöÑ‰∫ãÂä°
            promisifyTransaction(transaction) {
                return new Promise((resolve, reject) => {
                    transaction.oncomplete = () => resolve();
                    transaction.onerror = () => reject(transaction.error);
                });
            }
        };

        // ==================== IndexedDB Â∑•ÂÖ∑Á±ª ====================
        class BookStorage {
            constructor() {
                this.dbName = CONFIG.DB_NAME;
                this.stores = CONFIG.STORES;
                this.db = null;
                this.isAvailable = true; // Ê†áËÆ∞ IndexedDB ÊòØÂê¶ÂèØÁî®
            }

            async init() {
                // Ê£ÄÊü• IndexedDB ÊòØÂê¶ÂèØÁî®ÔºàiOS Safari ÈöêÁßÅÊ®°Âºè‰∏ã‰∏çÂèØÁî®Ôºâ
                if (typeof indexedDB === 'undefined') {
                    console.warn('IndexedDB ‰∏çÂèØÁî®ÔºåÂ∞Ü‰ΩøÁî®ÈôçÁ∫ßÊ®°Âºè');
                    this.isAvailable = false;
                    return;
                }
                
                return new Promise((resolve, reject) => {
                    try {
                        const request = indexedDB.open(this.dbName, CONFIG.DB_VERSION);
                        
                        request.onerror = (e) => {
                            console.warn('IndexedDB ÊâìÂºÄÂ§±Ë¥•:', e.target.error);
                            this.isAvailable = false;
                            resolve(); // ‰∏çrejectÔºåÂÖÅËÆ∏Â∫îÁî®ÁªßÁª≠ËøêË°å
                        };
                        
                        request.onsuccess = () => {
                            this.db = request.result;
                            this.isAvailable = true;
                            resolve();
                        };
                        
                        request.onupgradeneeded = (e) => {
                            const db = e.target.result;
                            const { BOOKS, PROGRESS, KNOWN_WORDS, OFFLINE_DICT, LOOKED_UP_WORDS } = this.stores;
                            
                            // ‰π¶Á±çÂ≠òÂÇ®
                            if (!db.objectStoreNames.contains(BOOKS)) {
                                const bookStore = db.createObjectStore(BOOKS, { keyPath: 'id' });
                                bookStore.createIndex('lastOpenedAt', 'lastOpenedAt', { unique: false });
                            }
                            
                            // ÈòÖËØªËøõÂ∫¶Â≠òÂÇ®
                            if (!db.objectStoreNames.contains(PROGRESS)) {
                                db.createObjectStore(PROGRESS, { keyPath: 'bookId' });
                            }
                            
                            // Â∑≤Áü•ËØçÊ±áÂ≠òÂÇ®ÔºàË∑®‰π¶Êú¨Ôºâ
                            if (!db.objectStoreNames.contains(KNOWN_WORDS)) {
                                const knownWordsStore = db.createObjectStore(KNOWN_WORDS, { keyPath: 'lemma' });
                                knownWordsStore.createIndex('addedAt', 'addedAt', { unique: false });
                            }
                            
                            // Á¶ªÁ∫øËØçÂÖ∏Â≠òÂÇ®
                            if (!db.objectStoreNames.contains(OFFLINE_DICT)) {
                                db.createObjectStore(OFFLINE_DICT, { keyPath: 'id' });
                            }
                            
                            // Â∑≤Êü•ËØ¢ËØçÊ±áÂ≠òÂÇ®ÔºàËÆ∞ÂΩïÊÇ¨ÂÅúÊü•ÁúãËøáÁöÑËØçÊ±áÔºâ
                            if (!db.objectStoreNames.contains(LOOKED_UP_WORDS)) {
                                const lookedUpStore = db.createObjectStore(LOOKED_UP_WORDS, { keyPath: 'word' });
                                lookedUpStore.createIndex('lookedUpAt', 'lookedUpAt', { unique: false });
                            }
                        };
                    } catch (e) {
                        console.warn('IndexedDB ÂàùÂßãÂåñÂºÇÂ∏∏:', e);
                        this.isAvailable = false;
                        resolve(); // ÂÖÅËÆ∏Â∫îÁî®ÁªßÁª≠ËøêË°å
                    }
                });
            }
            
            // Ê£ÄÊü•ÊòØÂê¶ÂèØÁî®
            _checkAvailable() {
                if (!this.isAvailable || !this.db) {
                    return false;
                }
                return true;
            }
            
            // ÈÄöÁî®Â≠òÂÇ®Êìç‰Ωú - ÁÆÄÂåñÈáçÂ§ç‰ª£Á†Å
            _getStore(storeName, mode = 'readonly') {
                if (!this._checkAvailable()) return null;
                const transaction = this.db.transaction([storeName], mode);
                return transaction.objectStore(storeName);
            }
            
            async _simpleGet(storeName, key) {
                if (!this._checkAvailable()) return null;
                const store = this._getStore(storeName);
                if (!store) return null;
                return Utils.promisifyRequest(store.get(key));
            }
            
            async _simplePut(storeName, data) {
                if (!this._checkAvailable()) return null;
                const store = this._getStore(storeName, 'readwrite');
                if (!store) return null;
                return Utils.promisifyRequest(store.put(data));
            }
            
            async _simpleDelete(storeName, key) {
                if (!this._checkAvailable()) return null;
                const store = this._getStore(storeName, 'readwrite');
                if (!store) return null;
                return Utils.promisifyRequest(store.delete(key));
            }
            
            async _simpleGetAll(storeName) {
                if (!this._checkAvailable()) return [];
                const store = this._getStore(storeName);
                if (!store) return [];
                return Utils.promisifyRequest(store.getAll());
            }

            // ‰øùÂ≠òÁ¶ªÁ∫øËØçÂÖ∏
            async saveOfflineDict(dictData) {
                return this._simplePut(this.stores.OFFLINE_DICT, {
                    id: 'ecdict',
                    data: dictData,
                    cachedAt: Date.now()
                });
            }
            
            // Ëé∑ÂèñÁ¶ªÁ∫øËØçÂÖ∏
            async getOfflineDict() {
                return this._simpleGet(this.stores.OFFLINE_DICT, 'ecdict');
            }

            // ÁîüÊàê‰π¶Á±çÂîØ‰∏ÄÊ†áËØÜ
            async generateBookId(arrayBuffer, fileName) {
                const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.slice(0, 8).map(b => b.toString(16).padStart(2, '0')).join('');
                return `${fileName}-${hashHex}`;
            }

            // ‰øùÂ≠ò‰π¶Á±ç
            async saveBook(arrayBuffer, fileName, metadata = {}, fileType = 'epub') {
                const bookId = await this.generateBookId(arrayBuffer, fileName);
                const now = Date.now();
                
                await this._simplePut(this.stores.BOOKS, {
                    id: bookId,
                    data: arrayBuffer,
                    fileName,
                    title: metadata.title || fileName,
                    author: metadata.author || '',
                    fileType,
                    lastOpenedAt: now,
                    addedAt: now
                });
                
                return bookId;
            }

            // Êõ¥Êñ∞‰π¶Á±çÁöÑÊúÄÂêéÊâìÂºÄÊó∂Èó¥
            async updateLastOpened(bookId) {
                const book = await this._simpleGet(this.stores.BOOKS, bookId);
                if (book) {
                    book.lastOpenedAt = Date.now();
                    await this._simplePut(this.stores.BOOKS, book);
                }
            }

            // Ëé∑Âèñ‰π¶Á±ç
            async getBook(bookId) {
                return this._simpleGet(this.stores.BOOKS, bookId);
            }

            // Ëé∑ÂèñÊâÄÊúâ‰π¶Á±çÔºàÊåâÊúÄÂêéÊâìÂºÄÊó∂Èó¥ÊéíÂ∫èÔºâ
            async getAllBooks() {
                const books = await this._simpleGetAll(this.stores.BOOKS) || [];
                return books.sort((a, b) => (b.lastOpenedAt || 0) - (a.lastOpenedAt || 0));
            }

            // Âà†Èô§‰π¶Á±ç
            async deleteBook(bookId) {
                const { BOOKS, PROGRESS } = this.stores;
                const transaction = this.db.transaction([BOOKS, PROGRESS], 'readwrite');
                transaction.objectStore(BOOKS).delete(bookId);
                transaction.objectStore(PROGRESS).delete(bookId);
                return Utils.promisifyTransaction(transaction);
            }

            // ‰øùÂ≠òÈòÖËØªËøõÂ∫¶
            async saveProgress(bookId, progressData) {
                return this._simplePut(this.stores.PROGRESS, {
                    bookId,
                    scrollPosition: progressData.scrollPosition,
                    scrollPercentage: progressData.scrollPercentage,
                    totalReadingTime: progressData.totalReadingTime || 0,
                    lastReadAt: Date.now()
                });
            }

            // Ëé∑ÂèñÈòÖËØªËøõÂ∫¶
            async getProgress(bookId) {
                return this._simpleGet(this.stores.PROGRESS, bookId);
            }

            // Ê∑ªÂä†Â∑≤Áü•ËØçÊ±á
            async addKnownWord(lemma) {
                return this._simplePut(this.stores.KNOWN_WORDS, {
                    lemma: lemma.toLowerCase(),
                    addedAt: Date.now()
                });
            }

            // ÁßªÈô§Â∑≤Áü•ËØçÊ±á
            async removeKnownWord(lemma) {
                return this._simpleDelete(this.stores.KNOWN_WORDS, lemma.toLowerCase());
            }

            // Ê£ÄÊü•ËØçÊ±áÊòØÂê¶Â∑≤Áü•
            async isKnownWord(lemma) {
                const result = await this._simpleGet(this.stores.KNOWN_WORDS, lemma.toLowerCase());
                return !!result;
            }

            // Ëé∑ÂèñÊâÄÊúâÂ∑≤Áü•ËØçÊ±á
            async getAllKnownWords() {
                const words = await this._simpleGetAll(this.stores.KNOWN_WORDS) || [];
                return words.sort((a, b) => (b.addedAt || 0) - (a.addedAt || 0));
            }

            // Ê∏ÖÁ©∫ÊâÄÊúâÂ∑≤Áü•ËØçÊ±á
            async clearAllKnownWords() {
                const store = this._getStore(this.stores.KNOWN_WORDS, 'readwrite');
                return Utils.promisifyRequest(store.clear());
            }

            // Ê∑ªÂä†Â∑≤Êü•ËØ¢ËØçÊ±áÔºàÊÇ¨ÂÅúÊü•ÁúãËøáÁöÑËØçÊ±áÔºâ
            async addLookedUpWord(word, translation, rank) {
                try {
                    const existing = await this._simpleGet(this.stores.LOOKED_UP_WORDS, word.toLowerCase());
                    return this._simplePut(this.stores.LOOKED_UP_WORDS, {
                        word: word.toLowerCase(),
                        translation,
                        rank,
                        lookedUpAt: existing?.lookedUpAt || Date.now(),
                        lastLookedUpAt: Date.now(),
                        count: (existing?.count || 0) + 1
                    });
                } catch (e) {
                    console.warn('Ê∑ªÂä†Â∑≤Êü•ËØ¢ËØçÊ±áÂ§±Ë¥•:', e);
                }
            }

            // ÁßªÈô§Â∑≤Êü•ËØ¢ËØçÊ±á
            async removeLookedUpWord(word) {
                return this._simpleDelete(this.stores.LOOKED_UP_WORDS, word.toLowerCase());
            }

            // Ëé∑ÂèñÊâÄÊúâÂ∑≤Êü•ËØ¢ËØçÊ±á
            async getAllLookedUpWords() {
                try {
                    const words = await this._simpleGetAll(this.stores.LOOKED_UP_WORDS) || [];
                    return words.sort((a, b) => (b.lastLookedUpAt || 0) - (a.lastLookedUpAt || 0));
                } catch (e) {
                    console.warn('Ëé∑ÂèñÂ∑≤Êü•ËØ¢ËØçÊ±áÂ§±Ë¥•:', e);
                    return [];
                }
            }

            // Ê∏ÖÁ©∫ÊâÄÊúâÂ∑≤Êü•ËØ¢ËØçÊ±á
            async clearAllLookedUpWords() {
                const store = this._getStore(this.stores.LOOKED_UP_WORDS, 'readwrite');
                return Utils.promisifyRequest(store.clear());
            }

            // Ëé∑ÂèñÊúÄËøëÈòÖËØªÁöÑ‰π¶Á±çID
            getLastBookId() {
                return localStorage.getItem('epubLastBookId');
            }

            // ËÆæÁΩÆÊúÄËøëÈòÖËØªÁöÑ‰π¶Á±çID
            setLastBookId(bookId) {
                localStorage.setItem('epubLastBookId', bookId);
            }
        }

        class EPUBReader {
            constructor() {
                // Êñá‰ª∂Áõ∏ÂÖ≥Áä∂ÊÄÅ
                this.zip = null;
                this.pdfDoc = null;
                this.opfPath = '';
                this.opfDir = '';
                this.manifest = {};
                this.spine = [];
                this.toc = [];
                this.metadata = {};
                this.chapterElements = [];
                this.currentFileName = '';
                this.currentBookId = null;
                this.currentFileType = 'epub';
                this.bookStorage = new BookStorage();
                this.pendingScrollPosition = null;
                
                // ÈòÖËØªËøΩË∏™Áä∂ÊÄÅ
                this.readingHistory = [];
                this.totalCharacters = 0;
                this.speedUpdateInterval = null;
                this.readObserver = null;
                this.readParagraphs = new Map();
                this.totalReadCharacters = 0;
                this.lastReadCountTime = Date.now();
                this.readingSpeedHistory = [];
                this.readCheckInterval = null;
                
                // Êó∂Èó¥ËøΩË∏™Áä∂ÊÄÅ
                this.totalReadingTime = 0;
                this.sessionStartTime = null;
                this.isPageVisible = true;
                this.readingTimeInterval = null;
                this.timeDisplayInterval = null;
                
                // ‰ΩøÁî®Â∏∏ÈáèÈªòËÆ§ËÆæÁΩÆ
                this.settings = { ...CONFIG.DEFAULT_SETTINGS };
                
                // ËØçÊ±áÊ†áÊ≥®Áä∂ÊÄÅ
                this.annotationEnabled = true;
                this.freqMin = CONFIG.COCA.DEFAULT_MIN;
                this.freqMax = CONFIG.COCA.DEFAULT_MAX;
                this.learningThreshold = CONFIG.COCA.DEFAULT_THRESHOLD;
                this.cocaRanks = new Map();
                this.cocaLoaded = false;
                this.annotationObserver = null;
                this.annotatedParagraphs = new Set();
                
                // ËØçÊ±áË°®Áä∂ÊÄÅ
                this.knownWords = new Set();
                this.selectedWordInfo = null;
                
                // Â∑≤Êü•ËØ¢ËØçÊ±áÁä∂ÊÄÅÔºàÊÇ¨ÂÅúÊü•ÁúãËøáÁöÑËØçÊ±áÔºâ
                this.lookedUpWords = new Map();
                
                // Á¶ªÁ∫øËØçÂÖ∏Áä∂ÊÄÅ
                this.offlineDict = new Map();
                this.offlineDictLoaded = false;
                this.offlineDictPriority = false;
                
                // LLM ‰∏ä‰∏ãÊñáÁøªËØëÁä∂ÊÄÅ
                this.llmEngine = null;
                this.llmLoading = false;
                this.llmEnabled = false;
                this.llmModelId = 'Qwen3-4B-q4f16_1-MLC';
                
                // ÂàùÂßãÂåñ
                this._init();
            }
            
            // ÂàùÂßãÂåñÊñπÊ≥ï - ÂàÜÁ¶ªÊûÑÈÄ†ÂáΩÊï∞ÈÄªËæë
            _init() {
                console.log('ÂºÄÂßãÂàùÂßãÂåñÈòÖËØªÂô®...');
                
                try {
                    this.loadSettings();
                    console.log('ËÆæÁΩÆÂä†ËΩΩÂÆåÊàê');
                } catch (e) {
                    console.error('Âä†ËΩΩËÆæÁΩÆÂ§±Ë¥•:', e);
                }
                
                try {
                    this.loadAnnotationSettings();
                    console.log('Ê†áÊ≥®ËÆæÁΩÆÂä†ËΩΩÂÆåÊàê');
                } catch (e) {
                    console.error('Âä†ËΩΩÊ†áÊ≥®ËÆæÁΩÆÂ§±Ë¥•:', e);
                }
                
                try {
                    this.initEventListeners();
                    console.log('‰∫ã‰ª∂ÁõëÂê¨Âô®ÂàùÂßãÂåñÂÆåÊàê');
                } catch (e) {
                    console.error('ÂàùÂßãÂåñ‰∫ã‰ª∂ÁõëÂê¨Âô®Â§±Ë¥•:', e);
                }
                
                try {
                    this.initSettingsListeners();
                    console.log('ËÆæÁΩÆÁõëÂê¨Âô®ÂàùÂßãÂåñÂÆåÊàê');
                } catch (e) {
                    console.error('ÂàùÂßãÂåñËÆæÁΩÆÁõëÂê¨Âô®Â§±Ë¥•:', e);
                }
                
                try {
                    this.loadLLMSettings();
                    console.log('LLM ËÆæÁΩÆÂä†ËΩΩÂÆåÊàê');
                } catch (e) {
                    console.error('Âä†ËΩΩ LLM ËÆæÁΩÆÂ§±Ë¥•:', e);
                }
                
                try {
                    this.initVisibilityTracking();
                    console.log('ÂèØËßÅÊÄßË∑üË∏™ÂàùÂßãÂåñÂÆåÊàê');
                } catch (e) {
                    console.error('ÂàùÂßãÂåñÂèØËßÅÊÄßË∑üË∏™Â§±Ë¥•:', e);
                }
                
                try {
                    this.applySettings();
                    console.log('ËÆæÁΩÆÂ∫îÁî®ÂÆåÊàê');
                } catch (e) {
                    console.error('Â∫îÁî®ËÆæÁΩÆÂ§±Ë¥•:', e);
                }
                
                try {
                    this.initStorage();
                    console.log('Â≠òÂÇ®ÂàùÂßãÂåñÂºÄÂßã');
                } catch (e) {
                    console.error('ÂàùÂßãÂåñÂ≠òÂÇ®Â§±Ë¥•:', e);
                }
                
                console.log('ÈòÖËØªÂô®ÂàùÂßãÂåñÂÆåÊàê');
            }

            // ÂàùÂßãÂåñÈ°µÈù¢ÂèØËßÅÊÄßË∑üË∏™
            initVisibilityTracking() {
                // È°µÈù¢ÂèØËßÅÊÄßÂèòÂåñ
                document.addEventListener('visibilitychange', () => {
                    document.hidden ? this.pauseReadingTime() : this.resumeReadingTime();
                });
                
                // Á™óÂè£ÁÑ¶ÁÇπÂèòÂåñ
                window.addEventListener('blur', () => this.pauseReadingTime());
                window.addEventListener('focus', () => this.resumeReadingTime());
                
                // È°µÈù¢Âç∏ËΩΩÊó∂‰øùÂ≠òÂπ∂Ê∏ÖÁêÜ
                window.addEventListener('beforeunload', () => {
                    this.pauseReadingTime();
                    this.saveReadingProgress();
                    this.cleanup();
                });
            }

            // Ê∏ÖÈô§ÂÆöÊó∂Âô®ÁöÑËæÖÂä©ÊñπÊ≥ï
            _clearIntervals(...intervals) {
                intervals.forEach(intervalName => {
                    if (this[intervalName]) {
                        clearInterval(this[intervalName]);
                        this[intervalName] = null;
                    }
                });
            }

            // ÂºÄÂßãËÆ°Êó∂
            startReadingTime() {
                this._clearIntervals('readingTimeInterval', 'timeDisplayInterval');
                
                this.sessionStartTime = Date.now();
                this.isPageVisible = !document.hidden;
                
                const { SAVE_PROGRESS, UPDATE_TIME_DISPLAY } = CONFIG.INTERVALS;
                
                this.readingTimeInterval = setInterval(() => {
                    if (this.isPageVisible && this.currentBookId) {
                        this.saveReadingProgress();
                    }
                }, SAVE_PROGRESS);
                
                this.timeDisplayInterval = setInterval(() => {
                    this.updateTimeDisplay();
                }, UPDATE_TIME_DISPLAY);
            }

            // ÊöÇÂÅúËÆ°Êó∂
            pauseReadingTime() {
                if (this.isPageVisible && this.sessionStartTime) {
                    this.totalReadingTime += Date.now() - this.sessionStartTime;
                    this.sessionStartTime = null;
                }
                this.isPageVisible = false;
            }

            // ÊÅ¢Â§çËÆ°Êó∂
            resumeReadingTime() {
                if (!this.isPageVisible && this.currentBookId) {
                    this.sessionStartTime = Date.now();
                    this.isPageVisible = true;
                }
            }

            // Ëé∑ÂèñÂΩìÂâçÁ¥ØËÆ°ÈòÖËØªÊó∂Èó¥
            getCurrentReadingTime() {
                let total = this.totalReadingTime;
                if (this.isPageVisible && this.sessionStartTime) {
                    total += Date.now() - this.sessionStartTime;
                }
                return total;
            }

            // ‰ΩøÁî®Â∑•ÂÖ∑ÂáΩÊï∞Ê†ºÂºèÂåñÊó∂Èó¥
            formatReadingTime(ms) {
                return Utils.formatReadingTime(ms);
            }

            // ÂàùÂßãÂåñÂ≠òÂÇ®Âπ∂Â∞ùËØïÂä†ËΩΩ‰∏äÊ¨°ÁöÑ‰π¶Á±ç
            async initStorage() {
                try {
                    await this.bookStorage.init();
                    // Âπ∂Ë°åÂä†ËΩΩCOCAËØçÈ¢ëË°®„ÄÅÂ∑≤Áü•ËØçÊ±á„ÄÅÂ∑≤Êü•ËØ¢ËØçÊ±áÂíåÁ¶ªÁ∫øËØçÂÖ∏
                    await Promise.all([
                        this.loadCOCAList(),
                        this.initKnownWords(),
                        this.initLookedUpWords(),
                        this.loadOfflineDict()
                    ]);
                    await this.loadLastBook();
                } catch (e) {
                    console.warn('Êó†Ê≥ïÂàùÂßãÂåñÂ≠òÂÇ®:', e);
                }
            }
            
            // Âä†ËΩΩÁ¶ªÁ∫øËØçÂÖ∏Ôºà‰ºòÂÖà‰ªé IndexedDB ÁºìÂ≠òÔºåÂê¶Âàô‰ªé CDN Âä†ËΩΩÔºâ
            async loadOfflineDict(forceReload = false) {
                // ÂÖàÂ∞ùËØï‰ªé IndexedDB Âä†ËΩΩÁºìÂ≠ò
                if (!forceReload) {
                    try {
                        const cached = await this.bookStorage.getOfflineDict();
                        if (cached?.data) {
                            this._populateOfflineDict(cached.data);
                            this.offlineDictLoaded = true;
                            console.log(`Á¶ªÁ∫øËØçÂÖ∏‰ªéÁºìÂ≠òÂä†ËΩΩÂÆåÊàêÔºåÂÖ± ${this.offlineDict.size} Êù°`);
                            this.updateDictStatus();
                            return;
                        }
                    } catch (e) {
                        console.warn('‰ªé IndexedDB Âä†ËΩΩËØçÂÖ∏ÁºìÂ≠òÂ§±Ë¥•:', e);
                    }
                }
                
                this.updateDictStatus('Ê≠£Âú®Âä†ËΩΩËØçÂÖ∏...');
                
                // ‰ªé CDN Âä†ËΩΩ
                for (const url of CONFIG.URLS.DICT) {
                    try {
                        console.log(`Â∞ùËØï‰ªé ${url} Âä†ËΩΩËØçÂÖ∏...`);
                        const response = await fetch(url);
                        if (!response.ok) continue;
                        
                        const data = await response.json();
                        this.offlineDict.clear();
                        this._parseDictData(data);
                        
                        this.offlineDictLoaded = true;
                        console.log(`Á¶ªÁ∫øËØçÂÖ∏Âä†ËΩΩÂÆåÊàêÔºåÂÖ± ${this.offlineDict.size} Êù°`);
                        
                        // ÁºìÂ≠òÂà∞ IndexedDB
                        this._cacheDictToStorage();
                        this.updateDictStatus();
                        return;
                    } catch (e) {
                        console.warn(`‰ªé ${url} Âä†ËΩΩËØçÂÖ∏Â§±Ë¥•:`, e);
                    }
                }
                
                console.warn('ÊâÄÊúâËØçÂÖ∏Ê∫êÂä†ËΩΩÂ§±Ë¥•');
                this.updateDictStatus('Âä†ËΩΩÂ§±Ë¥•ÔºåÁøªËØëÂ∞Ü‰ΩøÁî® Google API');
            }
            
            // ËæÖÂä©ÊñπÊ≥ïÔºöÂ°´ÂÖÖÁ¶ªÁ∫øËØçÂÖ∏
            _populateOfflineDict(data) {
                for (const [word, translation] of Object.entries(data)) {
                    this.offlineDict.set(word.toLowerCase(), translation);
                }
            }
            
            // ËæÖÂä©ÊñπÊ≥ïÔºöËß£ÊûêËØçÂÖ∏Êï∞ÊçÆ
            _parseDictData(data) {
                if (Array.isArray(data)) {
                    // Êï∞ÁªÑÊ†ºÂºè
                    for (const item of data) {
                        if (item.word && item.translation) {
                            this.offlineDict.set(item.word.toLowerCase(), item.translation);
                        }
                    }
                } else {
                    // ÂØπË±°Ê†ºÂºè
                    for (const [word, value] of Object.entries(data)) {
                        const translation = typeof value === 'string' 
                            ? value 
                            : (value?.translation || value?.trans || value?.zh || '');
                        if (translation) {
                            this.offlineDict.set(word.toLowerCase(), translation);
                        }
                    }
                }
            }
            
            // ËæÖÂä©ÊñπÊ≥ïÔºöÁºìÂ≠òËØçÂÖ∏Âà∞Â≠òÂÇ®
            async _cacheDictToStorage() {
                try {
                    const cacheObj = Object.fromEntries(this.offlineDict);
                    await this.bookStorage.saveOfflineDict(cacheObj);
                    console.log('ËØçÂÖ∏Â∑≤ÁºìÂ≠òÂà∞ IndexedDB');
                } catch (e) {
                    console.warn('ÁºìÂ≠òËØçÂÖ∏Â§±Ë¥•:', e);
                }
            }
            
            // ‰ªéÁ¶ªÁ∫øËØçÂÖ∏Êü•ËØ¢ÁøªËØë
            getOfflineTranslation(word) {
                if (!this.offlineDictLoaded || this.offlineDict.size === 0) return null;
                const translation = this.offlineDict.get(word.toLowerCase());
                // Â∞ÜÂ≠óÈù¢ÁöÑ \n ËΩ¨Êç¢‰∏∫ÁúüÊ≠£ÁöÑÊç¢Ë°åÁ¨¶
                return translation ? translation.replace(/\\n/g, '\n') : null;
            }

            // ==================== LLM ‰∏ä‰∏ãÊñáÁøªËØëÁõ∏ÂÖ≥ÊñπÊ≥ï ====================
            
            // Ê£ÄÊü•ÊµèËßàÂô®ÊòØÂê¶ÊîØÊåÅ WebGPU
            async checkWebGPUSupport() {
                if (!navigator.gpu) {
                    return { supported: false, reason: 'ÊµèËßàÂô®‰∏çÊîØÊåÅ WebGPU' };
                }
                try {
                    const adapter = await navigator.gpu.requestAdapter();
                    if (!adapter) {
                        return { supported: false, reason: 'Êó†Ê≥ïËé∑Âèñ GPU ÈÄÇÈÖçÂô®' };
                    }
                    return { supported: true };
                } catch (e) {
                    return { supported: false, reason: e.message };
                }
            }
            
            // Ê£ÄÊü•Ê®°ÂûãÊòØÂê¶Â∑≤ÁºìÂ≠ò
            async checkModelCached() {
                try {
                    // WebLLM ‰ΩøÁî® Cache API Â≠òÂÇ®Ê®°Âûã
                    const cache = await caches.open('webllm/model');
                    const keys = await cache.keys();
                    // Á≤æÁ°ÆÂåπÈÖçÂΩìÂâç‰ΩøÁî®ÁöÑ model id
                    const hasModel = keys.some(req => req.url.includes(this.llmModelId));
                    return hasModel;
                } catch (e) {
                    console.warn('Ê£ÄÊü•Ê®°ÂûãÁºìÂ≠òÂ§±Ë¥•:', e);
                    return false;
                }
            }
            
            // Êõ¥Êñ∞ LLM Áä∂ÊÄÅÊòæÁ§∫
            updateLLMStatus(message, isError = false) {
                const statusEl = document.getElementById('llm-status');
                if (statusEl) {
                    statusEl.textContent = message;
                    statusEl.style.color = isError ? '#e74c3c' : '#27ae60';
                }
            }
            
            // Êõ¥Êñ∞ LLM Âä†ËΩΩËøõÂ∫¶
            updateLLMProgress(progress) {
                const progressContainer = document.getElementById('llm-progress');
                const progressBar = document.getElementById('llm-progress-bar');
                const progressText = document.getElementById('llm-progress-text');
                
                if (progressContainer && progressBar && progressText) {
                    progressContainer.style.display = 'block';
                    
                    // progress ÂØπË±°ÂåÖÂê´ text Âíå progress Â±ûÊÄß
                    const percent = Math.round((progress.progress || 0) * 100);
                    progressBar.style.width = `${percent}%`;
                    progressText.textContent = progress.text || `Âä†ËΩΩ‰∏≠... ${percent}%`;
                }
            }
            
            // ÈöêËóèËøõÂ∫¶Êù°
            hideLLMProgress() {
                const progressContainer = document.getElementById('llm-progress');
                if (progressContainer) {
                    progressContainer.style.display = 'none';
                }
            }
            
            // ÊòæÁ§∫Á°ÆËÆ§ÂØπËØùÊ°Ü
            showConfirmDialog({ title, message, confirmText = 'Á°ÆÂÆö', cancelText = 'ÂèñÊ∂à' }) {
                return new Promise((resolve) => {
                    // ÂàõÂª∫Ê®°ÊÄÅÊ°Ü
                    const overlay = document.createElement('div');
                    overlay.style.cssText = `
                        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                        background: rgba(0,0,0,0.5); z-index: 10000;
                        display: flex; align-items: center; justify-content: center;
                    `;
                    
                    const dialog = document.createElement('div');
                    dialog.style.cssText = `
                        background: white; border-radius: 12px; padding: 24px;
                        max-width: 400px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.3);
                    `;
                    
                    dialog.innerHTML = `
                        <h3 style="margin: 0 0 16px 0; color: #2c3e50; font-size: 18px;">${title}</h3>
                        <p style="margin: 0 0 24px 0; color: #7f8c8d; font-size: 14px; line-height: 1.6; white-space: pre-line;">${message}</p>
                        <div style="display: flex; gap: 12px; justify-content: flex-end;">
                            <button id="dialog-cancel" style="padding: 10px 20px; border: 1px solid #ddd; background: white; border-radius: 6px; cursor: pointer; font-size: 14px;">${cancelText}</button>
                            <button id="dialog-confirm" style="padding: 10px 20px; border: none; background: #9b59b6; color: white; border-radius: 6px; cursor: pointer; font-size: 14px;">${confirmText}</button>
                        </div>
                    `;
                    
                    overlay.appendChild(dialog);
                    document.body.appendChild(overlay);
                    
                    const cleanup = (result) => {
                        document.body.removeChild(overlay);
                        resolve(result);
                    };
                    
                    dialog.querySelector('#dialog-confirm').onclick = () => cleanup(true);
                    dialog.querySelector('#dialog-cancel').onclick = () => cleanup(false);
                    overlay.onclick = (e) => { if (e.target === overlay) cleanup(false); };
                });
            }
            
            // ÊèêÁ§∫‰∏ãËΩΩÊ®°Âûã
            async promptModelDownload() {
                // ÂÖàÊ£ÄÊü• WebGPU ÊîØÊåÅ
                const gpuCheck = await this.checkWebGPUSupport();
                if (!gpuCheck.supported) {
                    this.updateLLMStatus(`‰∏çÊîØÊåÅ: ${gpuCheck.reason}`, true);
                    alert(`ÊÇ®ÁöÑÊµèËßàÂô®‰∏çÊîØÊåÅ WebGPUÔºö${gpuCheck.reason}\n\nËØ∑‰ΩøÁî® Chrome 113+ ÊàñÂÖ∂‰ªñÊîØÊåÅ WebGPU ÁöÑÊµèËßàÂô®„ÄÇ`);
                    return false;
                }
                
                // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁºìÂ≠ò
                const isCached = await this.checkModelCached();
                
                if (isCached) {
                    // Â∑≤ÁºìÂ≠òÔºåÁõ¥Êé•Âä†ËΩΩ
                    return await this.initLLM();
                }
                
                // Êú™ÁºìÂ≠òÔºåÂºπÁ™óÁ°ÆËÆ§
                const confirmed = await this.showConfirmDialog({
                    title: '‰∏ãËΩΩ AI ‰∏ä‰∏ãÊñáÁøªËØëÊ®°Âûã',
                    message: 'È¶ñÊ¨°‰ΩøÁî®ÈúÄË¶Å‰∏ãËΩΩ Qwen3-4B Ê®°ÂûãÊñá‰ª∂ÔºàÁ∫¶ 2.5 GBÔºâ„ÄÇ\n\n‰∏ãËΩΩÂêéÂ∞ÜÁºìÂ≠òÂú®ÊµèËßàÂô®‰∏≠ÔºåÂêéÁª≠‰ΩøÁî®Êó†ÈúÄÈáçÂ§ç‰∏ãËΩΩ„ÄÇ\n\nËØ•Ê®°ÂûãÁî®‰∫éÊ†πÊçÆÂè•Â≠ê‰∏ä‰∏ãÊñáÂ∞ÜÂçïËØçÁøªËØë‰∏∫ÊúÄÂêàÈÄÇÁöÑ‰∏≠ÊñáÈáä‰πâ„ÄÇ\n\nÊòØÂê¶Á´ãÂç≥‰∏ãËΩΩÔºü',
                    confirmText: 'ÂºÄÂßã‰∏ãËΩΩ',
                    cancelText: 'ÂèñÊ∂à'
                });
                
                if (confirmed) {
                    return await this.initLLM();
                }
                return false;
            }
            
            // ÂàùÂßãÂåñ LLM ÂºïÊìé
            async initLLM() {
                if (this.llmLoading) {
                    console.log('LLM Ê≠£Âú®Âä†ËΩΩ‰∏≠...');
                    return false;
                }
                
                if (this.llmEngine) {
                    console.log('LLM Â∑≤Âä†ËΩΩ');
                    return true;
                }
                
                // Ê£ÄÊü• WebLLM ÊòØÂê¶ÂèØÁî®
                if (typeof window.CreateMLCEngine === 'undefined') {
                    this.updateLLMStatus('WebLLM Â∫ìÊú™Âä†ËΩΩ', true);
                    console.error('WebLLM Â∫ìÊú™Âä†ËΩΩÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•');
                    return false;
                }
                
                this.llmLoading = true;
                this.updateLLMStatus('Ê≠£Âú®Âä†ËΩΩÊ®°Âûã...');
                
                // Á¶ÅÁî®Âä†ËΩΩÊåâÈíÆ
                const loadBtn = document.getElementById('load-llm-btn');
                if (loadBtn) {
                    loadBtn.disabled = true;
                    loadBtn.textContent = 'Âä†ËΩΩ‰∏≠...';
                }
                
                try {
                    // ÂàõÂª∫ÂºïÊìéÔºåÊòæÁ§∫ËøõÂ∫¶
                    this.llmEngine = await window.CreateMLCEngine(this.llmModelId, {
                        initProgressCallback: (progress) => {
                            this.updateLLMProgress(progress);
                            console.log('LLM Âä†ËΩΩËøõÂ∫¶:', progress.text);
                        }
                    });
                    
                    this.llmLoading = false;
                    this.hideLLMProgress();
                    this.updateLLMStatus('Ê®°ÂûãÂ∑≤Â∞±Áª™');
                    
                    // ÂêØÁî®ÂºÄÂÖ≥
                    const enabledCheckbox = document.getElementById('llm-enabled');
                    if (enabledCheckbox) {
                        enabledCheckbox.disabled = false;
                        enabledCheckbox.checked = true;
                        this.llmEnabled = true;
                        this.saveLLMSettings();
                    }
                    
                    // Êõ¥Êñ∞ÊåâÈíÆÁä∂ÊÄÅ
                    if (loadBtn) {
                        loadBtn.textContent = 'Â∑≤Âä†ËΩΩ';
                        loadBtn.style.background = '#27ae60';
                    }
                    
                    console.log('LLM ÂºïÊìéÂä†ËΩΩÊàêÂäü');
                    return true;
                } catch (e) {
                    this.llmLoading = false;
                    this.llmEngine = null;
                    this.hideLLMProgress();
                    this.updateLLMStatus(`Âä†ËΩΩÂ§±Ë¥•: ${e.message}`, true);
                    
                    // ÊÅ¢Â§çÊåâÈíÆ
                    if (loadBtn) {
                        loadBtn.disabled = false;
                        loadBtn.textContent = 'ÈáçËØïÂä†ËΩΩ';
                        loadBtn.style.background = '#e74c3c';
                    }
                    
                    console.error('LLM ÂºïÊìéÂä†ËΩΩÂ§±Ë¥•:', e);
                    return false;
                }
            }
            
            // ‰ªéÊñáÊú¨‰∏≠ÊèêÂèñÂåÖÂê´ÊåáÂÆöÂçïËØçÁöÑÂè•Â≠ê
            extractSentenceWithWord(text, word) {
                if (!text || !word) return text;
                
                // ÊåâÂè•Â≠êÂàÜÂâ≤ÔºàÊîØÊåÅ . ! ? ‰ª•ÂèäÁúÅÁï•Âè∑Á≠âÔºâ
                // ‰ΩøÁî®Ê≠£ÂàôÂåπÈÖçÂè•Â≠êËæπÁïåÔºå‰øùÁïôÂàÜÈöîÁ¨¶
                const sentences = text.split(/(?<=[.!?])\s+/);
                
                // Êü•ÊâæÂåÖÂê´ËØ•ÂçïËØçÁöÑÂè•Â≠ê
                const wordRegex = new RegExp(`\\b${word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
                for (const sentence of sentences) {
                    if (wordRegex.test(sentence)) {
                        return sentence.trim();
                    }
                }
                
                // Â¶ÇÊûúÊ≤°ÊâæÂà∞ÔºåËøîÂõûÂéüÊñáÊú¨ÔºàÂèØËÉΩÂçïËØçÂú®Âè•Â≠êËæπÁïåË¢´ÂàÜÂâ≤‰∫ÜÔºâ
                return text;
            }
            
            // ‰ΩøÁî® LLM Ê†πÊçÆÂè•Â≠ê‰∏ä‰∏ãÊñáÁõ¥Êé•ÁøªËØëÂçïËØç
            async translateWithLLM(word, lemma = null, sentenceContext = null) {
                if (!this.llmEngine) return null;
                
                // Â¶ÇÊûúÊ≤°Êúâ‰∏ä‰∏ãÊñáÔºåËøîÂõû nullÔºåÂõûÈÄÄÂà∞ÂÖ∂‰ªñÁøªËØëÊñπÂºè
                if (!sentenceContext || sentenceContext.trim().length === 0) {
                    console.log(`[LLM] Êó†‰∏ä‰∏ãÊñáÔºåË∑≥Ëøá LLM ÁøªËØë: ${word}`);
                    return null;
                }
                
                try {
                    const contextSentence = sentenceContext.trim();
                    
                    // Few-Shot prompt for Qwen3Ôºå‰ΩøÁî® /no_think Á¶ÅÁî®ÊÄùËÄÉÊ®°Âºè‰ª•Ëé∑ÂæóÂø´ÈÄüÁõ¥Êé•ÁöÑÂõûÂ§ç
                    const userPrompt = `/no_think
Task: Translate the target English word into Chinese based on the sentence context. Only output the Chinese translation, nothing else.

Sentence: "He runs a software company."
Target Word: "runs"
Translation: ÁªèËê•

Sentence: "The river runs through the city."
Target Word: "runs"
Translation: ÊµÅÁªè

Sentence: "I need to bank the money before noon."
Target Word: "bank"
Translation: Â≠òÂÖ•Èì∂Ë°å

Sentence: "The bank of the river was covered with flowers."
Target Word: "bank"
Translation: Ê≤≥Â≤∏

Sentence: "${contextSentence}"
Target Word: "${word}"
Translation:`;
                    
                    const response = await this.llmEngine.chat.completions.create({
                        messages: [
                            { role: 'user', content: userPrompt }
                        ],
                        temperature: 0.1,
                        max_tokens: 30
                    });
                    
                    const rawResult = response.choices[0]?.message?.content?.trim();
                    // log rawResult
                    console.log('rawResult', rawResult);
                    if (rawResult) {
                        // Ê∏ÖÁêÜÁªìÊûúÔºöÁßªÈô§ Qwen3 ÁöÑ <think>...</think> Ê†áÁ≠æ„ÄÅÂºïÂè∑„ÄÅÂ§ö‰ΩôÁ©∫ÁôΩÁ≠â
                        const cleanedResult = rawResult
                            .replace(/<think>[\s\S]*?<\/think>/g, '')  // ÁßªÈô§ÊÄùËÄÉÊ†áÁ≠æ
                            .replace(/^["'`]|["'`]$/g, '')  // ÁßªÈô§ÂºïÂè∑
                            .trim();
                        // Âè™ÂèñÁ¨¨‰∏ÄË°åÔºàÈò≤Ê≠¢Ê®°ÂûãËæìÂá∫Â§ö‰ΩôÂÜÖÂÆπÔºâ
                        const firstLine = cleanedResult.split('\n')[0].trim();
                        if (firstLine && firstLine.length > 0 && firstLine.length < 50) {
                            console.log(`[LLMÁøªËØë] ${word} -> ${firstLine}\nÂè•Â≠ê: ${contextSentence}`);
                            return firstLine;
                        }
                        console.log(`[LLMÁøªËØë] ÁªìÊûúÂºÇÂ∏∏ÔºåË∑≥Ëøá: ${rawResult}`);
                    }
                } catch (e) {
                    console.warn('LLM ‰∏ä‰∏ãÊñáÁøªËØëÂ§±Ë¥•:', e);
                }
                
                // Â§±Ë¥•Êó∂ËøîÂõû nullÔºåÂõûÈÄÄÂà∞ÂÖ∂‰ªñÁøªËØëÊñπÂºè
                return null;
            }
            
            // ‰øùÂ≠ò LLM ËÆæÁΩÆ
            saveLLMSettings() {
                localStorage.setItem('epubLLMEnabled', this.llmEnabled ? '1' : '0');
            }
            
            // Âä†ËΩΩ LLM ËÆæÁΩÆ
            loadLLMSettings() {
                this.llmEnabled = localStorage.getItem('epubLLMEnabled') === '1';
                
                const enabledCheckbox = document.getElementById('llm-enabled');
                if (enabledCheckbox) {
                    enabledCheckbox.checked = this.llmEnabled;
                    // Â¶ÇÊûúÊ®°ÂûãÊú™Âä†ËΩΩÔºåÁ¶ÅÁî®ÂºÄÂÖ≥
                    enabledCheckbox.disabled = !this.llmEngine;
                }
                
                // ÁõëÂê¨ WebLLM Âä†ËΩΩÂÆåÊàê‰∫ã‰ª∂ÔºåÁÑ∂ÂêéÂ∞ùËØïËá™Âä®Âä†ËΩΩÊ®°Âûã
                if (typeof window.CreateMLCEngine !== 'undefined') {
                    // WebLLM Â∑≤Âä†ËΩΩÔºåÁõ¥Êé•Â∞ùËØïËá™Âä®Âä†ËΩΩ
                    this.tryAutoLoadLLM();
                } else {
                    // Á≠âÂæÖ WebLLM Âä†ËΩΩÂÆåÊàê
                    window.addEventListener('webllm-ready', () => {
                        this.tryAutoLoadLLM();
                    }, { once: true });
                }
            }
            
            // Â∞ùËØïËá™Âä®Âä†ËΩΩ LLM Ê®°ÂûãÔºàÂ¶ÇÊûúÂ∑≤ÁºìÂ≠òÔºâ
            async tryAutoLoadLLM() {
                try {
                    // Ê£ÄÊü•Ê®°ÂûãÊòØÂê¶Â∑≤ÁºìÂ≠ò
                    const isCached = await this.checkModelCached();
                    if (isCached) {
                        console.log('Ê£ÄÊµãÂà∞Â∑≤ÁºìÂ≠òÁöÑÊ®°ÂûãÔºåÂºÄÂßãËá™Âä®Âä†ËΩΩ...');
                        await this.initLLM();
                    } else {
                        console.log('Ê®°ÂûãÊú™ÁºìÂ≠òÔºåË∑≥ËøáËá™Âä®Âä†ËΩΩ');
                    }
                } catch (e) {
                    console.warn('Ëá™Âä®Âä†ËΩΩÊ®°ÂûãÂ§±Ë¥•:', e);
                }
            }

            // ÂàùÂßãÂåñÂ∑≤Áü•ËØçÊ±áË°®
            async initKnownWords() {
                try {
                    const words = await this.bookStorage.getAllKnownWords();
                    this.knownWords = new Set(words.map(w => w.lemma));
                    console.log(`Â∑≤Áü•ËØçÊ±áË°®Âä†ËΩΩÂÆåÊàêÔºåÂÖ± ${this.knownWords.size} ‰∏™ËØç`);
                } catch (e) {
                    console.warn('Âä†ËΩΩÂ∑≤Áü•ËØçÊ±áË°®Â§±Ë¥•:', e);
                }
            }

            // ÂàùÂßãÂåñÂ∑≤Êü•ËØ¢ËØçË°®
            async initLookedUpWords() {
                try {
                    const words = await this.bookStorage.getAllLookedUpWords();
                    this.lookedUpWords = new Map(words.map(w => [w.word, w]));
                    console.log(`Â∑≤Êü•ËØ¢ËØçË°®Âä†ËΩΩÂÆåÊàêÔºåÂÖ± ${this.lookedUpWords.size} ‰∏™ËØç`);
                } catch (e) {
                    console.warn('Âä†ËΩΩÂ∑≤Êü•ËØ¢ËØçË°®Â§±Ë¥•:', e);
                    this.lookedUpWords = new Map();
                }
            }

            // Âä†ËΩΩ‰∏äÊ¨°ÊâìÂºÄÁöÑ‰π¶Á±ç
            async loadLastBook() {
                try {
                    const lastBookId = this.bookStorage.getLastBookId();
                    if (lastBookId) {
                        const book = await this.bookStorage.getBook(lastBookId);
                        if (book && book.data) {
                            // Ëé∑Âèñ‰øùÂ≠òÁöÑÈòÖËØªËøõÂ∫¶
                            const progress = await this.bookStorage.getProgress(lastBookId);
                            if (progress) {
                                this.pendingScrollPosition = progress.scrollPosition;
                                this.totalReadingTime = progress.totalReadingTime || 0;
                            }
                            
                            this.currentFileName = book.fileName;
                            this.currentBookId = lastBookId;
                            this.currentFileType = book.fileType || 'epub';
                            
                            // Ê†πÊçÆÊñá‰ª∂Á±ªÂûãÈÄâÊã©Âä†ËΩΩÊñπÊ≥ï
                            if (book.fileType === 'pdf' || book.fileName.toLowerCase().endsWith('.pdf')) {
                                await this.loadPDFFromArrayBuffer(book.data, book.fileName, true);
                            } else {
                                await this.loadEPUBFromArrayBuffer(book.data, book.fileName, true);
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Êó†Ê≥ïÂä†ËΩΩ‰∏äÊ¨°ÁöÑ‰π¶Á±ç:', e);
                }
            }

            // ‰øùÂ≠òÈòÖËØªËøõÂ∫¶
            async saveReadingProgress() {
                if (!this.currentBookId) return;
                
                const container = document.getElementById('reader-container');
                const scrollHeight = container.scrollHeight - container.clientHeight;
                const scrollPercentage = scrollHeight > 0 
                    ? Math.round((container.scrollTop / scrollHeight) * 100) 
                    : 0;
                
                try {
                    await this.bookStorage.saveProgress(this.currentBookId, {
                        scrollPosition: container.scrollTop,
                        scrollPercentage: scrollPercentage,
                        totalReadingTime: this.getCurrentReadingTime()
                    });
                } catch (e) {
                    console.warn('‰øùÂ≠òËøõÂ∫¶Â§±Ë¥•:', e);
                }
            }

            // ÊòæÁ§∫‰π¶Êû∂
            async showLibrary() {
                const books = await this.bookStorage.getAllBooks();
                
                // Ëé∑ÂèñÊØèÊú¨‰π¶ÁöÑËøõÂ∫¶
                const booksWithProgress = await Promise.all(books.map(async (book) => {
                    const progress = await this.bookStorage.getProgress(book.id);
                    return { ...book, progress };
                }));
                
                this.renderLibrary(booksWithProgress);
            }

            // Ê∏≤Êüì‰π¶Êû∂
            renderLibrary(books) {
                const modal = document.createElement('div');
                modal.className = 'library-modal';
                modal.innerHTML = `
                    <div class="library-content">
                        <div class="library-header">
                            <h2>üìö ÊàëÁöÑ‰π¶Êû∂</h2>
                            <button class="library-close" id="library-close">‚úï</button>
                        </div>
                        <div class="library-books" id="library-books">
                            ${books.length === 0 ? `
                                <div class="library-empty">
                                    ‰π¶Êû∂‰∏∫Á©∫<br>ÊâìÂºÄ EPUB Êàñ PDF Êñá‰ª∂Âêé‰ºöËá™Âä®Ê∑ªÂä†Âà∞‰π¶Êû∂
                                </div>
                            ` : books.map(book => {
                                const fileType = book.fileType || (book.fileName.toLowerCase().endsWith('.pdf') ? 'pdf' : 'epub');
                                return `
                                <div class="library-book" data-book-id="${book.id}">
                                    <div class="book-info">
                                        <div class="book-title">
                                            <span class="file-type-badge ${fileType}">${fileType.toUpperCase()}</span>
                                            <span class="book-title-text">${book.title || book.fileName}</span>
                                        </div>
                                        <div class="book-meta">
                                            ${book.author ? `<span class="book-author">${book.author}</span>` : ''}
                                            <span class="book-progress">
                                                <span class="book-progress-bar"><span class="book-progress-fill" style="width: ${book.progress ? book.progress.scrollPercentage : 0}%"></span></span>
                                                ${book.progress ? book.progress.scrollPercentage : 0}%
                                            </span>
                                            ${book.progress && book.progress.totalReadingTime ? 
                                                `<span class="book-time">Â∑≤ËØª ${this.formatReadingTime(book.progress.totalReadingTime)}</span>` : ''}
                                        </div>
                                    </div>
                                    <div class="book-actions">
                                        <button class="book-open" data-book-id="${book.id}">üìñ ÊâìÂºÄ</button>
                                        <button class="book-delete" data-book-id="${book.id}">üóë Âà†Èô§</button>
                                    </div>
                                </div>
                            `;}).join('')}
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // ÂÖ≥Èó≠ÊåâÈíÆ
                document.getElementById('library-close').addEventListener('click', () => {
                    modal.remove();
                });
                
                // ÁÇπÂáªËÉåÊôØÂÖ≥Èó≠
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
                // ÊâìÂºÄ‰π¶Á±ç
                modal.querySelectorAll('.book-open').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const bookId = btn.dataset.bookId;
                        modal.remove();
                        await this.openBookById(bookId);
                    });
                });
                
                // Âà†Èô§‰π¶Á±ç
                modal.querySelectorAll('.book-delete').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const bookId = btn.dataset.bookId;
                        if (confirm('Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊú¨‰π¶ÂêóÔºü')) {
                            await this.bookStorage.deleteBook(bookId);
                            btn.closest('.library-book').remove();
                            
                            // Â¶ÇÊûúÂà†Èô§ÁöÑÊòØÂΩìÂâç‰π¶Á±ç
                            if (bookId === this.currentBookId) {
                                this.currentBookId = null;
                                document.getElementById('welcome-screen').style.display = 'flex';
                                document.getElementById('reader-content').style.display = 'none';
                            }
                        }
                    });
                });
            }

            // ÈÄöËøáIDÊâìÂºÄ‰π¶Á±ç
            async openBookById(bookId) {
                this.showLoading(true);
                try {
                    const book = await this.bookStorage.getBook(bookId);
                    if (book && book.data) {
                        const progress = await this.bookStorage.getProgress(bookId);
                        if (progress) {
                            this.pendingScrollPosition = progress.scrollPosition;
                            this.totalReadingTime = progress.totalReadingTime || 0;
                        } else {
                            this.totalReadingTime = 0;
                        }
                        
                        this.currentFileName = book.fileName;
                        this.currentBookId = bookId;
                        this.currentFileType = book.fileType || 'epub';
                        this.bookStorage.setLastBookId(bookId);
                        await this.bookStorage.updateLastOpened(bookId);
                        
                        // Ê†πÊçÆÊñá‰ª∂Á±ªÂûãÈÄâÊã©Âä†ËΩΩÊñπÊ≥ï
                        if (book.fileType === 'pdf' || book.fileName.toLowerCase().endsWith('.pdf')) {
                            await this.loadPDFFromArrayBuffer(book.data, book.fileName, true);
                        } else {
                            await this.loadEPUBFromArrayBuffer(book.data, book.fileName, true);
                        }
                    }
                } catch (e) {
                    console.error('ÊâìÂºÄ‰π¶Á±çÂ§±Ë¥•:', e);
                    alert('ÊâìÂºÄ‰π¶Á±çÂ§±Ë¥•');
                } finally {
                    this.showLoading(false);
                }
            }

            // ÂàùÂßãÂåñÁ≤æÁ°ÆÈòÖËØªËøΩË∏™
            initPreciseReadingTracker() {
                // Ê∏ÖÁêÜ‰πãÂâçÁöÑËßÇÂØüÂô®
                if (this.readObserver) {
                    this.readObserver.disconnect();
                }
                this.readParagraphs.clear();
                this.totalReadCharacters = 0;
                this.lastReadCountTime = Date.now();
                this.readingSpeedHistory = [];
                
                const readerContent = document.getElementById('reader-content');
                if (!readerContent) return;
                
                // Ëé∑ÂèñÊâÄÊúâÊñáÊú¨ÊÆµËêΩÔºàp, h1-h6, li, blockquote Á≠âÔºâ
                const textElements = readerContent.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, blockquote, td, th, dt, dd, figcaption');
                
                // ‰∏∫ÊØè‰∏™ÊÆµËêΩÂàõÂª∫ËøΩË∏™Êï∞ÊçÆ
                textElements.forEach((el, index) => {
                    const text = el.textContent || '';
                    const wordCount = this.countWords(text);
                    if (wordCount > 0) {
                        el.dataset.paragraphId = `para-${index}`;
                        this.readParagraphs.set(el.dataset.paragraphId, {
                            element: el,
                            wordCount: wordCount,
                            isRead: false,
                            visibleSince: null,
                            totalVisibleTime: 0
                        });
                    }
                });
                
                // ÂàõÂª∫ Intersection Observer
                const container = document.getElementById('reader-container');
                this.readObserver = new IntersectionObserver((entries) => {
                    if (!this.isPageVisible) return;
                    
                    const now = Date.now();
                    entries.forEach(entry => {
                        const paraId = entry.target.dataset.paragraphId;
                        if (!paraId) return;
                        
                        const paraData = this.readParagraphs.get(paraId);
                        if (!paraData || paraData.isRead) return;
                        
                        // ÂØπ‰∫éÁü≠ÊÆµËêΩÔºà<= 10ËØçÔºâÔºåÂè™ÈúÄË¶Å‰ªªÊÑèÂèØËßÅÂç≥ÂèØÔºõËæÉÈïøÊÆµËêΩÈúÄË¶Å50%ÂèØËßÅ
                        const visibilityThreshold = paraData.wordCount <= 10 ? 0 : 0.5;
                        
                        if (entry.isIntersecting && entry.intersectionRatio > visibilityThreshold) {
                            // ÊÆµËêΩËøõÂÖ•ÂèØËßÜÂå∫Âüü
                            if (!paraData.visibleSince) {
                                paraData.visibleSince = now;
                            }
                        } else {
                            // ÊÆµËêΩÁ¶ªÂºÄÂèØËßÜÂå∫Âüü
                            if (paraData.visibleSince) {
                                paraData.totalVisibleTime += now - paraData.visibleSince;
                                paraData.visibleSince = null;
                                
                                // Á¶ªÂºÄÊó∂Á´ãÂç≥Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•Ê†áËÆ∞‰∏∫Â∑≤ËØª
                                this.checkSingleParagraph(paraId, paraData, now);
                            }
                        }
                    });
                }, {
                    root: container,
                    threshold: [0, 0.1, 0.25, 0.5, 0.75, 1.0],
                    rootMargin: '0px'
                });
                
                // ÂºÄÂßãËßÇÂØüÊâÄÊúâÊÆµËêΩ
                this.readParagraphs.forEach((data) => {
                    this.readObserver.observe(data.element);
                });
                
                // ÂÆöÊúüÊ£ÄÊü•Âπ∂Ê†áËÆ∞Â∑≤ËØªÊÆµËêΩ
                this._clearIntervals('readCheckInterval');
                this.readCheckInterval = setInterval(() => {
                    this.checkReadParagraphs();
                }, CONFIG.INTERVALS.CHECK_READ);
            }
            
            // ËÆ°ÁÆóÊÆµËêΩÊâÄÈúÄÁöÑÊúÄÂ∞èÈòÖËØªÊó∂Èó¥
            calculateRequiredReadTime(wordCount) {
                // Áü≠ÊÆµËêΩÔºà1-5ËØçÔºâÔºö200-400ms
                // ‰∏≠Á≠âÊÆµËêΩÔºà6-20ËØçÔºâÔºö400-800ms  
                // ÈïøÊÆµËêΩÔºà20+ËØçÔºâÔºöÊ†πÊçÆÈòÖËØªÈÄüÂ∫¶ËÆ°ÁÆóÔºå‰ΩÜËá≥Â∞ë800ms
                
                if (wordCount <= 5) {
                    return 200 + wordCount * 40;
                } else if (wordCount <= 20) {
                    return 300 + wordCount * 25;
                } else {
                    const { WORDS_PER_SECOND } = CONFIG.READING;
                    return Math.max(800, (wordCount / WORDS_PER_SECOND) * 1000 * 0.3);
                }
            }
            
            // Ê£ÄÊü•Âçï‰∏™ÊÆµËêΩÊòØÂê¶Â∑≤ËØª
            checkSingleParagraph(paraId, data, now) {
                if (data.isRead) return;
                
                let totalTime = data.totalVisibleTime;
                if (data.visibleSince) {
                    totalTime += now - data.visibleSince;
                }
                
                const requiredTime = this.calculateRequiredReadTime(data.wordCount);
                
                if (totalTime >= requiredTime) {
                    data.isRead = true;
                    this.totalReadCharacters += data.wordCount;
                    // Ë∞ÉËØïÔºöÁªôÂ∑≤ËØªÊÆµËêΩÊ∑ªÂä†ËßÜËßâÊ†áËÆ∞
                    // data.element.style.backgroundColor = 'rgba(46, 204, 113, 0.1)';
                }
            }
            
            // Ê£ÄÊü•Âπ∂Ê†áËÆ∞Â∑≤ËØªÊÆµËêΩ
            checkReadParagraphs() {
                if (!this.isPageVisible) return;
                
                const now = Date.now();
                
                this.readParagraphs.forEach((data, paraId) => {
                    this.checkSingleParagraph(paraId, data, now);
                });
            }
            
            // ËÆ∞ÂΩïÈòÖËØªÈÄüÂ∫¶Êï∞ÊçÆÁÇπ
            recordReadingSpeedPoint() {
                const now = Date.now();
                
                // Á°Æ‰øùÂΩìÂâçÂèØËßÅÁöÑÊÆµËêΩÊó∂Èó¥Ë¢´ËÆ°ÂÖ•
                this.checkReadParagraphs();
                
                this.readingSpeedHistory.push({
                    timestamp: now,
                    wordsRead: this.totalReadCharacters
                });
                
                // Âè™‰øùÁïôÈÖçÁΩÆÊó∂ÈïøÁöÑÊï∞ÊçÆ
                const cutoffTime = now - CONFIG.READING.SPEED_HISTORY_MINUTES * 60 * 1000;
                this.readingSpeedHistory = this.readingSpeedHistory.filter(h => h.timestamp >= cutoffTime);
            }

            // ËÆ°ÁÆóÁ≤æÁ°ÆÈòÖËØªÈÄüÂ∫¶ÔºàËØç/ÂàÜÈíüÔºâ
            calculateReadingSpeed() {
                if (this.readingSpeedHistory.length < 2) return null;
                
                const now = Date.now();
                const { SPEED_CALC_MINUTES, MIN_SPEED_TIME, MIN_WPM, MAX_WPM } = CONFIG.READING;
                
                // ‰ΩøÁî®ÊúÄËøëÊï∞ÊçÆËÆ°ÁÆóÈÄüÂ∫¶
                const cutoffTime = now - SPEED_CALC_MINUTES * 60 * 1000;
                const recentHistory = this.readingSpeedHistory.filter(h => h.timestamp >= cutoffTime);
                
                if (recentHistory.length < 2) return null;
                
                const oldest = recentHistory[0];
                const newest = recentHistory[recentHistory.length - 1];
                
                const timeDiffMinutes = (newest.timestamp - oldest.timestamp) / 60000;
                const wordsDiff = newest.wordsRead - oldest.wordsRead;
                
                // ÊúÄÂ∞èÊó∂Èó¥ÂíåÊ≠£ÂêëÈòÖËØªÊ£ÄÊü•
                if (timeDiffMinutes < MIN_SPEED_TIME || wordsDiff <= 0) return null;
                
                const wpm = Math.round(wordsDiff / timeDiffMinutes);
                
                // ÂêàÁêÜËåÉÂõ¥Ê£ÄÊü•
                return (wpm >= MIN_WPM && wpm <= MAX_WPM) ? wpm : null;
            }

            // Êõ¥Êñ∞ÈòÖËØªÈÄüÂ∫¶ÊòæÁ§∫
            updateSpeedDisplay() {
                const speed = this.calculateReadingSpeed();
                const speedIndicator = document.getElementById('speed-indicator');
                const speedValue = document.getElementById('speed-value');
                
                if (speed !== null) {
                    speedIndicator.classList.add('active');
                    speedValue.textContent = speed;
                } else {
                    speedValue.textContent = '--';
                }
                
                // ÂêåÊó∂Êõ¥Êñ∞Â∑≤ËØªÂ≠óÊï∞ÊòæÁ§∫
                this.updateReadCountDisplay();
            }
            
            // Êõ¥Êñ∞Â∑≤ËØªÂ≠óÊï∞ÊòæÁ§∫
            updateReadCountDisplay() {
                const readCountIndicator = document.getElementById('read-count-indicator');
                const readCountValue = document.getElementById('read-count-value');
                
                if (readCountIndicator && readCountValue) {
                    readCountIndicator.classList.add('active');
                    readCountValue.textContent = this.totalReadCharacters.toLocaleString();
                }
            }

            // ÂºÄÂßãÈòÖËØªÈÄüÂ∫¶Ë∑üË∏™
            startSpeedTracking() {
                // ÂÅúÊ≠¢‰πãÂâçÁöÑË∑üË∏™
                this.stopSpeedTracking();
                
                // ÂàùÂßãÂåñÁ≤æÁ°ÆÈòÖËØªËøΩË∏™
                this.initPreciseReadingTracker();
                
                // ËÆ∞ÂΩïÂàùÂßãÁÇπ
                this.recordReadingSpeedPoint();
                
                // ÊòæÁ§∫ÈÄüÂ∫¶ÊåáÁ§∫Âô®
                document.getElementById('speed-indicator').classList.add('active');
                
                // ÂÆöÊúüËÆ∞ÂΩïÈÄüÂ∫¶Êï∞ÊçÆÂπ∂Êõ¥Êñ∞ÊòæÁ§∫
                this.speedUpdateInterval = setInterval(() => {
                    this.recordReadingSpeedPoint();
                    this.updateSpeedDisplay();
                }, CONFIG.INTERVALS.UPDATE_SPEED);
            }

            // ÂÅúÊ≠¢ÈòÖËØªÈÄüÂ∫¶Ë∑üË∏™
            stopSpeedTracking() {
                this._clearIntervals('speedUpdateInterval', 'readCheckInterval');
                
                if (this.readObserver) {
                    this.readObserver.disconnect();
                    this.readObserver = null;
                }
            }
            
            // Ê∏ÖÁêÜÊâÄÊúâËµÑÊ∫êÔºàÁî®‰∫éÈ°µÈù¢Âç∏ËΩΩÊàñÈáçÊñ∞Âä†ËΩΩ‰π¶Á±çÊó∂Ôºâ
            cleanup() {
                this.stopSpeedTracking();
                this._clearIntervals('readingTimeInterval', 'timeDisplayInterval');
                
                if (this.annotationObserver) {
                    this.annotationObserver.disconnect();
                    this.annotationObserver = null;
                }
                
                // Ê∏ÖÁêÜÂ§ßÂûãÊï∞ÊçÆÁªìÊûÑ
                this.readParagraphs.clear();
                this.readingSpeedHistory = [];
                this.annotatedParagraphs.clear();
            }

            // Êõ¥Êñ∞ÈòÖËØªÊó∂Èó¥ÊòæÁ§∫
            updateTimeDisplay() {
                const timeValue = document.getElementById('time-value');
                if (timeValue) {
                    timeValue.textContent = this.formatReadingTime(this.getCurrentReadingTime());
                }
            }

            // Êõ¥Êñ∞ÊÄªÂ≠óÊï∞ÊòæÁ§∫
            updateWordCountDisplay() {
                const wordCountIndicator = document.getElementById('word-count-indicator');
                const wordCountValue = document.getElementById('word-count-value');
                
                if (wordCountIndicator && wordCountValue) {
                    wordCountIndicator.classList.add('active');
                    wordCountValue.textContent = Utils.formatNumber(this.totalCharacters);
                }
            }

            // ËÆ°ÁÆóÂçïËØçÊï∞ - ‰ΩøÁî®Â∑•ÂÖ∑ÂáΩÊï∞
            countWords(text) {
                return Utils.countWords(text);
            }

            // Âä†ËΩΩËØçÊ±áÊ†áÊ≥®ËÆæÁΩÆ
            loadAnnotationSettings() {
                const saved = localStorage.getItem('annotationSettings');
                const settings = Utils.safeJsonParse(saved, {});
                const { DEFAULT_MIN, DEFAULT_MAX, DEFAULT_THRESHOLD } = CONFIG.COCA;
                
                this.annotationEnabled = settings.enabled ?? true;
                this.freqMin = settings.freqMin ?? DEFAULT_MIN;
                this.freqMax = settings.freqMax ?? DEFAULT_MAX;
                this.learningThreshold = settings.learningThreshold ?? DEFAULT_THRESHOLD;
                this.offlineDictPriority = settings.offlineDictPriority ?? false;
            }

            // ‰øùÂ≠òËØçÊ±áÊ†áÊ≥®ËÆæÁΩÆ
            saveAnnotationSettings() {
                localStorage.setItem('annotationSettings', JSON.stringify({
                    enabled: this.annotationEnabled,
                    freqMin: this.freqMin,
                    freqMax: this.freqMax,
                    learningThreshold: this.learningThreshold,
                    offlineDictPriority: this.offlineDictPriority
                }));
            }

            // Âä†ËΩΩCOCAËØçÈ¢ëË°®
            async loadCOCAList() {
                if (this.cocaLoaded) return;
                
                try {
                    const response = await fetch(CONFIG.URLS.COCA);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    
                    const text = await response.text();
                    const lines = text.trim().split('\n');
                    this.cocaRanks = new Map();
                    
                    lines.forEach((word, index) => {
                        this.cocaRanks.set(word.toLowerCase().trim(), index + 1);
                    });
                    
                    this.cocaLoaded = true;
                    console.log(`COCAËØçÈ¢ëË°®Âä†ËΩΩÂÆåÊàêÔºåÂÖ± ${this.cocaRanks.size} ‰∏™ËØç`);
                } catch (e) {
                    console.warn('Âä†ËΩΩCOCAËØçÈ¢ëË°®Â§±Ë¥•:', e);
                }
            }

            // Ë∞ÉÁî®GoogleÁøªËØëAPIÔºàÊü•ËØ¢ÂéüËØçÔºâÔºåÂ§±Ë¥•Êó∂ÂõûÈÄÄÂà∞Á¶ªÁ∫øËØçÂÖ∏
            // Â¶ÇÊûúÂºÄÂêØ‰∫ÜÁ¶ªÁ∫øËØçÂÖ∏‰ºòÂÖàÔºåÂàôÂÖàÊü•Á¶ªÁ∫øËØçÂÖ∏ÔºåÊü•‰∏çÂà∞ÂÜçÁî®GoogleÁøªËØë
            // sentenceContext: Âè•Â≠ê‰∏ä‰∏ãÊñáÔºåÁî®‰∫é LLM ‰∏ä‰∏ãÊñáÁøªËØë
            async translateWord(word, lemma = null, sentenceContext = null) {
                // LLM ‰∏ä‰∏ãÊñáÁøªËØë‰ºòÂÖàÔºàÂ¶ÇÊûúÂ∑≤ÂêØÁî®‰∏îÊ®°ÂûãÂ∑≤Âä†ËΩΩÔºâ
                if (this.llmEnabled && this.llmEngine) {
                    const llmResult = await this.translateWithLLM(word, lemma, sentenceContext);
                    if (llmResult) {
                        return llmResult;
                    }
                    // LLM ÁøªËØëÂ§±Ë¥•ÔºåÂõûÈÄÄÂà∞ÂÖ∂‰ªñÁøªËØëÊñπÂºè
                    console.log(`[LLM] ÁøªËØëÂ§±Ë¥•ÔºåÂõûÈÄÄÂà∞ÂÖ∂‰ªñÊñπÂºè: ${word}/${lemma}`);
                }
                
                // Á¶ªÁ∫øËØçÂÖ∏‰ºòÂÖàÊ®°Âºè
                if (this.offlineDictPriority) {
                    // ÂÖàÊü•ÂéüËØç
                    let offlineResult = this.getOfflineTranslation(word);
                    if (offlineResult) {
                        console.log(`[Á¶ªÁ∫ø‰ºòÂÖà] ‰ΩøÁî®Á¶ªÁ∫øËØçÂÖ∏ÁøªËØë(ÂéüËØç): ${word} -> ${offlineResult}`);
                        return offlineResult;
                    }
                    
                    // ÂéüËØçÊü•‰∏çÂà∞ÔºåÂ∞ùËØïÊü• lemma
                    if (lemma && lemma !== word.toLowerCase()) {
                        offlineResult = this.getOfflineTranslation(lemma);
                        if (offlineResult) {
                            console.log(`[Á¶ªÁ∫ø‰ºòÂÖà] ‰ΩøÁî®Á¶ªÁ∫øËØçÂÖ∏ÁøªËØë(lemma): ${lemma} -> ${offlineResult}`);
                            return offlineResult;
                        }
                    }
                    
                    // Á¶ªÁ∫øËØçÂÖ∏Êü•‰∏çÂà∞ÔºåÂõûÈÄÄÂà∞ Google ÁøªËØë
                    const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=zh-CN&dt=t&q=${encodeURIComponent(word)}`;
                    try {
                        const response = await fetch(url);
                        const data = await response.json();
                        const result = data[0]?.[0]?.[0] || null;
                        if (result) {
                            console.log(`[Á¶ªÁ∫ø‰ºòÂÖà] Á¶ªÁ∫øËØçÂÖ∏Êó†ÁªìÊûúÔºå‰ΩøÁî®GoogleÁøªËØë: ${word} -> ${result}`);
                            return result;
                        }
                    } catch (e) {
                        console.warn(`GoogleÁøªËØëAPIÂ§±Ë¥•: ${word}`, e);
                    }
                    return null;
                }
                
                // ÈªòËÆ§Ê®°ÂºèÔºöGoogle ÁøªËØë‰ºòÂÖà
                const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=zh-CN&dt=t&q=${encodeURIComponent(word)}`;
                
                try {
                    const response = await fetch(url);
                    const data = await response.json();
                    const result = data[0]?.[0]?.[0] || null;
                    if (result) return result;
                } catch (e) {
                    console.warn(`GoogleÁøªËØëAPIÂ§±Ë¥•: ${word}`, e);
                }
                
                // API Â§±Ë¥•Êó∂ÔºåÂõûÈÄÄÂà∞Á¶ªÁ∫øËØçÂÖ∏
                // ÂÖàÊü•ÂéüËØç
                let offlineResult = this.getOfflineTranslation(word);
                if (offlineResult) {
                    console.log(`‰ΩøÁî®Á¶ªÁ∫øËØçÂÖ∏ÁøªËØë(ÂéüËØç): ${word} -> ${offlineResult}`);
                    return offlineResult;
                }
                
                // ÂéüËØçÊü•‰∏çÂà∞ÔºåÂ∞ùËØïÊü• lemma
                if (lemma && lemma !== word.toLowerCase()) {
                    offlineResult = this.getOfflineTranslation(lemma);
                    if (offlineResult) {
                        console.log(`‰ΩøÁî®Á¶ªÁ∫øËØçÂÖ∏ÁøªËØë(lemma): ${lemma} -> ${offlineResult}`);
                        return offlineResult;
                    }
                }
                
                return null;
            }

            // Ëé∑ÂèñÁøªËØë
            // word: ÂéüËØç, lemma: ËØçÊ†πÂΩ¢ÂºèÔºàÂèØÈÄâÔºåÁî®‰∫éÁ¶ªÁ∫øËØçÂÖ∏Â§áÈÄâÊü•ËØ¢Ôºâ
            // sentenceContext: Âè•Â≠ê‰∏ä‰∏ãÊñáÔºàÂèØÈÄâÔºåÁî®‰∫é LLM ‰∏ä‰∏ãÊñáÁøªËØëÔºâ
            async getTranslation(word, lemma = null, sentenceContext = null) {
                return await this.translateWord(word, lemma, sentenceContext);
            }

            // ‰ª•Âè•Â≠ê‰∏∫Âçï‰ΩçËé∑ÂèñÊâÄÊúâÂçïËØçÁöÑÂéüÂΩ¢ÔºàlemmaÔºâÂíåËØçÊÄß
            // ËøîÂõû Map<ÂéüËØçÂ∞èÂÜô, {lemma, pos}>
            getLemmasFromText(text) {
                // console.log('getLemmasFromText', text);
                const lemmaMap = new Map();
                if (!text || text.trim().length === 0) return lemmaMap;
                
                try {
                    const doc = nlp(text);
                    
                    // ÈÅçÂéÜÊâÄÊúâ termsÔºåÂØπÊØè‰∏™ÂçïËØçÂçïÁã¨ËøõË°åÂéüÂΩ¢ËΩ¨Êç¢
                    const terms = doc.terms().json();
                    for (const term of terms) {
                        const originalWord = term.text;
                        if (!originalWord || originalWord.length < 2) continue;
                        if (!/^[a-zA-Z]+$/.test(originalWord)) continue;
                        
                        const lowerWord = originalWord.toLowerCase();
                        if (lemmaMap.has(lowerWord)) continue;
                        
                        let lemma = lowerWord;
                        let pos = 'Unknown';
                        const tags = term.terms?.[0]?.tags || [];
                        
                        if (tags.includes('Verb')) {
                            pos = 'Verb';
                            // ÊûÑÈÄ†Â∏¶‰∏ªËØ≠ÁöÑÂè•Â≠êÂ∏ÆÂä© compromise ËØÜÂà´Âä®ËØçÔºåÂπ∂Ê†áËÆ∞ËØçÊÄß
                            const sentenceDoc = nlp('I ' + originalWord);
                            sentenceDoc.match(originalWord).tag('Verb');
                            const verbs = sentenceDoc.verbs();
                            if (verbs.length) {
                                verbs.toInfinitive();
                                // ÊèêÂèñËΩ¨Êç¢ÂêéÁöÑÂä®ËØçÔºàÂéªÊéâ "I "Ôºâ
                                const result = sentenceDoc.text().toLowerCase().trim();
                                const infinitive = result.startsWith('i ') ? result.slice(2).trim() : result;
                                if (infinitive && infinitive.length > 0 && /^[a-z]+$/.test(infinitive)) {
                                    lemma = infinitive;
                                }
                            }
                        } else if (tags.includes('Noun')) {
                            pos = 'Noun';
                            // ÂØπÂçï‰∏™ÂêçËØçËøõË°åÂçïÊï∞ËΩ¨Êç¢
                            const wordDoc = nlp(originalWord);
                            const nouns = wordDoc.nouns();
                            if (nouns.length) {
                                nouns.toSingular();
                                const singular = wordDoc.text().toLowerCase().trim();
                                if (singular && singular.length > 0 && /^[a-z]+$/.test(singular)) {
                                    lemma = singular;
                                }
                            }
                        } else if (tags.includes('Adjective')) {
                            pos = 'Adjective';
                            // ÂØπÂΩ¢ÂÆπËØçËøõË°åÂéüÂΩ¢Â§ÑÁêÜÔºàÂ§ÑÁêÜÊØîËæÉÁ∫ßÂíåÊúÄÈ´òÁ∫ßÔºâ
                            lemma = this.getAdjectiveAdverbLemma(lowerWord);
                        } else if (tags.includes('Adverb')) {
                            pos = 'Adverb';
                            // ÂØπÂâØËØçËøõË°åÂéüÂΩ¢Â§ÑÁêÜ
                            lemma = this.getAdjectiveAdverbLemma(lowerWord);
                        } else {
                            pos = tags.length > 0 ? tags[0] : 'Unknown';
                        }
                        
                        lemmaMap.set(lowerWord, { lemma, pos });
                    }
                } catch (e) {
                    console.warn('getLemmasFromText error:', e);
                }
                
                return lemmaMap;
            }

            // ‰∏çËßÑÂàôÂΩ¢ÂÆπËØç/ÂâØËØçÊò†Â∞ÑË°®
            static IRREGULAR_ADJ_ADV = {
                // good/well
                'better': 'good', 'best': 'good',
                // bad/badly
                'worse': 'bad', 'worst': 'bad',
                // much/many
                'more': 'much', 'most': 'much',
                // little
                'less': 'little', 'least': 'little',
                // far
                'further': 'far', 'furthest': 'far', 'farther': 'far', 'farthest': 'far',
                // old
                'elder': 'old', 'eldest': 'old', 'older': 'old', 'oldest': 'old',
                // late
                'later': 'late', 'latest': 'late', 'latter': 'late',
            };

            // Ëé∑ÂèñÂΩ¢ÂÆπËØç/ÂâØËØçÂéüÂΩ¢
            getAdjectiveAdverbLemma(word) {
                if (!word) return word;
                const lower = word.toLowerCase();
                
                // 1. Ê£ÄÊü•‰∏çËßÑÂàôÂΩ¢Âºè
                if (EPUBReader.IRREGULAR_ADJ_ADV[lower]) {
                    return EPUBReader.IRREGULAR_ADJ_ADV[lower];
                }
                
                // 2. Â§ÑÁêÜËßÑÂàôÂèòÂåñÁöÑÊØîËæÉÁ∫ß/ÊúÄÈ´òÁ∫ß
                // -iest -> -y (happiest -> happy)
                if (lower.endsWith('iest') && lower.length > 5) {
                    return lower.slice(0, -4) + 'y';
                }
                // -ier -> -y (happier -> happy)
                if (lower.endsWith('ier') && lower.length > 4) {
                    return lower.slice(0, -3) + 'y';
                }
                // ÂèåÂÜôËæÖÈü≥ + est (biggest -> big)
                if (lower.endsWith('est') && lower.length > 5) {
                    const base = lower.slice(0, -3);
                    if (base.length >= 2 && base[base.length - 1] === base[base.length - 2]) {
                        return base.slice(0, -1);
                    }
                }
                // ÂèåÂÜôËæÖÈü≥ + er (bigger -> big)
                if (lower.endsWith('er') && lower.length > 4) {
                    const base = lower.slice(0, -2);
                    if (base.length >= 2 && base[base.length - 1] === base[base.length - 2]) {
                        return base.slice(0, -1);
                    }
                }
                // -est (tallest -> tall, ‰ΩÜË¶ÅÈÅøÂÖç test, best Á≠â)
                if (lower.endsWith('est') && lower.length > 4) {
                    const base = lower.slice(0, -3);
                    // Ê£ÄÊü•ÊòØÂê¶ÊòØÂêàÁêÜÁöÑÂΩ¢ÂÆπËØçËØçÊ†π
                    if (/[aeiou][^aeiou]$/.test(base) || /[^aeiou]{2}$/.test(base)) {
                        return base;
                    }
                }
                // -er (taller -> tall, ‰ΩÜË¶ÅÈÅøÂÖç water, after Á≠âÂ∏∏ËßÅËØç)
                if (lower.endsWith('er') && lower.length > 3) {
                    const base = lower.slice(0, -2);
                    // Âè™Â§ÑÁêÜÊòéÊòæÁöÑÊØîËæÉÁ∫ßÊ®°Âºè
                    if (/[aeiou][^aeiou]$/.test(base) || /[^aeiou]{2}$/.test(base)) {
                        return base;
                    }
                }
                
                return lower;
            }

            // ‰ΩøÁî®CompromiseËé∑ÂèñÂçïËØçÂéüÂΩ¢ÔºàÂçïËØçÊ®°ÂºèÔºå‰Ωú‰∏∫Â§áÁî®Ôºâ
            getLemma(word) {
                if (!word || word.length < 2) return word;
                
                try {
                    const doc = nlp(word);
                    
                    // Â∞ùËØïËé∑ÂèñÂä®ËØçÂéüÂΩ¢
                    const verbs = doc.verbs();
                    if (verbs.length) {
                        const infinitive = verbs.toInfinitive().out('text');
                        if (infinitive && infinitive.length > 0) {
                            return infinitive.toLowerCase();
                        }
                    }
                    
                    // Â∞ùËØïËé∑ÂèñÂêçËØçÂçïÊï∞ÂΩ¢Âºè
                    const nouns = doc.nouns();
                    if (nouns.length) {
                        const singular = nouns.toSingular().out('text');
                        if (singular && singular.length > 0) {
                            return singular.toLowerCase();
                        }
                    }
                    
                    // ËøîÂõûÂéüËØçÂ∞èÂÜô
                    return word.toLowerCase();
                } catch (e) {
                    return word.toLowerCase();
                }
            }

            // ÂàùÂßãÂåñÊáíÂä†ËΩΩÊ†áÊ≥®ËßÇÂØüÂô®
            initAnnotationObserver() {
                // Ê∏ÖÁêÜ‰πãÂâçÁöÑËßÇÂØüÂô®
                if (this.annotationObserver) {
                    this.annotationObserver.disconnect();
                }
                this.annotatedParagraphs = new Set();
                this.annotatedWordsHistory = new Map(); // Ë∑üË∏™ËØçÊúÄËøëÂá∫Áé∞ÁöÑÊÆµËêΩÁ¥¢ÂºïÔºåkey: lemma, value: ÊÆµËêΩÁ¥¢Âºï
                this.currentParagraphIndex = 0; // ÂΩìÂâçÊÆµËêΩÁ¥¢Âºï
                this.annotationQueue = []; // ÂæÖÊ†áÊ≥®ÁöÑÊÆµËêΩÈòüÂàó
                this.isProcessingAnnotation = false; // ÊòØÂê¶Ê≠£Âú®Â§ÑÁêÜÊ†áÊ≥®
                
                if (!this.annotationEnabled || !this.cocaLoaded) return;
                
                const readerContent = document.getElementById('reader-content');
                if (!readerContent) return;
                
                // Ëé∑ÂèñÊâÄÊúâÂèØÊ†áÊ≥®ÁöÑÊÆµËêΩÂÖÉÁ¥†
                const paragraphs = readerContent.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, blockquote, td, th, dt, dd, figcaption');
                
                // ‰∏∫ÊØè‰∏™ÊÆµËêΩÂàÜÈÖçÂîØ‰∏ÄID
                paragraphs.forEach((el, index) => {
                    if (!el.dataset.annotationId) {
                        el.dataset.annotationId = `anno-${index}`;
                    }
                });
                
                const container = document.getElementById('reader-container');
                
                // ÂàõÂª∫ IntersectionObserver Áî®‰∫éÊáíÂä†ËΩΩÊ†áÊ≥®
                this.annotationObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const paraId = entry.target.dataset.annotationId;
                            if (paraId && !this.annotatedParagraphs.has(paraId)) {
                                this.annotatedParagraphs.add(paraId);
                                // Âä†ÂÖ•ÈòüÂàóËÄå‰∏çÊòØÁõ¥Êé•Ë∞ÉÁî®ÔºåÁ°Æ‰øù‰∏≤Ë°åÂ§ÑÁêÜ
                                this.annotationQueue.push(entry.target);
                                this.processAnnotationQueue();
                            }
                        }
                    });
                }, {
                    root: container,
                    rootMargin: '200px 0px', // ÊèêÂâç200pxÂºÄÂßãÊ†áÊ≥®
                    threshold: 0
                });
                
                // ÂºÄÂßãËßÇÂØüÊâÄÊúâÊÆµËêΩ
                paragraphs.forEach(el => {
                    this.annotationObserver.observe(el);
                });
            }

            // ‰∏≤Ë°åÂ§ÑÁêÜÊ†áÊ≥®ÈòüÂàóÔºåÈÅøÂÖçÂπ∂ÂèëÂØºËá¥ÂéªÈáçÂ§±Êïà
            async processAnnotationQueue() {
                if (this.isProcessingAnnotation) return; // Â∑≤ÊúâÂ§ÑÁêÜ‰∏≠ÔºåÁõ¥Êé•ËøîÂõû
                this.isProcessingAnnotation = true;
                
                while (this.annotationQueue.length > 0) {
                    const element = this.annotationQueue.shift();
                    await this.annotateParagraph(element);
                }
                
                this.isProcessingAnnotation = false;
            }

            // Ê†áÊ≥®Âçï‰∏™ÊÆµËêΩÔºà‰ª•Âè•Â≠ê‰∏∫Âçï‰ΩçËøõË°ålemmatizeÔºâ
            async annotateParagraph(element) {
                if (!this.annotationEnabled || !this.cocaLoaded) return;
                
                // ÈÄíÂ¢ûÊÆµËêΩÁ¥¢Âºï
                this.currentParagraphIndex++;
                
                const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);
                const textNodes = [];
                while (walker.nextNode()) {
                    textNodes.push(walker.currentNode);
                }
                
                for (const node of textNodes) {
                    // Ë∑≥ËøáÁâπÊÆäÊ†áÁ≠æ
                    const parentTag = node.parentNode?.tagName?.toUpperCase();
                    if (['SCRIPT', 'STYLE', 'CODE', 'PRE', 'TEXTAREA'].includes(parentTag)) {
                        continue;
                    }
                    
                    const text = node.textContent;
                    if (!text || text.trim().length === 0) continue;
                    
                    // ÊèêÂèñÊâÄÊúâËã±ÊñáÂçïËØçÔºàÊîØÊåÅËøûÂ≠óÁ¨¶ËØçÊ±áÂ¶Ç gold-rimmedÔºâ
                    const wordMatches = [...text.matchAll(/[a-zA-Z]+(?:-[a-zA-Z]+)*/g)];
                    if (wordMatches.length === 0) continue;
                    
                    // ‰ª•Âè•Â≠ê‰∏∫Âçï‰ΩçËé∑ÂèñÊâÄÊúâÂçïËØçÁöÑlemmaÂíåËØçÊÄß
                    // Â∞ÜÊï¥‰∏™ÊñáÊú¨‰º†ÁªôCompromiseÔºåËÆ©ÂÆÉÊ†πÊçÆ‰∏ä‰∏ãÊñáÂà§Êñ≠ËØçÊÄß
                    const lemmaMap = this.getLemmasFromText(text);
                    
                    // Êî∂ÈõÜÈúÄË¶ÅÊ†áÊ≥®ÁöÑÂçïËØç
                    const annotations = new Map();
                    for (const match of wordMatches) {
                        const word = match[0];
                        if (word.length < 2) continue;
                        
                        const lowerWord = word.toLowerCase();
                        // ‰ºòÂÖà‰ΩøÁî®Âè•Â≠ê‰∏ä‰∏ãÊñá‰∏≠Ëé∑ÂèñÁöÑlemmaÂíåËØçÊÄßÔºåÂê¶Âàô‰ΩøÁî®ÂçïËØçÊ®°Âºè
                        const lemmaInfo = lemmaMap.get(lowerWord);
                        const lemma = lemmaInfo?.lemma || this.getLemma(word);
                        const pos = lemmaInfo?.pos || 'Unknown';
                        const rank = this.cocaRanks.get(lemma);
                        
                        if (rank && rank >= this.freqMin && rank <= this.freqMax) {
                            // Ë∑≥ËøáÂ∑≤Áü•ËØçÊ±á
                            if (this.knownWords.has(lemma)) {
                                continue;
                            }
                            
                            // Ê£ÄÊü•Ëøô‰∏™ËØçÔºàÊåâlemmaÔºâÊòØÂê¶Âú®ËøëÊúüÊÆµËêΩÂÜÖÂ∑≤Ê†áÊ≥®Ëøá
                            const lastSeenParagraph = this.annotatedWordsHistory.get(lemma);
                            const isRecentlyAnnotated = lastSeenParagraph !== undefined && 
                                (this.currentParagraphIndex - lastSeenParagraph) <= CONFIG.READING.ANNOTATION_GAP;
                            
                            if (!isRecentlyAnnotated && !annotations.has(lowerWord)) {
                                // Êü•ËØ¢ÁøªËØëÔºöÊèêÂèñÂçïËØçÊâÄÂú®ÁöÑÂè•Â≠ê‰Ωú‰∏∫‰∏ä‰∏ãÊñáÁî®‰∫é LLM ‰∏ä‰∏ãÊñáÁøªËØë
                                const sentenceContext = this.extractSentenceWithWord(text, word);
                                const cn = await this.getTranslation(lowerWord, lemma, sentenceContext);
                                if (cn && cn !== lemma && cn !== lowerWord) {
                                    annotations.set(lowerWord, { cn, rank });
                                    this.annotatedWordsHistory.set(lemma, this.currentParagraphIndex); // ËÆ∞ÂΩïËØçÂá∫Áé∞ÁöÑÊÆµËêΩÁ¥¢Âºï
                                    console.log(`[Ê†áÊ≥®] ÂéüËØç: ${word}, ËØçÊÄß: ${pos}, ÂéüÂΩ¢: ${lemma}, COCAËØçÈ¢ë: ${rank}, ÁøªËØë: ${cn}`);
                                }
                            }
                        }
                    }
                    
                    // ÊõøÊç¢ÊñáÊú¨‰∏∫Â∏¶ÊµÆÁ™óÁöÑspan
                    if (annotations.size > 0) {
                        // ÊûÑÂª∫Ê≠£ÂàôÂåπÈÖçÊâÄÊúâÈúÄË¶ÅÊ†áÊ≥®ÁöÑÂçïËØç
                        const wordsToMatch = Array.from(annotations.keys()).map(w => w.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
                        const regex = new RegExp(`\\b(${wordsToMatch.join('|')})\\b`, 'gi');
                        
                        // ÂàõÂª∫ÊñáÊ°£ÁâáÊÆµ
                        const fragment = document.createDocumentFragment();
                        let lastIndex = 0;
                        let match;
                        
                        while ((match = regex.exec(text)) !== null) {
                            // Ê∑ªÂä†ÂåπÈÖçÂâçÁöÑÊñáÊú¨
                            if (match.index > lastIndex) {
                                fragment.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
                            }
                            
                            // ÂàõÂª∫Â∏¶ÊµÆÁ™óÁöÑspan
                            const word = match[1];
                            const info = annotations.get(word.toLowerCase());
                            if (info) {
                                const span = document.createElement('span');
                                span.className = info.rank < this.learningThreshold ? 'annotation-word low-freq' : 'annotation-word';
                                span.textContent = word;
                                
                                const tooltip = document.createElement('span');
                                tooltip.className = 'annotation-tooltip';
                                tooltip.textContent = `${info.cn} [COCA: ${info.rank}]`;
                                span.appendChild(tooltip);
                                
                                fragment.appendChild(span);
                            } else {
                                fragment.appendChild(document.createTextNode(word));
                            }
                            
                            lastIndex = regex.lastIndex;
                        }
                        
                        // Ê∑ªÂä†Ââ©‰ΩôÊñáÊú¨
                        if (lastIndex < text.length) {
                            fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
                        }
                        
                        // ÊõøÊç¢ÂéüËäÇÁÇπ
                        node.parentNode.replaceChild(fragment, node);
                    }
                }
            }

            // ‰ªé localStorage Âä†ËΩΩËÆæÁΩÆ
            loadSettings() {
                const saved = localStorage.getItem('epubReaderSettings');
                const parsed = Utils.safeJsonParse(saved, {});
                this.settings = { ...CONFIG.DEFAULT_SETTINGS, ...parsed };
            }

            // ‰øùÂ≠òËÆæÁΩÆÂà∞ localStorage
            saveSettings() {
                localStorage.setItem('epubReaderSettings', JSON.stringify(this.settings));
            }

            // Â∫îÁî®ËÆæÁΩÆÂà∞ÁïåÈù¢
            applySettings() {
                const readerContent = document.getElementById('reader-content');
                
                // Â≠ó‰Ωì
                if (this.settings.fontFamily === 'system') {
                    readerContent.style.fontFamily = "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif";
                } else {
                    readerContent.style.fontFamily = this.settings.fontFamily;
                }
                
                // Â≠óÂè∑
                readerContent.style.fontSize = this.settings.fontSize + 'px';
                
                // Ë°åÈ´ò
                readerContent.style.lineHeight = this.settings.lineHeight;
                
                // ÂÜÖÂÆπÂÆΩÂ∫¶
                readerContent.style.maxWidth = this.settings.contentWidth + 'px';
                
                // ‰æßËæπË∑ù
                readerContent.style.paddingLeft = this.settings.padding + 'px';
                readerContent.style.paddingRight = this.settings.padding + 'px';
                
                // Êõ¥Êñ∞Êéß‰ª∂ÊòæÁ§∫ÂÄº
                document.getElementById('font-family').value = this.settings.fontFamily;
                document.getElementById('font-size').value = this.settings.fontSize;
                document.getElementById('font-size-value').textContent = this.settings.fontSize + 'px';
                document.getElementById('line-height').value = this.settings.lineHeight;
                document.getElementById('line-height-value').textContent = this.settings.lineHeight;
                document.getElementById('content-width').value = this.settings.contentWidth;
                document.getElementById('content-width-value').textContent = this.settings.contentWidth + 'px';
                document.getElementById('padding').value = this.settings.padding;
                document.getElementById('padding-value').textContent = this.settings.padding + 'px';
                
                // Êõ¥Êñ∞ËØçÊ±áÊ†áÊ≥®ËÆæÁΩÆ
                document.getElementById('annotation-toggle').checked = this.annotationEnabled;
                document.getElementById('freq-min').value = this.freqMin;
                document.getElementById('freq-max').value = this.freqMax;
                document.getElementById('learning-threshold').value = this.learningThreshold;
                document.getElementById('offline-dict-priority').checked = this.offlineDictPriority;
                this.updateFreqRangeVisibility();
            }

            // ÂàùÂßãÂåñËÆæÁΩÆÈù¢Êùø‰∫ã‰ª∂
            initSettingsListeners() {
                // ËæÖÂä©ÂáΩÊï∞ÔºöÂêåÊó∂ÁªëÂÆö click Âíå touchend ‰∫ã‰ª∂
                const addClickHandler = (element, handler) => {
                    if (!element) return;
                    element.addEventListener('click', handler);
                    element.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        handler(e);
                    });
                };
                
                try {
                    const settingsBtn = document.getElementById('settings-btn');
                    const settingsPanel = document.getElementById('settings-panel');
                    const settingsOverlay = document.getElementById('settings-overlay');

                    // ÊâìÂºÄ/ÂÖ≥Èó≠ËÆæÁΩÆÈù¢Êùø
                    addClickHandler(settingsBtn, () => {
                        console.log('ËÆæÁΩÆÊåâÈíÆÁÇπÂáª');
                        settingsPanel.classList.toggle('active');
                        settingsOverlay.classList.toggle('active');
                        // Êõ¥Êñ∞ËØçÂÖ∏Áä∂ÊÄÅÊòæÁ§∫
                        if (settingsPanel.classList.contains('active')) {
                            this.updateDictStatus();
                        }
                    });

                    addClickHandler(settingsOverlay, () => {
                        settingsPanel.classList.remove('active');
                        settingsOverlay.classList.remove('active');
                    });
                } catch (e) {
                    console.error('ÂàùÂßãÂåñËÆæÁΩÆÊåâÈíÆÂ§±Ë¥•:', e);
                }

                // Â≠ó‰ΩìÈÄâÊã©
                document.getElementById('font-family').addEventListener('change', (e) => {
                    this.settings.fontFamily = e.target.value;
                    this.applySettings();
                    this.saveSettings();
                });

                // Â≠óÂè∑ÊªëÂùó
                document.getElementById('font-size').addEventListener('input', (e) => {
                    this.settings.fontSize = parseInt(e.target.value);
                    this.applySettings();
                    this.saveSettings();
                });

                // Ë°åÈ´òÊªëÂùó
                document.getElementById('line-height').addEventListener('input', (e) => {
                    this.settings.lineHeight = parseFloat(e.target.value);
                    this.applySettings();
                    this.saveSettings();
                });

                // ÂÜÖÂÆπÂÆΩÂ∫¶ÊªëÂùó
                document.getElementById('content-width').addEventListener('input', (e) => {
                    this.settings.contentWidth = parseInt(e.target.value);
                    this.applySettings();
                    this.saveSettings();
                });

                // ‰æßËæπË∑ùÊªëÂùó
                document.getElementById('padding').addEventListener('input', (e) => {
                    this.settings.padding = parseInt(e.target.value);
                    this.applySettings();
                    this.saveSettings();
                });

                // ËØçÊ±áÊ†áÊ≥®ÂºÄÂÖ≥
                document.getElementById('annotation-toggle').addEventListener('change', (e) => {
                    this.annotationEnabled = e.target.checked;
                    this.saveAnnotationSettings();
                    this.updateFreqRangeVisibility();
                });

                // ËØçÈ¢ëËåÉÂõ¥ËÆæÁΩÆ
                document.getElementById('freq-min').addEventListener('change', (e) => {
                    const value = parseInt(e.target.value);
                    if (value >= 1 && value <= 60000 && value < this.freqMax) {
                        this.freqMin = value;
                        this.saveAnnotationSettings();
                    } else {
                        e.target.value = this.freqMin;
                    }
                });

                document.getElementById('freq-max').addEventListener('change', (e) => {
                    const value = parseInt(e.target.value);
                    if (value >= 1 && value <= 60000 && value > this.freqMin) {
                        this.freqMax = value;
                        this.saveAnnotationSettings();
                    } else {
                        e.target.value = this.freqMax;
                    }
                });

                // Â≠¶‰π†ËØçÈ¢ëÈòàÂÄºËÆæÁΩÆ
                document.getElementById('learning-threshold').addEventListener('change', (e) => {
                    const value = parseInt(e.target.value);
                    if (value >= 1 && value <= 60000) {
                        this.learningThreshold = value;
                        this.saveAnnotationSettings();
                    } else {
                        e.target.value = this.learningThreshold;
                    }
                });
                
                // Á¶ªÁ∫øËØçÂÖ∏ÈáçÊñ∞Âä†ËΩΩÊåâÈíÆ
                document.getElementById('reload-dict-btn').addEventListener('click', async () => {
                    await this.loadOfflineDict(true);
                });
                
                // Á¶ªÁ∫øËØçÂÖ∏‰ºòÂÖàÂºÄÂÖ≥
                document.getElementById('offline-dict-priority').addEventListener('change', (e) => {
                    this.offlineDictPriority = e.target.checked;
                    this.saveAnnotationSettings();
                });
                
                // LLM Ê®°ÂûãÂä†ËΩΩÊåâÈíÆ
                document.getElementById('load-llm-btn').addEventListener('click', async () => {
                    await this.promptModelDownload();
                });
                
                // LLM ‰∏ä‰∏ãÊñáÁøªËØëÂºÄÂÖ≥
                document.getElementById('llm-enabled').addEventListener('change', (e) => {
                    this.llmEnabled = e.target.checked;
                    this.saveLLMSettings();
                });
            }
            
            // Êõ¥Êñ∞ËØçÂÖ∏Áä∂ÊÄÅÊòæÁ§∫
            updateDictStatus(message = null) {
                const statusEl = document.getElementById('dict-status');
                if (statusEl) {
                    if (message) {
                        statusEl.textContent = message;
                        statusEl.style.color = '#f39c12';
                    } else if (this.offlineDictLoaded && this.offlineDict.size > 0) {
                        statusEl.textContent = `Â∑≤Âä†ËΩΩ ${this.offlineDict.size} ‰∏™ËØçÊù°`;
                        statusEl.style.color = '#27ae60';
                    } else {
                        statusEl.textContent = 'Êú™Âä†ËΩΩ';
                        statusEl.style.color = '#95a5a6';
                    }
                }
            }

            // Êõ¥Êñ∞ËØçÈ¢ëËåÉÂõ¥ËÆæÁΩÆÁöÑÂèØËßÅÊÄß
            updateFreqRangeVisibility() {
                const freqRangeGroup = document.getElementById('freq-range-group');
                const learningThresholdGroup = document.getElementById('learning-threshold-group');
                if (freqRangeGroup) {
                    freqRangeGroup.style.display = this.annotationEnabled ? 'block' : 'none';
                }
                if (learningThresholdGroup) {
                    learningThresholdGroup.style.display = this.annotationEnabled ? 'block' : 'none';
                }
            }

            initEventListeners() {
                // ËæÖÂä©ÂáΩÊï∞ÔºöÂêåÊó∂ÁªëÂÆö click Âíå touchend ‰∫ã‰ª∂ÔºàÁßªÂä®Á´ØÂÖºÂÆπÔºâ
                const addClickHandler = (element, handler) => {
                    if (!element) return;
                    element.addEventListener('click', handler);
                    // ÂØπ‰∫éÊüê‰∫õ iOS ËÆæÂ§áÔºåÈúÄË¶ÅÂêåÊó∂ÁªëÂÆö touchend
                    element.addEventListener('touchend', (e) => {
                        // Èò≤Ê≠¢ÂêåÊó∂Ëß¶Âèë click Âíå touchend
                        e.preventDefault();
                        handler(e);
                    });
                };
                
                try {
                    // Êñá‰ª∂‰∏ä‰º†
                    document.getElementById('file-input').addEventListener('change', (e) => {
                        console.log('Êñá‰ª∂ÈÄâÊã©‰∫ã‰ª∂Ëß¶Âèë');
                        if (e.target.files.length > 0) {
                            this.loadFile(e.target.files[0]);
                        }
                    });
                } catch (e) {
                    console.error('ÁªëÂÆöÊñá‰ª∂‰∏ä‰º†‰∫ã‰ª∂Â§±Ë¥•:', e);
                }

                try {
                    // ‰æßËæπÊ†èÂàáÊç¢
                    const sidebar = document.getElementById('sidebar');
                    const sidebarOverlay = document.getElementById('sidebar-overlay');
                    
                    const isMobile = () => window.innerWidth <= 768;
                    
                    const toggleSidebar = () => {
                        console.log('ÂàáÊç¢‰æßËæπÊ†è');
                        if (isMobile()) {
                            // ÁßªÂä®Á´ØÔºö‰ΩøÁî® expanded Á±ªÊéßÂà∂ÊòæÁ§∫
                            const isExpanded = sidebar.classList.toggle('expanded');
                            sidebarOverlay.classList.toggle('active', isExpanded);
                        } else {
                            // Ê°åÈù¢Á´ØÔºö‰ΩøÁî® collapsed Á±ªÊéßÂà∂ÈöêËóè
                            sidebar.classList.toggle('collapsed');
                        }
                    };
                    
                    const closeSidebar = () => {
                        if (isMobile()) {
                            sidebar.classList.remove('expanded');
                        } else {
                            sidebar.classList.add('collapsed');
                        }
                        sidebarOverlay.classList.remove('active');
                    };
                    
                    addClickHandler(document.getElementById('toggle-sidebar'), toggleSidebar);
                    
                    // ÁÇπÂáªÈÅÆÁΩ©ÂÖ≥Èó≠‰æßËæπÊ†è
                    addClickHandler(sidebarOverlay, closeSidebar);
                    
                    // Á™óÂè£Â§ßÂ∞èÂèòÂåñÊó∂Â§ÑÁêÜÁä∂ÊÄÅ
                    window.addEventListener('resize', () => {
                        if (!isMobile()) {
                            // ÂàáÊç¢Âà∞Ê°åÈù¢Á´ØÊó∂ÔºåÁßªÈô§ÁßªÂä®Á´ØÁõ∏ÂÖ≥Á±ª
                            sidebar.classList.remove('expanded');
                            sidebarOverlay.classList.remove('active');
                        }
                    });
                } catch (e) {
                    console.error('ÁªëÂÆö‰æßËæπÊ†è‰∫ã‰ª∂Â§±Ë¥•:', e);
                }

                try {
                    // ÊãñÊîæÊîØÊåÅÔºàÁßªÂä®Á´Ø‰∏çÊîØÊåÅÊãñÊîæÔºåËøôÈáåÂè™Â§ÑÁêÜÊ°åÈù¢Á´ØÔºâ
                    const dropZone = document.getElementById('drop-zone');
                    const container = document.getElementById('reader-container');

                    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                        container.addEventListener(eventName, (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                        });
                    });

                    container.addEventListener('dragenter', () => dropZone.classList.add('drag-over'));
                    container.addEventListener('dragleave', () => dropZone.classList.remove('drag-over'));
                    container.addEventListener('drop', (e) => {
                        dropZone.classList.remove('drag-over');
                        const files = e.dataTransfer.files;
                        if (files.length > 0) {
                            const fileName = files[0].name.toLowerCase();
                            if (fileName.endsWith('.epub') || fileName.endsWith('.pdf')) {
                                this.loadFile(files[0]);
                            }
                        }
                    });
                } catch (e) {
                    console.error('ÁªëÂÆöÊãñÊîæ‰∫ã‰ª∂Â§±Ë¥•:', e);
                }

                try {
                    // ÊªöÂä®Êó∂Êõ¥Êñ∞ÁõÆÂΩïÈ´ò‰∫ÆÂíåËøõÂ∫¶ - ‰ΩøÁî®ËäÇÊµÅÂíåÈò≤Êäñ‰ºòÂåñÊÄßËÉΩ
                    const throttledUpdate = Utils.throttle(() => {
                        this.updateActiveTocItem();
                        this.updateProgress();
                    }, 100);
                    
                    const debouncedSave = Utils.debounce(() => {
                        this.saveReadingProgress();
                    }, CONFIG.INTERVALS.SAVE_DEBOUNCE);
                    
                    document.getElementById('reader-container').addEventListener('scroll', () => {
                        throttledUpdate();
                        debouncedSave();
                    }, { passive: true });
                } catch (e) {
                    console.error('ÁªëÂÆöÊªöÂä®‰∫ã‰ª∂Â§±Ë¥•:', e);
                }

                try {
                    // ‰π¶Êû∂ÊåâÈíÆ
                    addClickHandler(document.getElementById('library-btn'), () => {
                        console.log('‰π¶Êû∂ÊåâÈíÆÁÇπÂáª');
                        this.showLibrary();
                    });

                    // ËØçÊ±áË°®ÊåâÈíÆ
                    addClickHandler(document.getElementById('vocab-btn'), () => {
                        console.log('ËØçÊ±áË°®ÊåâÈíÆÁÇπÂáª');
                        this.showVocabularyModal();
                    });

                    // Â∑≤Êü•ËØ¢ËØçË°®ÊåâÈíÆ
                    const lookedUpBtn = document.getElementById('looked-up-btn');
                    if (lookedUpBtn) {
                        addClickHandler(lookedUpBtn, () => {
                            console.log('Â∑≤Êü•ËØ¢ËØçË°®ÊåâÈíÆÁÇπÂáª');
                            this.showLookedUpWordsModal();
                        });
                    }
                } catch (e) {
                    console.error('ÁªëÂÆöÂ∑•ÂÖ∑Ê†èÊåâÈíÆ‰∫ã‰ª∂Â§±Ë¥•:', e);
                }

                try {
                    // ÈÄâËØçÊµÆÂä®ÊåâÈíÆ
                    this.initWordSelection();
                    
                    // ÂàùÂßãÂåñËØçÊ±áÊÇ¨ÂÅúËÆ∞ÂΩï
                    this.initWordHoverTracking();
                } catch (e) {
                    console.error('ÂàùÂßãÂåñÈÄâËØçÂäüËÉΩÂ§±Ë¥•:', e);
                }
                
                console.log('‰∫ã‰ª∂ÁõëÂê¨Âô®ÂàùÂßãÂåñÂÆåÊàê');
            }

            // ÂàùÂßãÂåñÈÄâËØçÂäüËÉΩ
            initWordSelection() {
                const wordActionBtn = document.getElementById('word-action-btn');
                const readerContainer = document.getElementById('reader-container');

                // Â§ÑÁêÜÊñáÊú¨ÈÄâÊã©ÁöÑÂáΩÊï∞
                const handleSelection = (e) => {
                    // Âª∂ËøüÂ§ÑÁêÜÔºåÁ°Æ‰øùÈÄâÂå∫Â∑≤ÁªèÂª∫Á´ã
                    setTimeout(() => {
                        this.handleTextSelection(e);
                    }, 10);
                };

                // ÁõëÂê¨Èº†Ê†áÊä¨Ëµ∑‰∫ã‰ª∂ÔºàÊ°åÈù¢Á´ØÔºâ
                readerContainer.addEventListener('mouseup', handleSelection);
                
                // ÁõëÂê¨Ëß¶Êë∏ÁªìÊùü‰∫ã‰ª∂ÔºàÁßªÂä®Á´ØÔºâ
                readerContainer.addEventListener('touchend', handleSelection, { passive: true });

                // ÈöêËóèÊåâÈíÆÁöÑÂáΩÊï∞
                const hideBtn = (e) => {
                    if (e.target !== wordActionBtn) {
                        this.hideWordActionBtn();
                    }
                };

                // ÁõëÂê¨ÁÇπÂáª/Ëß¶Êë∏‰∫ã‰ª∂ÈöêËóèÊåâÈíÆ
                document.addEventListener('mousedown', hideBtn);
                document.addEventListener('touchstart', hideBtn, { passive: true });

                // ÁÇπÂáªÊµÆÂä®ÊåâÈíÆÔºàÂêåÊó∂ÊîØÊåÅ click Âíå touchendÔºâ
                const handleWordAction = async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (this.selectedWordInfo) {
                        await this.toggleKnownWord(this.selectedWordInfo.lemma);
                    }
                };
                
                wordActionBtn.addEventListener('click', handleWordAction);
                wordActionBtn.addEventListener('touchend', handleWordAction);
            }

            // ÂàùÂßãÂåñËØçÊ±áÊÇ¨ÂÅúËøΩË∏™
            initWordHoverTracking() {
                try {
                    const readerContainer = document.getElementById('reader-container');
                    if (!readerContainer) return;
                    
                    // ‰ΩøÁî® mouseover ‰∫ã‰ª∂ÂßîÊâòÁõëÂê¨ÊÇ¨ÂÅú
                    readerContainer.addEventListener('mouseover', (e) => {
                        try {
                            const annotationWord = e.target.closest('.annotation-word');
                            if (!annotationWord) return;
                            
                            const tooltip = annotationWord.querySelector('.annotation-tooltip');
                            if (!tooltip) return;
                            
                            const word = annotationWord.textContent.replace(tooltip.textContent, '').trim().toLowerCase();
                            if (!word) return;
                            
                            this.recordLookedUpWord(annotationWord);
                        } catch (e) {
                            // ÂøΩÁï•ÊÇ¨ÂÅúËøΩË∏™ÈîôËØØ
                        }
                    });
                } catch (e) {
                    console.warn('ÂàùÂßãÂåñËØçÊ±áÊÇ¨ÂÅúËøΩË∏™Â§±Ë¥•:', e);
                }
            }

            // ËÆ∞ÂΩïÊü•ËØ¢ÁöÑÂçïËØç
            recordLookedUpWord(element) {
                try {
                    const tooltip = element.querySelector('.annotation-tooltip');
                    if (!tooltip) return;
                    
                    // Ëé∑ÂèñÂçïËØçÔºöÊéíÈô§ tooltip ÁöÑÊñáÊú¨
                    const tooltipText = tooltip.textContent;
                    const word = element.textContent.replace(tooltipText, '').trim().toLowerCase();
                    if (!word) return;
                    
                    // Ëß£ÊûêÊµÆÁ™óÂÜÖÂÆπ: "ÁøªËØë [COCA: ÊéíÂêç]"
                    const match = tooltipText.match(/^(.+?)\s*\[COCA:\s*(\d+)\]$/);
                    if (!match) return;
                    
                    const translation = match[1].trim();
                    const rank = parseInt(match[2], 10);
                    
                    // ÂºÇÊ≠•‰øùÂ≠òÔºå‰∏çÈòªÂ°û
                    this.bookStorage.addLookedUpWord(word, translation, rank).then(() => {
                        // Êõ¥Êñ∞ÂÜÖÂ≠òÁºìÂ≠ò
                        const existing = this.lookedUpWords.get(word);
                        this.lookedUpWords.set(word, {
                            word,
                            translation,
                            rank,
                            lookedUpAt: existing?.lookedUpAt || Date.now(),
                            lastLookedUpAt: Date.now(),
                            count: (existing?.count || 0) + 1
                        });
                    }).catch(e => {
                        console.warn('ËÆ∞ÂΩïÊü•ËØ¢ËØçÊ±áÂ§±Ë¥•:', e);
                    });
                } catch (e) {
                    console.warn('ËÆ∞ÂΩïÊü•ËØ¢ËØçÊ±áÂ§±Ë¥•:', e);
                }
            }

            // ÊòæÁ§∫Â∑≤Êü•ËØ¢ËØçË°®Ê®°ÊÄÅÊ°Ü
            async showLookedUpWordsModal() {
                const words = await this.bookStorage.getAllLookedUpWords();
                this.renderLookedUpWordsModal(words);
            }

            // Ê∏≤ÊüìÂ∑≤Êü•ËØ¢ËØçË°®Ê®°ÊÄÅÊ°Ü
            renderLookedUpWordsModal(words, filterText = '') {
                // ËøáÊª§ËØçÊ±á
                const filteredWords = filterText 
                    ? words.filter(w => w.word.includes(filterText.toLowerCase()) || w.translation.includes(filterText))
                    : words;

                const modal = document.createElement('div');
                modal.className = 'vocab-modal looked-up-modal';
                modal.id = 'looked-up-modal';
                modal.innerHTML = `
                    <div class="vocab-content">
                        <div class="vocab-header">
                            <h2>üîç Â∑≤Êü•ËØ¢ËØçË°®</h2>
                            <div class="vocab-header-actions">
                                <input type="text" class="vocab-search" id="looked-up-search" placeholder="ÊêúÁ¥¢ËØçÊ±á..." value="${filterText}">
                                <button class="vocab-close" id="looked-up-close">‚úï</button>
                            </div>
                        </div>
                        <div class="vocab-stats">
                            ÂÖ± ${words.length} ‰∏™ËØçÊ±á${filterText ? `ÔºåÊòæÁ§∫ ${filteredWords.length} ‰∏™ÂåπÈÖçÁªìÊûú` : ''}
                        </div>
                        <div class="vocab-list" id="looked-up-list">
                            ${filteredWords.length === 0 ? `
                                <div class="vocab-empty">
                                    ${filterText ? 'Ê≤°ÊúâÊâæÂà∞ÂåπÈÖçÁöÑËØçÊ±á' : 'Â∑≤Êü•ËØ¢ËØçË°®‰∏∫Á©∫ÔºåÊÇ¨ÂÅúÂú®Ê†áÊ≥®ËØçÊ±á‰∏äÊü•ÁúãËØç‰πâÂêé‰ºöËá™Âä®ËÆ∞ÂΩï'}
                                </div>
                            ` : filteredWords.map(word => `
                                <div class="vocab-word looked-up-word" data-word="${word.word}">
                                    <div class="looked-up-main">
                                        <span class="vocab-word-text">${word.word}</span>
                                        <span class="looked-up-translation">${word.translation}</span>
                                        <span class="looked-up-rank">[COCA: ${word.rank}]</span>
                                    </div>
                                    <div class="vocab-word-meta">
                                        <span class="looked-up-count">Êü•Áúã ${word.count} Ê¨°</span>
                                        <span class="vocab-word-date">${this.formatDate(word.lastLookedUpAt)}</span>
                                        <button class="vocab-word-delete" data-word="${word.word}">üóë</button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <div class="vocab-footer">
                            <button class="vocab-export-btn" id="looked-up-export">üì• ÂØºÂá∫ËØçË°®</button>
                            <button class="vocab-clear-btn" id="looked-up-clear">üóë Ê∏ÖÁ©∫ÂÖ®ÈÉ®</button>
                        </div>
                    </div>
                `;

                // ÁßªÈô§Â∑≤Â≠òÂú®ÁöÑÊ®°ÊÄÅÊ°Ü
                const existingModal = document.getElementById('looked-up-modal');
                if (existingModal) {
                    existingModal.remove();
                }

                document.body.appendChild(modal);

                // ÂÖ≥Èó≠ÊåâÈíÆ
                document.getElementById('looked-up-close').addEventListener('click', () => {
                    modal.remove();
                });

                // ÁÇπÂáªËÉåÊôØÂÖ≥Èó≠
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });

                // ÊêúÁ¥¢ÂäüËÉΩ
                let searchTimeout = null;
                document.getElementById('looked-up-search').addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        modal.remove();
                        this.renderLookedUpWordsModal(words, e.target.value);
                        // ËÅöÁÑ¶Âà∞ÊêúÁ¥¢Ê°ÜÂπ∂‰øùÊåÅÂÖâÊ†á‰ΩçÁΩÆ
                        const searchInput = document.getElementById('looked-up-search');
                        if (searchInput) {
                            searchInput.focus();
                            searchInput.setSelectionRange(e.target.value.length, e.target.value.length);
                        }
                    }, 300);
                });

                // Âà†Èô§Âçï‰∏™ËØçÊ±á
                modal.querySelectorAll('.vocab-word-delete').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const word = btn.dataset.word;
                        await this.bookStorage.removeLookedUpWord(word);
                        this.lookedUpWords.delete(word);
                        btn.closest('.vocab-word').remove();
                        // Êõ¥Êñ∞ÁªüËÆ°
                        const statsEl = modal.querySelector('.vocab-stats');
                        const newWords = await this.bookStorage.getAllLookedUpWords();
                        const newFiltered = filterText 
                            ? newWords.filter(w => w.word.includes(filterText.toLowerCase()) || w.translation.includes(filterText))
                            : newWords;
                        statsEl.textContent = `ÂÖ± ${newWords.length} ‰∏™ËØçÊ±á${filterText ? `ÔºåÊòæÁ§∫ ${newFiltered.length} ‰∏™ÂåπÈÖçÁªìÊûú` : ''}`;
                        
                        // Â¶ÇÊûúÂàóË°®‰∏∫Á©∫ÔºåÊòæÁ§∫Á©∫Áä∂ÊÄÅ
                        if (newFiltered.length === 0) {
                            document.getElementById('looked-up-list').innerHTML = `
                                <div class="vocab-empty">
                                    ${filterText ? 'Ê≤°ÊúâÊâæÂà∞ÂåπÈÖçÁöÑËØçÊ±á' : 'Â∑≤Êü•ËØ¢ËØçË°®‰∏∫Á©∫ÔºåÊÇ¨ÂÅúÂú®Ê†áÊ≥®ËØçÊ±á‰∏äÊü•ÁúãËØç‰πâÂêé‰ºöËá™Âä®ËÆ∞ÂΩï'}
                                </div>
                            `;
                        }
                    });
                });

                // ÂØºÂá∫ËØçÊ±áË°®
                document.getElementById('looked-up-export').addEventListener('click', () => {
                    this.exportLookedUpWords(words);
                });

                // Ê∏ÖÁ©∫ÂÖ®ÈÉ®
                document.getElementById('looked-up-clear').addEventListener('click', async () => {
                    if (confirm('Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâÂ∑≤Êü•ËØ¢ËØçÊ±áÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ')) {
                        await this.bookStorage.clearAllLookedUpWords();
                        this.lookedUpWords.clear();
                        modal.remove();
                        this.showLookedUpWordsModal();
                    }
                });
            }

            // ÂØºÂá∫Â∑≤Êü•ËØ¢ËØçË°®
            exportLookedUpWords(words) {
                // Â∞ÜÁøªËØë‰∏≠ÁöÑÊç¢Ë°åÁ¨¶ÊõøÊç¢‰∏∫ÂàÜÂè∑ÔºåÈÅøÂÖçÁ†¥Âùè TSV Ê†ºÂºè
                const content = words.map(w => `${w.word}\t${(w.translation || '').replace(/\n/g, '; ')}\t${w.rank}\t${w.count}`).join('\n');
                const header = 'ÂçïËØç\tÁøªËØë\tCOCAÊéíÂêç\tÊü•ÁúãÊ¨°Êï∞\n';
                const blob = new Blob([header + content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `looked_up_words_${new Date().toISOString().slice(0,10)}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // Â§ÑÁêÜÊñáÊú¨ÈÄâÊã©
            handleTextSelection(e) {
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();

                // Ê£ÄÊü•ÊòØÂê¶ÈÄâ‰∏≠‰∫ÜÂçï‰∏™ÂçïËØç
                if (!selectedText || !/^[a-zA-Z]+(?:-[a-zA-Z]+)?$/.test(selectedText)) {
                    this.hideWordActionBtn();
                    return;
                }

                // Ëé∑ÂèñÂçïËØçÁöÑÂéüÂΩ¢
                const lemma = this.getLemma(selectedText);
                const isKnown = this.knownWords.has(lemma.toLowerCase());

                // ‰øùÂ≠òÈÄâ‰∏≠‰ø°ÊÅØ
                this.selectedWordInfo = {
                    word: selectedText,
                    lemma: lemma.toLowerCase(),
                    isKnown: isKnown
                };

                // ÊòæÁ§∫ÊµÆÂä®ÊåâÈíÆ
                this.showWordActionBtn(e.clientX, e.clientY, isKnown);
            }

            // ÊòæÁ§∫ÈÄâËØçÊµÆÂä®ÊåâÈíÆ
            showWordActionBtn(x, y, isKnown) {
                const btn = document.getElementById('word-action-btn');
                
                // Êõ¥Êñ∞ÊåâÈíÆÊñáÊú¨ÂíåÊ†∑Âºè
                if (isKnown) {
                    btn.textContent = '- ‰ªéÂ∑≤Áü•ËØçÊ±áË°®ÁßªÈô§';
                    btn.classList.add('remove');
                } else {
                    btn.textContent = '+ Âä†ÂÖ•Â∑≤Áü•ËØçÊ±áË°®';
                    btn.classList.remove('remove');
                }

                // ËÆ°ÁÆóÊåâÈíÆ‰ΩçÁΩÆÔºàÂú®ÈÄâÂå∫‰∏äÊñπÊàñ‰∏ãÊñπÔºâ
                const btnHeight = 36;
                const btnWidth = 130;
                let posX = x - btnWidth / 2;
                let posY = y - btnHeight - 10;

                // Á°Æ‰øù‰∏çË∂ÖÂá∫Â±èÂπïËæπÁïå
                posX = Math.max(10, Math.min(posX, window.innerWidth - btnWidth - 10));
                if (posY < 10) {
                    posY = y + 20; // Â¶ÇÊûú‰∏äÊñπÁ©∫Èó¥‰∏çË∂≥ÔºåÊòæÁ§∫Âú®‰∏ãÊñπ
                }

                btn.style.left = posX + 'px';
                btn.style.top = posY + 'px';
                btn.style.display = 'block';
            }

            // ÈöêËóèÈÄâËØçÊµÆÂä®ÊåâÈíÆ
            hideWordActionBtn() {
                const btn = document.getElementById('word-action-btn');
                btn.style.display = 'none';
                this.selectedWordInfo = null;
            }

            // ÂàáÊç¢Â∑≤Áü•ËØçÊ±áÁä∂ÊÄÅ
            async toggleKnownWord(lemma) {
                const lowerLemma = lemma.toLowerCase();
                
                try {
                    if (this.knownWords.has(lowerLemma)) {
                        // ‰ªéÂ∑≤Áü•ËØçÊ±á‰∏≠ÁßªÈô§
                        await this.bookStorage.removeKnownWord(lowerLemma);
                        this.knownWords.delete(lowerLemma);
                        console.log(`Â∑≤‰ªéËØçÊ±áË°®ÁßªÈô§: ${lowerLemma}`);
                    } else {
                        // Ê∑ªÂä†Âà∞Â∑≤Áü•ËØçÊ±á
                        await this.bookStorage.addKnownWord(lowerLemma);
                        this.knownWords.add(lowerLemma);
                        console.log(`Â∑≤Âä†ÂÖ•ËØçÊ±áË°®: ${lowerLemma}`);
                    }
                } catch (e) {
                    console.error('Êõ¥Êñ∞ËØçÊ±áË°®Â§±Ë¥•:', e);
                }

                this.hideWordActionBtn();
                // Ê∏ÖÈô§ÈÄâÂå∫
                window.getSelection().removeAllRanges();
            }

            // ÊòæÁ§∫ËØçÊ±áË°®Ê®°ÊÄÅÊ°Ü
            async showVocabularyModal() {
                const words = await this.bookStorage.getAllKnownWords();
                this.renderVocabularyModal(words);
            }

            // Ê∏≤ÊüìËØçÊ±áË°®Ê®°ÊÄÅÊ°Ü
            renderVocabularyModal(words, filterText = '') {
                // ËøáÊª§ËØçÊ±á
                const filteredWords = filterText 
                    ? words.filter(w => w.lemma.includes(filterText.toLowerCase()))
                    : words;

                const modal = document.createElement('div');
                modal.className = 'vocab-modal';
                modal.id = 'vocab-modal';
                modal.innerHTML = `
                    <div class="vocab-content">
                        <div class="vocab-header">
                            <h2>üìñ Â∑≤Áü•ËØçÊ±áË°®</h2>
                            <div class="vocab-header-actions">
                                <input type="text" class="vocab-search" id="vocab-search" placeholder="ÊêúÁ¥¢ËØçÊ±á..." value="${filterText}">
                                <button class="vocab-close" id="vocab-close">‚úï</button>
                            </div>
                        </div>
                        <div class="vocab-stats">
                            ÂÖ± ${words.length} ‰∏™ËØçÊ±á${filterText ? `ÔºåÊòæÁ§∫ ${filteredWords.length} ‰∏™ÂåπÈÖçÁªìÊûú` : ''}
                        </div>
                        <div class="vocab-list" id="vocab-list">
                            ${filteredWords.length === 0 ? `
                                <div class="vocab-empty">
                                    ${filterText ? 'Ê≤°ÊúâÊâæÂà∞ÂåπÈÖçÁöÑËØçÊ±á' : 'Â∑≤Áü•ËØçÊ±áË°®‰∏∫Á©∫ÔºåÈÄâ‰∏≠ÂçïËØçÂêéÁÇπÂáª"Âä†ÂÖ•Â∑≤Áü•ËØçÊ±áË°®"ÊåâÈíÆÊ∑ªÂä†'}
                                </div>
                            ` : filteredWords.map(word => `
                                <div class="vocab-word" data-lemma="${word.lemma}">
                                    <span class="vocab-word-text">${word.lemma}</span>
                                    <div class="vocab-word-meta">
                                        <span class="vocab-word-date">${this.formatDate(word.addedAt)}</span>
                                        <button class="vocab-word-delete" data-lemma="${word.lemma}">üóë</button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <div class="vocab-footer">
                            <button class="vocab-export-btn" id="vocab-export">üì• ÂØºÂá∫ËØçË°®</button>
                            <button class="vocab-clear-btn" id="vocab-clear">üóë Ê∏ÖÁ©∫ÂÖ®ÈÉ®</button>
                        </div>
                    </div>
                `;

                // ÁßªÈô§Â∑≤Â≠òÂú®ÁöÑÊ®°ÊÄÅÊ°Ü
                const existingModal = document.getElementById('vocab-modal');
                if (existingModal) {
                    existingModal.remove();
                }

                document.body.appendChild(modal);

                // ÂÖ≥Èó≠ÊåâÈíÆ
                document.getElementById('vocab-close').addEventListener('click', () => {
                    modal.remove();
                });

                // ÁÇπÂáªËÉåÊôØÂÖ≥Èó≠
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });

                // ÊêúÁ¥¢ÂäüËÉΩ
                let searchTimeout = null;
                document.getElementById('vocab-search').addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        modal.remove();
                        this.renderVocabularyModal(words, e.target.value);
                        // ËÅöÁÑ¶Âà∞ÊêúÁ¥¢Ê°ÜÂπ∂‰øùÊåÅÂÖâÊ†á‰ΩçÁΩÆ
                        const searchInput = document.getElementById('vocab-search');
                        if (searchInput) {
                            searchInput.focus();
                            searchInput.setSelectionRange(e.target.value.length, e.target.value.length);
                        }
                    }, 300);
                });

                // Âà†Èô§Âçï‰∏™ËØçÊ±á
                modal.querySelectorAll('.vocab-word-delete').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const lemma = btn.dataset.lemma;
                        await this.bookStorage.removeKnownWord(lemma);
                        this.knownWords.delete(lemma);
                        btn.closest('.vocab-word').remove();
                        // Êõ¥Êñ∞ÁªüËÆ°
                        const statsEl = modal.querySelector('.vocab-stats');
                        const newWords = await this.bookStorage.getAllKnownWords();
                        const newFiltered = filterText 
                            ? newWords.filter(w => w.lemma.includes(filterText.toLowerCase()))
                            : newWords;
                        statsEl.textContent = `ÂÖ± ${newWords.length} ‰∏™ËØçÊ±á${filterText ? `ÔºåÊòæÁ§∫ ${newFiltered.length} ‰∏™ÂåπÈÖçÁªìÊûú` : ''}`;
                        
                        // Â¶ÇÊûúÂàóË°®‰∏∫Á©∫ÔºåÊòæÁ§∫Á©∫Áä∂ÊÄÅ
                        if (newFiltered.length === 0) {
                            document.getElementById('vocab-list').innerHTML = `
                                <div class="vocab-empty">
                                    ${filterText ? 'Ê≤°ÊúâÊâæÂà∞ÂåπÈÖçÁöÑËØçÊ±á' : 'Â∑≤Áü•ËØçÊ±áË°®‰∏∫Á©∫ÔºåÈÄâ‰∏≠ÂçïËØçÂêéÁÇπÂáª"Âä†ÂÖ•Â∑≤Áü•ËØçÊ±áË°®"ÊåâÈíÆÊ∑ªÂä†'}
                                </div>
                            `;
                        }
                    });
                });

                // ÂØºÂá∫ËØçÊ±áË°®
                document.getElementById('vocab-export').addEventListener('click', () => {
                    this.exportVocabulary(words);
                });

                // Ê∏ÖÁ©∫ÂÖ®ÈÉ®
                document.getElementById('vocab-clear').addEventListener('click', async () => {
                    if (confirm('Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâÂ∑≤Áü•ËØçÊ±áÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ')) {
                        await this.bookStorage.clearAllKnownWords();
                        this.knownWords.clear();
                        modal.remove();
                        this.showVocabularyModal();
                    }
                });
            }

            // Ê†ºÂºèÂåñÊó•Êúü - ‰ΩøÁî®Â∑•ÂÖ∑ÂáΩÊï∞
            formatDate(timestamp) {
                return Utils.formatDate(timestamp);
            }

            // ÂØºÂá∫ËØçÊ±áË°®
            exportVocabulary(words) {
                const content = words.map(w => w.lemma).join('\n');
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `vocabulary_${new Date().toISOString().slice(0,10)}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // Êõ¥Êñ∞ÈòÖËØªËøõÂ∫¶
            updateProgress() {
                const container = document.getElementById('reader-container');
                const readerContent = document.getElementById('reader-content');
                
                if (readerContent.style.display === 'none') return;
                
                const scrollTop = container.scrollTop;
                const scrollHeight = container.scrollHeight - container.clientHeight;
                
                let progress = 0;
                if (scrollHeight > 0) {
                    progress = Math.min(100, Math.round((scrollTop / scrollHeight) * 100));
                }
                
                document.getElementById('progress-bar').style.width = progress + '%';
                document.getElementById('progress-text').textContent = progress + '%';
            }

            showLoading(show) {
                document.getElementById('loading').classList.toggle('active', show);
            }

            // Ê†πÊçÆÊñá‰ª∂Á±ªÂûãÂä†ËΩΩÊñá‰ª∂
            async loadFile(file) {
                console.log('ÂºÄÂßãÂä†ËΩΩÊñá‰ª∂:', file.name, 'Â§ßÂ∞è:', file.size);
                
                const fileName = file.name.toLowerCase();
                
                try {
                    if (fileName.endsWith('.pdf')) {
                        // Ê£ÄÊü• PDF.js ÊòØÂê¶ÂèØÁî®
                        if (typeof pdfjsLib === 'undefined') {
                            alert('PDF.js Â∫ìÊú™ËÉΩÂä†ËΩΩÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•ÂêéÂà∑Êñ∞È°µÈù¢ÈáçËØï„ÄÇ');
                            return;
                        }
                        await this.loadPDF(file);
                    } else if (fileName.endsWith('.epub')) {
                        // Ê£ÄÊü• JSZip ÊòØÂê¶ÂèØÁî®
                        if (typeof JSZip === 'undefined') {
                            alert('JSZip Â∫ìÊú™ËÉΩÂä†ËΩΩÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•ÂêéÂà∑Êñ∞È°µÈù¢ÈáçËØï„ÄÇ');
                            return;
                        }
                        await this.loadEPUB(file);
                    } else {
                        alert('‰∏çÊîØÊåÅÁöÑÊñá‰ª∂Ê†ºÂºèÔºåËØ∑‰∏ä‰º† EPUB Êàñ PDF Êñá‰ª∂„ÄÇ');
                    }
                } catch (error) {
                    console.error('Âä†ËΩΩÊñá‰ª∂Â§±Ë¥•:', error);
                    this.showLoading(false);
                    alert('Âä†ËΩΩÊñá‰ª∂Â§±Ë¥•: ' + (error.message || 'Êú™Áü•ÈîôËØØ'));
                }
            }

            async loadEPUB(file) {
                this.showLoading(true);
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    this.currentFileName = file.name;
                    
                    // ÂÖàËß£ÊûêËé∑ÂèñÂÖÉÊï∞ÊçÆ
                    const tempZip = await JSZip.loadAsync(arrayBuffer);
                    const containerXml = await tempZip.file('META-INF/container.xml').async('text');
                    const containerDoc = new DOMParser().parseFromString(containerXml, 'application/xml');
                    const opfPath = containerDoc.querySelector('rootfile').getAttribute('full-path');
                    const opfContent = await tempZip.file(opfPath).async('text');
                    const opfDoc = new DOMParser().parseFromString(opfContent, 'application/xml');
                    const metadataEl = opfDoc.querySelector('metadata');
                    const metadata = {
                        title: metadataEl?.querySelector('title')?.textContent || file.name,
                        author: metadataEl?.querySelector('creator')?.textContent || ''
                    };
                    
                    // ‰øùÂ≠òÂà∞ IndexedDB
                    try {
                        const bookId = await this.bookStorage.saveBook(arrayBuffer, file.name, metadata);
                        this.currentBookId = bookId;
                        this.bookStorage.setLastBookId(bookId);
                    } catch (e) {
                        console.warn('Êó†Ê≥ï‰øùÂ≠ò‰π¶Á±çÂà∞Â≠òÂÇ®:', e);
                    }
                    
                    // ÈáçÁΩÆÈòÖËØªÊó∂Èó¥ÂíåÊªöÂä®‰ΩçÁΩÆÔºàÊñ∞Êñá‰ª∂Ôºâ
                    this.pendingScrollPosition = null;
                    this.totalReadingTime = 0;
                    
                    await this.loadEPUBFromArrayBuffer(arrayBuffer, file.name, false);
                } catch (error) {
                    console.error('Âä†ËΩΩ EPUB Â§±Ë¥•:', error);
                    alert('Âä†ËΩΩ EPUB Êñá‰ª∂Â§±Ë¥•ÔºåËØ∑Á°Æ‰øùÊñá‰ª∂Ê†ºÂºèÊ≠£Á°Æ„ÄÇ');
                    this.showLoading(false);
                }
            }

            async loadEPUBFromArrayBuffer(arrayBuffer, fileName, isReload = false) {
                this.showLoading(true);
                try {
                    this.zip = await JSZip.loadAsync(arrayBuffer);
                    
                    // Ëß£Êûê container.xml Ëé∑Âèñ OPF Ë∑ØÂæÑ
                    const containerXml = await this.zip.file('META-INF/container.xml').async('text');
                    const containerDoc = new DOMParser().parseFromString(containerXml, 'application/xml');
                    this.opfPath = containerDoc.querySelector('rootfile').getAttribute('full-path');
                    this.opfDir = this.opfPath.substring(0, this.opfPath.lastIndexOf('/') + 1);

                    // Ëß£Êûê OPF Êñá‰ª∂
                    const opfContent = await this.zip.file(this.opfPath).async('text');
                    const opfDoc = new DOMParser().parseFromString(opfContent, 'application/xml');
                    
                    this.parseMetadata(opfDoc);
                    this.parseManifest(opfDoc);
                    this.parseSpine(opfDoc);
                    await this.parseTOC(opfDoc);
                    
                    await this.renderBook();
                    this.renderTOC();
                    
                    document.getElementById('book-title').textContent = this.metadata.title || fileName;
                    document.getElementById('welcome-screen').style.display = 'none';
                    document.getElementById('reader-content').style.display = 'block';
                    document.getElementById('progress-indicator').style.display = 'flex';
                    document.getElementById('time-indicator').classList.add('active');
                    
                    // ËÆ°ÁÆóÊÄªÂçïËØçÊï∞ÔºàÊåâËã±ÊñáÂçïËØçÊï∞ÈáèÔºâ
                    const readerContent = document.getElementById('reader-content');
                    this.totalCharacters = this.countWords(readerContent.textContent);
                    
                    // ÊòæÁ§∫ÊÄªÂ≠óÊï∞
                    this.updateWordCountDisplay();
                    
                    // ÂºÄÂßãÈòÖËØªÈÄüÂ∫¶Ë∑üË∏™
                    this.startSpeedTracking();
                    
                    // ÂàùÂßãÂåñÊáíÂä†ËΩΩËØçÊ±áÊ†áÊ≥®
                    this.initAnnotationObserver();
                    
                    // ÂºÄÂßãÈòÖËØªÊó∂Èó¥Ë∑üË∏™
                    this.startReadingTime();
                    this.updateTimeDisplay();
                    
                    // ÊÅ¢Â§çÈòÖËØª‰ΩçÁΩÆ
                    if (this.pendingScrollPosition !== null) {
                        const container = document.getElementById('reader-container');
                        // ‰ΩøÁî® requestAnimationFrame Á°Æ‰øù DOM Â∑≤Ê∏≤Êüì
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                container.scrollTop = this.pendingScrollPosition;
                                this.pendingScrollPosition = null;
                                this.updateProgress();
                                this.updateActiveTocItem();
                            });
                        });
                    } else {
                        this.updateProgress();
                    }
                } catch (error) {
                    console.error('Âä†ËΩΩ EPUB Â§±Ë¥•:', error);
                    alert('Âä†ËΩΩ EPUB Êñá‰ª∂Â§±Ë¥•ÔºåËØ∑Á°Æ‰øùÊñá‰ª∂Ê†ºÂºèÊ≠£Á°Æ„ÄÇ');
                } finally {
                    this.showLoading(false);
                }
            }

            // PDF Âä†ËΩΩÊñπÊ≥ï
            async loadPDF(file) {
                this.showLoading(true);
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    this.currentFileName = file.name;
                    this.currentFileType = 'pdf';
                    
                    // Â§çÂà∂ ArrayBuffer Áî®‰∫éÂ≠òÂÇ®ÔºàÂõ†‰∏∫ PDF.js ‰ºö detach ÂéüÂßã bufferÔºâ
                    const arrayBufferCopy = arrayBuffer.slice(0);
                    
                    // ËÆæÁΩÆ PDF.js worker
                    pdfjsLib.GlobalWorkerOptions.workerSrc = CONFIG.URLS.PDF_WORKER;
                    
                    // Âä†ËΩΩ PDF ÊñáÊ°£Ëé∑ÂèñÂÖÉÊï∞ÊçÆ
                    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                    
                    // Ëé∑Âèñ PDF ÂÖÉÊï∞ÊçÆ
                    const pdfMetadata = await pdf.getMetadata().catch(() => ({}));
                    const metadata = {
                        title: pdfMetadata.info?.Title || file.name.replace(/\.pdf$/i, ''),
                        author: pdfMetadata.info?.Author || ''
                    };
                    
                    // ‰øùÂ≠òÂà∞ IndexedDBÔºà‰ΩøÁî®Â§çÂà∂ÁöÑ bufferÔºâ
                    try {
                        const bookId = await this.bookStorage.saveBook(arrayBufferCopy, file.name, metadata, 'pdf');
                        this.currentBookId = bookId;
                        this.bookStorage.setLastBookId(bookId);
                    } catch (e) {
                        console.warn('Êó†Ê≥ï‰øùÂ≠ò‰π¶Á±çÂà∞Â≠òÂÇ®:', e);
                    }
                    
                    // ÈáçÁΩÆÈòÖËØªÊó∂Èó¥ÂíåÊªöÂä®‰ΩçÁΩÆÔºàÊñ∞Êñá‰ª∂Ôºâ
                    this.pendingScrollPosition = null;
                    this.totalReadingTime = 0;
                    
                    // Áõ¥Êé•‰ΩøÁî®Â∑≤Âä†ËΩΩÁöÑ PDF ÊñáÊ°£Ê∏≤Êüì
                    await this.renderPDFFromDocument(pdf, file.name, false);
                } catch (error) {
                    console.error('Âä†ËΩΩ PDF Â§±Ë¥•:', error);
                    alert('Âä†ËΩΩ PDF Êñá‰ª∂Â§±Ë¥•ÔºåËØ∑Á°Æ‰øùÊñá‰ª∂Ê†ºÂºèÊ≠£Á°Æ„ÄÇ');
                    this.showLoading(false);
                }
            }

            async loadPDFFromArrayBuffer(arrayBuffer, fileName, isReload = false) {
                this.showLoading(true);
                try {
                    // ËÆæÁΩÆ PDF.js worker
                    pdfjsLib.GlobalWorkerOptions.workerSrc = CONFIG.URLS.PDF_WORKER;
                    
                    // Â§çÂà∂ ArrayBufferÔºàÈò≤Ê≠¢Ë¢´ detachÔºâ
                    const bufferCopy = arrayBuffer.slice(0);
                    
                    // Âä†ËΩΩ PDF ÊñáÊ°£
                    const pdf = await pdfjsLib.getDocument({ data: bufferCopy }).promise;
                    
                    await this.renderPDFFromDocument(pdf, fileName, isReload);
                } catch (error) {
                    console.error('Âä†ËΩΩ PDF Â§±Ë¥•:', error);
                    alert('Âä†ËΩΩ PDF Êñá‰ª∂Â§±Ë¥•ÔºåËØ∑Á°Æ‰øùÊñá‰ª∂Ê†ºÂºèÊ≠£Á°Æ„ÄÇ');
                    this.showLoading(false);
                }
            }

            // ‰ªéÂ∑≤Âä†ËΩΩÁöÑ PDF ÊñáÊ°£Ê∏≤ÊüìÂÜÖÂÆπ
            async renderPDFFromDocument(pdf, fileName, isReload = false) {
                try {
                    this.pdfDoc = pdf;
                    const numPages = this.pdfDoc.numPages;
                    
                    // Ëé∑ÂèñÂÖÉÊï∞ÊçÆ
                    const pdfMetadata = await this.pdfDoc.getMetadata().catch(() => ({}));
                    this.metadata = {
                        title: pdfMetadata.info?.Title || fileName.replace(/\.pdf$/i, ''),
                        creator: pdfMetadata.info?.Author || '',
                        language: ''
                    };
                    
                    // Ê∏ÖÁ©∫ÁõÆÂΩïÔºàPDF ÁõÆÂΩïÁ®çÂêéÂ§ÑÁêÜÔºâ
                    this.toc = [];
                    this.chapterElements = [];
                    
                    // Ê∏≤ÊüìÊâÄÊúâÈ°µÈù¢ÁöÑÊñáÊú¨ÂÜÖÂÆπ
                    const readerContent = document.getElementById('reader-content');
                    readerContent.innerHTML = '';
                    
                    for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                        const page = await this.pdfDoc.getPage(pageNum);
                        const textContent = await page.getTextContent();
                        
                        // ÂàõÂª∫Á´†ËäÇÂÆπÂô®
                        const chapterDiv = document.createElement('div');
                        chapterDiv.className = 'chapter';
                        chapterDiv.id = `pdf-page-${pageNum}`;
                        
                        // Ê∑ªÂä†È°µÁ†ÅÊ†áÈ¢ò
                        const pageHeader = document.createElement('div');
                        pageHeader.className = 'pdf-page-header';
                        pageHeader.style.cssText = 'text-align: center; color: #999; font-size: 12px; margin-bottom: 20px; padding-top: 20px; border-top: 1px solid #eee;';
                        pageHeader.textContent = `Á¨¨ ${pageNum} È°µ`;
                        if (pageNum > 1) {
                            chapterDiv.appendChild(pageHeader);
                        }
                        
                        // Â§ÑÁêÜÊñáÊú¨ÂÜÖÂÆπ - Êô∫ËÉΩÊÆµËêΩÊ£ÄÊµã
                        let currentParagraph = document.createElement('p');
                        let paragraphText = '';
                        
                        // È¶ñÂÖàÊî∂ÈõÜÊâÄÊúâÊñáÊú¨È°πÂπ∂ËÆ°ÁÆóÂÖ∏ÂûãË°åÈ´ò
                        const textItems = textContent.items.filter(item => item.str.trim() !== '');
                        
                        // ËÆ°ÁÆóË°åÈ´òÔºöÂàÜÊûêËøûÁª≠Ë°å‰πãÈó¥ÁöÑ Y ÂùêÊ†áÂ∑ÆÂÄº
                        const lineGaps = [];
                        for (let i = 1; i < textItems.length; i++) {
                            const gap = Math.abs(textItems[i].transform[5] - textItems[i-1].transform[5]);
                            if (gap > 0 && gap < 100) { // ÂøΩÁï•Âêå‰∏ÄË°åÁöÑÈ°πÁõÆÂíåËøáÂ§ßÁöÑË∑≥Ë∑É
                                lineGaps.push(gap);
                            }
                        }
                        
                        // ‰ΩøÁî®‰∏≠‰ΩçÊï∞ÊàñÂπ≥ÂùáÂÄº‰Ωú‰∏∫ÂÖ∏ÂûãË°åÈ´ò
                        let typicalLineHeight = 14; // ÈªòËÆ§ÂÄº
                        if (lineGaps.length > 0) {
                            lineGaps.sort((a, b) => a - b);
                            // Âèñ‰∏≠‰ΩçÊï∞ÈôÑËøëÁöÑÂÄº‰Ωú‰∏∫ÂÖ∏ÂûãË°åÈ´ò
                            const midIndex = Math.floor(lineGaps.length / 2);
                            typicalLineHeight = lineGaps[midIndex];
                        }
                        
                        // ÊÆµËêΩÈó¥Ë∑ùÈòàÂÄºÔºöÂÖ∏ÂûãË°åÈ´òÁöÑ 1.8 ÂÄç
                        const paragraphThreshold = typicalLineHeight * 1.8;
                        
                        let lastY = null;
                        let lastX = null;
                        
                        for (const item of textItems) {
                            const currentY = item.transform[5];
                            const currentX = item.transform[4];
                            
                            // Ê£ÄÊµãÊòØÂê¶ÈúÄË¶ÅÊç¢ÊÆµËêΩ
                            let shouldBreak = false;
                            
                            if (lastY !== null) {
                                const yGap = Math.abs(currentY - lastY);
                                
                                // Êù°‰ª∂1ÔºöY ÂùêÊ†áÂ∑ÆÂÄºË∂ÖËøáÊÆµËêΩÈòàÂÄº
                                if (yGap > paragraphThreshold) {
                                    shouldBreak = true;
                                }
                                
                                // Êù°‰ª∂2ÔºöÊñ∞Ë°å‰∏î X ÂùêÊ†áÊúâÊòéÊòæÁº©ËøõÔºàÂèØËÉΩÊòØÊñ∞ÊÆµËêΩÔºâ
                                // ÂêåÊó∂ Y ÂùêÊ†áÂèòÂåñË∂ÖËøáÊôÆÈÄöË°åÈ´ò
                                if (yGap > typicalLineHeight * 0.8 && lastX !== null) {
                                    const xDiff = currentX - lastX;
                                    // Â¶ÇÊûúÊñ∞Ë°åÊúâÊòéÊòæÁº©ËøõÔºàË∂ÖËøá20ÂÉèÁ¥†ÔºâÔºåÂèØËÉΩÊòØÊñ∞ÊÆµËêΩ
                                    if (xDiff > 20) {
                                        shouldBreak = true;
                                    }
                                }
                            }
                            
                            if (shouldBreak && paragraphText.trim()) {
                                currentParagraph.textContent = paragraphText.trim();
                                chapterDiv.appendChild(currentParagraph);
                                currentParagraph = document.createElement('p');
                                paragraphText = '';
                            }
                            
                            // Â¶ÇÊûúÊòØÂêå‰∏ÄË°åÂÜÖÁöÑÊñáÊú¨ÔºåÁõ¥Êé•ËøûÊé•
                            // Â¶ÇÊûúÊòØÊç¢Ë°åÔºåÊ∑ªÂä†Á©∫Ê†ºËøûÊé•ÔºàÈÅøÂÖçÂçïËØçÁ≤òËøûÔºâ
                            if (lastY !== null && Math.abs(currentY - lastY) > 2) {
                                // Êç¢Ë°å‰∫ÜÔºåÁ°Æ‰øùÊúâÁ©∫Ê†º
                                if (paragraphText && !paragraphText.endsWith(' ') && !paragraphText.endsWith('-')) {
                                    paragraphText += ' ';
                                }
                            }
                            
                            paragraphText += item.str;
                            lastY = currentY;
                            lastX = currentX;
                        }
                        
                        // Ê∑ªÂä†ÊúÄÂêé‰∏Ä‰∏™ÊÆµËêΩ
                        if (paragraphText.trim()) {
                            currentParagraph.textContent = paragraphText.trim();
                            chapterDiv.appendChild(currentParagraph);
                        }
                        
                        readerContent.appendChild(chapterDiv);
                        
                        // Ê∑ªÂä†Âà∞Á´†ËäÇÂÖÉÁ¥†Êï∞ÁªÑÁî®‰∫éÁõÆÂΩïÂØºËà™
                        this.chapterElements.push({
                            element: chapterDiv,
                            href: `pdf-page-${pageNum}`
                        });
                        
                        // ‰∏∫ PDF ÁîüÊàêÁÆÄÂçïÁõÆÂΩïÔºàÊØèÈ°µ‰∏Ä‰∏™Êù°ÁõÆÔºâ
                        this.toc.push({
                            label: `Á¨¨ ${pageNum} È°µ`,
                            href: `pdf-page-${pageNum}`,
                            level: 1
                        });
                    }
                    
                    // Â∞ùËØïËé∑Âèñ PDF Â§ßÁ∫≤Ôºà‰π¶Á≠æÔºâ
                    try {
                        const outline = await this.pdfDoc.getOutline();
                        if (outline && outline.length > 0) {
                            this.toc = [];
                            await this.parsePDFOutline(outline, 1);
                        }
                    } catch (e) {
                        console.warn('Êó†Ê≥ïËé∑Âèñ PDF Â§ßÁ∫≤:', e);
                    }
                    
                    this.renderTOC();
                    
                    document.getElementById('book-title').textContent = this.metadata.title || fileName;
                    document.getElementById('welcome-screen').style.display = 'none';
                    document.getElementById('reader-content').style.display = 'block';
                    document.getElementById('progress-indicator').style.display = 'flex';
                    document.getElementById('time-indicator').classList.add('active');
                    
                    // ËÆ°ÁÆóÊÄªÂçïËØçÊï∞
                    this.totalCharacters = this.countWords(readerContent.textContent);
                    
                    // ÊòæÁ§∫ÊÄªÂ≠óÊï∞
                    this.updateWordCountDisplay();
                    
                    // ÂºÄÂßãÈòÖËØªÈÄüÂ∫¶Ë∑üË∏™
                    this.startSpeedTracking();
                    
                    // ÂàùÂßãÂåñÊáíÂä†ËΩΩËØçÊ±áÊ†áÊ≥®
                    this.initAnnotationObserver();
                    
                    // ÂºÄÂßãÈòÖËØªÊó∂Èó¥Ë∑üË∏™
                    this.startReadingTime();
                    this.updateTimeDisplay();
                    
                    // ÊÅ¢Â§çÈòÖËØª‰ΩçÁΩÆ
                    if (this.pendingScrollPosition !== null) {
                        const container = document.getElementById('reader-container');
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                container.scrollTop = this.pendingScrollPosition;
                                this.pendingScrollPosition = null;
                                this.updateProgress();
                                this.updateActiveTocItem();
                            });
                        });
                    } else {
                        this.updateProgress();
                    }
                } catch (error) {
                    console.error('Ê∏≤Êüì PDF Â§±Ë¥•:', error);
                    alert('Ê∏≤Êüì PDF Êñá‰ª∂Â§±Ë¥•„ÄÇ');
                } finally {
                    this.showLoading(false);
                }
            }

            // Ëß£Êûê PDF Â§ßÁ∫≤Ôºà‰π¶Á≠æÔºâ
            async parsePDFOutline(outline, level) {
                for (const item of outline) {
                    let pageNum = 1;
                    try {
                        if (item.dest) {
                            let dest = item.dest;
                            if (typeof dest === 'string') {
                                dest = await this.pdfDoc.getDestination(dest);
                            }
                            if (dest && dest[0]) {
                                const pageIndex = await this.pdfDoc.getPageIndex(dest[0]);
                                pageNum = pageIndex + 1;
                            }
                        }
                    } catch (e) {
                        console.warn('Êó†Ê≥ïËß£Êûê‰π¶Á≠æÁõÆÊ†á:', e);
                    }
                    
                    this.toc.push({
                        label: item.title,
                        href: `pdf-page-${pageNum}`,
                        level: level
                    });
                    
                    if (item.items && item.items.length > 0) {
                        await this.parsePDFOutline(item.items, level + 1);
                    }
                }
            }

            parseMetadata(opfDoc) {
                const metadata = opfDoc.querySelector('metadata');
                this.metadata = {
                    title: metadata.querySelector('title')?.textContent || '',
                    creator: metadata.querySelector('creator')?.textContent || '',
                    language: metadata.querySelector('language')?.textContent || ''
                };
            }

            parseManifest(opfDoc) {
                this.manifest = {};
                opfDoc.querySelectorAll('manifest item').forEach(item => {
                    this.manifest[item.getAttribute('id')] = {
                        href: item.getAttribute('href'),
                        mediaType: item.getAttribute('media-type'),
                        properties: item.getAttribute('properties') || ''
                    };
                });
            }

            parseSpine(opfDoc) {
                this.spine = [];
                opfDoc.querySelectorAll('spine itemref').forEach(itemref => {
                    const idref = itemref.getAttribute('idref');
                    if (this.manifest[idref]) {
                        this.spine.push(this.manifest[idref].href);
                    }
                });
            }

            async parseTOC(opfDoc) {
                this.toc = [];
                
                // È¶ñÂÖàÂ∞ùËØï EPUB3 ÁöÑ nav ÊñáÊ°£
                const navItem = Object.values(this.manifest).find(item => 
                    item.properties.includes('nav')
                );
                
                if (navItem) {
                    await this.parseNavTOC(navItem.href);
                } else {
                    // ÂõûÈÄÄÂà∞ NCX
                    const ncxItem = Object.values(this.manifest).find(item =>
                        item.mediaType === 'application/x-dtbncx+xml'
                    );
                    if (ncxItem) {
                        await this.parseNCXTOC(ncxItem.href);
                    }
                }
            }

            async parseNavTOC(navHref) {
                const navPath = this.opfDir + navHref;
                const navContent = await this.zip.file(navPath).async('text');
                const navDoc = new DOMParser().parseFromString(navContent, 'application/xhtml+xml');
                
                const tocNav = navDoc.querySelector('nav[epub\\:type="toc"], nav[*|type="toc"], nav');
                if (tocNav) {
                    this.extractNavItems(tocNav.querySelector('ol'), 1);
                }
            }

            extractNavItems(ol, level) {
                if (!ol) return;
                ol.querySelectorAll(':scope > li').forEach(li => {
                    const a = li.querySelector(':scope > a');
                    if (a) {
                        this.toc.push({
                            title: a.textContent.trim(),
                            href: a.getAttribute('href'),
                            level: level
                        });
                    }
                    const subOl = li.querySelector(':scope > ol');
                    if (subOl) {
                        this.extractNavItems(subOl, level + 1);
                    }
                });
            }

            async parseNCXTOC(ncxHref) {
                const ncxPath = this.opfDir + ncxHref;
                const ncxContent = await this.zip.file(ncxPath).async('text');
                const ncxDoc = new DOMParser().parseFromString(ncxContent, 'application/xml');
                
                this.extractNCXNavPoints(ncxDoc.querySelector('navMap'), 1);
            }

            extractNCXNavPoints(parent, level) {
                if (!parent) return;
                parent.querySelectorAll(':scope > navPoint').forEach(navPoint => {
                    const label = navPoint.querySelector('navLabel text')?.textContent?.trim();
                    const src = navPoint.querySelector('content')?.getAttribute('src');
                    if (label && src) {
                        this.toc.push({
                            title: label,
                            href: src,
                            level: level
                        });
                    }
                    this.extractNCXNavPoints(navPoint, level + 1);
                });
            }

            async renderBook() {
                const readerContent = document.getElementById('reader-content');
                readerContent.innerHTML = '';
                this.chapterElements = [];

                for (let i = 0; i < this.spine.length; i++) {
                    const href = this.spine[i];
                    const chapterPath = this.opfDir + href;
                    
                    try {
                        let content = await this.zip.file(chapterPath).async('text');
                        const chapterDoc = new DOMParser().parseFromString(content, 'application/xhtml+xml');
                        
                        // Â§ÑÁêÜÂõæÁâá
                        await this.processImages(chapterDoc, chapterPath);
                        
                        // ÂàõÂª∫Á´†ËäÇÂÆπÂô®
                        const section = document.createElement('section');
                        section.className = 'chapter-section';
                        section.id = `chapter-${i}`;
                        section.dataset.href = href;
                        
                        // ÊèêÂèñ body ÂÜÖÂÆπ
                        const body = chapterDoc.querySelector('body');
                        if (body) {
                            section.innerHTML = body.innerHTML;
                        }
                        
                        // ‰∏∫ÊâÄÊúâÂ∏¶ id ÁöÑÂÖÉÁ¥†Ê∑ªÂä†ÂîØ‰∏ÄÂâçÁºÄ
                        section.querySelectorAll('[id]').forEach(el => {
                            el.id = `ch${i}-${el.id}`;
                        });
                        
                        readerContent.appendChild(section);
                        this.chapterElements.push({
                            element: section,
                            href: href
                        });
                    } catch (e) {
                        console.warn(`Êó†Ê≥ïÂä†ËΩΩÁ´†ËäÇ: ${href}`, e);
                    }
                }
            }

            async processImages(doc, chapterPath) {
                const chapterDir = chapterPath.substring(0, chapterPath.lastIndexOf('/') + 1);
                const images = doc.querySelectorAll('img, image');
                
                for (const img of images) {
                    const src = img.getAttribute('src') || img.getAttribute('xlink:href');
                    if (!src) continue;
                    
                    let imagePath = src;
                    if (!src.startsWith('/')) {
                        imagePath = this.resolvePath(chapterDir, src);
                    } else {
                        imagePath = src.substring(1);
                    }
                    
                    try {
                        const imageFile = this.zip.file(imagePath);
                        if (imageFile) {
                            const imageData = await imageFile.async('base64');
                            const mimeType = this.getMimeType(imagePath);
                            const dataUrl = `data:${mimeType};base64,${imageData}`;
                            
                            if (img.tagName.toLowerCase() === 'image') {
                                img.setAttribute('xlink:href', dataUrl);
                            } else {
                                img.setAttribute('src', dataUrl);
                            }
                        }
                    } catch (e) {
                        console.warn(`Êó†Ê≥ïÂä†ËΩΩÂõæÁâá: ${imagePath}`, e);
                    }
                }
            }

            resolvePath(basePath, relativePath) {
                const baseDir = basePath.substring(0, basePath.lastIndexOf('/') + 1);
                const parts = (baseDir + relativePath).split('/');
                const resolved = [];
                
                for (const part of parts) {
                    if (part === '..') {
                        resolved.pop();
                    } else if (part !== '.' && part !== '') {
                        resolved.push(part);
                    }
                }
                
                return resolved.join('/');
            }

            getMimeType(path) {
                const ext = path.split('.').pop().toLowerCase();
                const mimeTypes = {
                    'jpg': 'image/jpeg',
                    'jpeg': 'image/jpeg',
                    'png': 'image/png',
                    'gif': 'image/gif',
                    'svg': 'image/svg+xml',
                    'webp': 'image/webp'
                };
                return mimeTypes[ext] || 'image/jpeg';
            }

            renderTOC() {
                const tocContainer = document.getElementById('toc');
                tocContainer.innerHTML = '';

                if (this.toc.length === 0) {
                    // Â¶ÇÊûúÊ≤°ÊúâÁõÆÂΩïÔºå‰ΩøÁî® spine È°∫Â∫è‰Ωú‰∏∫ÁõÆÂΩï
                    this.spine.forEach((href, index) => {
                        const item = document.createElement('div');
                        item.className = 'toc-item level-1';
                        item.textContent = `Á´†ËäÇ ${index + 1}`;
                        item.dataset.href = href;
                        item.addEventListener('click', () => this.navigateTo(href));
                        tocContainer.appendChild(item);
                    });
                } else {
                    this.toc.forEach((item, index) => {
                        const tocItem = document.createElement('div');
                        tocItem.className = `toc-item level-${Math.min(item.level, 3)}`;
                        tocItem.textContent = item.title;
                        tocItem.dataset.href = item.href;
                        tocItem.dataset.index = index;
                        tocItem.addEventListener('click', () => this.navigateTo(item.href));
                        tocContainer.appendChild(tocItem);
                    });
                }
            }

            navigateTo(href) {
                // ÂàÜÁ¶ªÊñá‰ª∂Ë∑ØÂæÑÂíåÈîöÁÇπ
                const [filePath, anchor] = href.split('#');
                
                // Êü•ÊâæÂØπÂ∫îÁöÑÁ´†ËäÇ
                for (let i = 0; i < this.chapterElements.length; i++) {
                    const chapter = this.chapterElements[i];
                    if (chapter.href === filePath || chapter.href.endsWith(filePath)) {
                        let targetElement = chapter.element;
                        
                        // Â¶ÇÊûúÊúâÈîöÁÇπÔºåÂ∞ùËØïÊâæÂà∞ÂØπÂ∫îÂÖÉÁ¥†
                        if (anchor) {
                            const anchorEl = document.getElementById(`ch${i}-${anchor}`);
                            if (anchorEl) {
                                targetElement = anchorEl;
                            }
                        }
                        
                        targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        this.highlightTocItem(href);
                        break;
                    }
                }
            }

            highlightTocItem(href) {
                document.querySelectorAll('.toc-item').forEach(item => {
                    item.classList.remove('active');
                    if (item.dataset.href === href || href.includes(item.dataset.href)) {
                        item.classList.add('active');
                    }
                });
            }

            updateActiveTocItem() {
                const container = document.getElementById('reader-container');
                const scrollTop = container.scrollTop;
                
                let activeChapter = null;
                for (const chapter of this.chapterElements) {
                    if (chapter.element.offsetTop <= scrollTop + 100) {
                        activeChapter = chapter;
                    } else {
                        break;
                    }
                }
                
                if (activeChapter) {
                    this.highlightTocItem(activeChapter.href);
                }
            }
        }

        // ÂàùÂßãÂåñÈòÖËØªÂô®
        const reader = new EPUBReader();
    </script>
</body>
</html>
