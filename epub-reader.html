<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç”µå­ä¹¦é˜…è¯»å™¨</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://unpkg.com/compromise@14.14.5/builds/compromise.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // é…ç½® PDF.js worker - å¿…é¡»åœ¨ä½¿ç”¨å‰è®¾ç½®
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }
    </script>
    <style>
        /* CSS å˜é‡ - ç»Ÿä¸€ç®¡ç†é¢œè‰²å’Œå°ºå¯¸ */
        :root {
            --primary-color: #3498db;
            --primary-hover: #2980b9;
            --success-color: #27ae60;
            --success-hover: #219a52;
            --danger-color: #e74c3c;
            --danger-hover: #c0392b;
            --purple-color: #9b59b6;
            --purple-hover: #8e44ad;
            --gray-color: #607d8b;
            --gray-hover: #546e7a;
            --teal-color: #16a085;
            --teal-hover: #138d75;
            
            --sidebar-bg: #2c3e50;
            --sidebar-header-bg: #1a252f;
            --sidebar-border: #34495e;
            --text-primary: #2c3e50;
            --text-secondary: #7f8c8d;
            --text-muted: #95a5a6;
            --border-color: #ecf0f1;
            --bg-light: #f5f5f5;
            --bg-lighter: #f8f9fa;
            
            --font-system: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 12px;
            --radius-pill: 20px;
            --transition-fast: 0.2s;
            --transition-normal: 0.3s;
            --shadow-sm: 0 2px 10px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 20px rgba(0,0,0,0.08);
            --shadow-lg: 0 10px 40px rgba(0,0,0,0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-system);
            background: var(--bg-light);
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        /* é€šç”¨æŒ‰é’®æ ·å¼ */
        .btn {
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 14px;
            transition: background var(--transition-fast);
        }
        
        .btn-primary { background: var(--primary-color); }
        .btn-primary:hover { background: var(--primary-hover); }
        .btn-success { background: var(--success-color); }
        .btn-success:hover { background: var(--success-hover); }
        .btn-danger { background: var(--danger-color); }
        .btn-danger:hover { background: var(--danger-hover); }
        .btn-purple { background: var(--purple-color); }
        .btn-purple:hover { background: var(--purple-hover); }
        .btn-gray { background: var(--gray-color); }
        .btn-gray:hover { background: var(--gray-hover); }
        .btn-teal { background: var(--teal-color); }
        .btn-teal:hover { background: var(--teal-hover); }

        /* é€šç”¨æŒ‡ç¤ºå™¨æ ·å¼ */
        .indicator {
            display: none;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            border-radius: var(--radius-pill);
            font-size: 13px;
        }
        .indicator.active { display: flex; }
        .indicator .icon { font-size: 14px; }
        .indicator .value { font-weight: 600; }
        .indicator .unit { font-size: 11px; }

        /* ç»Ÿè®¡æŒ‡ç¤ºå™¨å®¹å™¨ */
        .stats-group {
            display: flex;
            align-items: center;
            gap: 8px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 6px 10px;
            border-radius: 12px;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.06);
        }

        /* ç»Ÿä¸€çš„ç»Ÿè®¡æŒ‡ç¤ºå™¨æ ·å¼ */
        .time-indicator,
        .speed-indicator,
        .read-count-indicator,
        .word-count-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 1px solid rgba(255,255,255,0.8);
            backdrop-filter: blur(4px);
        }

        .time-indicator:hover,
        .speed-indicator:hover,
        .read-count-indicator:hover,
        .word-count-indicator:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
        }

        /* å›¾æ ‡æ ·å¼ */
        .time-icon, .speed-icon, .read-count-icon, .word-count-icon {
            font-size: 15px;
            filter: drop-shadow(0 1px 1px rgba(0,0,0,0.1));
        }

        /* æ•°å€¼æ ·å¼ */
        .time-value, .speed-value, .read-count-value, .word-count-value {
            font-weight: 700;
            font-size: 14px;
            letter-spacing: -0.3px;
        }

        /* å•ä½æ ·å¼ */
        .speed-unit, .read-count-unit, .word-count-unit {
            font-size: 11px;
            opacity: 0.75;
            font-weight: 500;
        }

        /* ä¾§è¾¹æ æ ·å¼ */
        .sidebar {
            width: 280px;
            min-width: 280px;
            background: var(--sidebar-bg);
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            transition: transform var(--transition-normal) ease;
            z-index: 100;
        }

        .sidebar.collapsed {
            transform: translateX(-280px);
            margin-left: -280px;
        }

        .sidebar-header {
            padding: 20px;
            background: var(--sidebar-header-bg);
            border-bottom: 1px solid var(--sidebar-border);
        }

        .sidebar-header h2 {
            font-size: 16px;
            font-weight: 500;
            color: #bdc3c7;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .toc-container {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
        }

        .toc-item {
            padding: 12px 20px;
            cursor: pointer;
            transition: background var(--transition-fast), border-left var(--transition-fast);
            border-left: 3px solid transparent;
            font-size: 14px;
            line-height: 1.5;
        }

        .toc-item:hover { background: var(--sidebar-border); }
        .toc-item.active {
            background: var(--primary-color);
            border-left-color: var(--danger-color);
        }

        .toc-item.level-1 { padding-left: 20px; }
        .toc-item.level-2 { padding-left: 35px; font-size: 13px; }
        .toc-item.level-3 { padding-left: 50px; font-size: 12px; }

        /* ä¸»å†…å®¹åŒº */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        /* é¡¶éƒ¨å·¥å…·æ  */
        .toolbar {
            background: white;
            padding: 15px 25px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: var(--shadow-sm);
            z-index: 10;
        }

        .toggle-sidebar {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 14px;
            transition: background var(--transition-fast);
        }
        .toggle-sidebar:hover { background: var(--primary-hover); }

        .book-title {
            flex: 1;
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .upload-btn {
            background: var(--success-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 14px;
            transition: background var(--transition-fast);
        }
        .upload-btn:hover { background: var(--success-hover); }

        #file-input { display: none; }

        /* è®¾ç½®æŒ‰é’® */
        .settings-btn {
            background: var(--purple-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 14px;
            transition: background var(--transition-fast);
        }
        .settings-btn:hover { background: var(--purple-hover); }

        /* è®¾ç½®é¢æ¿ */
        .settings-panel {
            position: fixed;
            top: 70px;
            right: 25px;
            background: white;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            padding: 25px;
            width: 320px;
            max-width: calc(100vw - 50px);
            max-height: calc(100vh - 90px);
            overflow-y: auto;
            z-index: 200;
            display: none;
        }
        .settings-panel.active { display: block; }

        .settings-panel h3 {
            font-size: 16px;
            color: var(--text-primary);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .setting-group {
            margin-bottom: 20px;
        }
        .setting-group:last-child { margin-bottom: 0; }

        .setting-label {
            display: block;
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            font-weight: 500;
        }

        .setting-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .setting-row input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--border-color);
            border-radius: 3px;
            outline: none;
        }

        .setting-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
            transition: background var(--transition-fast);
        }
        .setting-row input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--primary-hover);
        }
        
        /* Firefox å…¼å®¹æ€§ */
        .setting-row input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .setting-value {
            min-width: 50px;
            text-align: right;
            font-size: 14px;
            color: var(--text-primary);
            font-weight: 600;
        }

        .font-select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
            color: var(--text-primary);
            background: white;
            cursor: pointer;
            outline: none;
            transition: border-color var(--transition-fast);
        }
        .font-select:hover, .font-select:focus {
            border-color: var(--primary-color);
        }

        .settings-overlay {
            position: fixed;
            inset: 0;
            z-index: 150;
            display: none;
        }
        .settings-overlay.active { display: block; }

        /* é˜…è¯»è¿›åº¦ */
        .progress-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            background: var(--bg-lighter);
            border-radius: var(--radius-pill);
            font-size: 13px;
            color: #5a6c7d;
        }

        .progress-indicator .progress-text {
            font-weight: 600;
            color: var(--text-primary);
            min-width: 45px;
            text-align: center;
        }

        .progress-bar-container {
            width: 80px;
            height: 6px;
            background: #e0e5ea;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), #2ecc71);
            border-radius: 3px;
            transition: width 0.15s ease-out;
            width: 0%;
        }

        /* å„ç±»æŒ‡ç¤ºå™¨é¢œè‰²ä¸»é¢˜ */
        .time-indicator {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            color: #155724;
            border-color: rgba(40, 167, 69, 0.2);
        }
        .time-indicator .time-value { color: #28a745; }

        .speed-indicator {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeeba 100%);
            color: #856404;
            border-color: rgba(255, 193, 7, 0.3);
        }
        .speed-indicator .speed-value { color: #d39e00; }

        .read-count-indicator {
            background: linear-gradient(135deg, #e2d5f1 0%, #d4c4e8 100%);
            color: #5a3d7a;
            border-color: rgba(102, 51, 153, 0.2);
        }
        .read-count-indicator .read-count-value { color: #6f42c1; }

        .word-count-indicator {
            background: linear-gradient(135deg, #cce5ff 0%, #b8daff 100%);
            color: #004085;
            border-color: rgba(0, 123, 255, 0.2);
        }
        .word-count-indicator .word-count-value { color: #007bff; }

        /* ä¹¦æ¶æŒ‰é’® */
        .library-btn {
            background: var(--gray-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 14px;
            transition: background var(--transition-fast);
        }
        .library-btn:hover { background: var(--gray-hover); }

        /* é€šç”¨æ¨¡æ€æ¡†æ ·å¼ */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            border-radius: var(--radius-lg);
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 1px solid #eee;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 18px;
            color: var(--text-primary);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--text-muted);
            padding: 5px;
        }
        .modal-close:hover { color: var(--text-primary); }

        /* ä¹¦æ¶æ¨¡æ€æ¡† - å¤ç”¨é€šç”¨æ¨¡æ€æ¡†æ ·å¼ï¼Œå‚è§ .modal, .modal-content, .modal-header, .modal-close */

        /* é€šç”¨åˆ—è¡¨é¡¹æ ·å¼ */
        .list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 25px;
            border-bottom: 1px solid #f5f5f5;
            transition: background var(--transition-fast);
        }
        .list-item:hover { background: var(--bg-lighter); }

        .list-body {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
        }

        /* é€šç”¨å°æŒ‰é’® */
        .btn-sm {
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 12px;
            transition: background var(--transition-fast);
        }

        /* ä¹¦æ¶å†…å®¹ - å¤ç”¨ .list-body å’Œ .list-item æ ·å¼ */

        .book-info {
            flex: 1;
            min-width: 0;
        }

        .book-title {
            font-size: 15px;
            font-weight: 500;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 5px;
        }

        .file-type-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-weight: 600;
            margin-right: 8px;
            vertical-align: middle;
        }
        .file-type-badge.epub { background: #e8f5e9; color: #2e7d32; }
        .file-type-badge.pdf { background: #ffebee; color: #c62828; }

        .book-meta {
            display: flex;
            gap: 12px;
            font-size: 12px;
            color: var(--text-muted);
        }
        .book-progress { color: var(--primary-color); font-weight: 500; }
        .book-time { color: var(--success-color); }

        .book-actions {
            display: flex;
            gap: 8px;
            margin-left: 15px;
        }

        .book-open {
            background: var(--primary-color);
        }
        .book-open:hover { background: var(--primary-hover); }

        .book-delete {
            background: var(--danger-color);
        }
        .book-delete:hover { background: var(--danger-hover); }

        /* é€‰è¯æµ®åŠ¨æŒ‰é’® */
        .word-action-btn {
            position: fixed;
            background: var(--success-color);
            color: white;
            border: none;
            padding: 8px 14px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.4);
            z-index: 10000;
            display: none;
            transition: all var(--transition-fast);
            white-space: nowrap;
        }
        .word-action-btn:hover {
            background: var(--success-hover);
            transform: translateY(-1px);
        }
        .word-action-btn.remove {
            background: var(--danger-color);
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
        }
        .word-action-btn.remove:hover { background: var(--danger-hover); }

        /* å·²çŸ¥è¯æ±‡æŒ‰é’® */
        .vocab-btn {
            background: var(--teal-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 14px;
            transition: background var(--transition-fast);
        }
        .vocab-btn:hover { background: var(--teal-hover); }

        /* è¯æ±‡è¡¨æ¨¡æ€æ¡† - å¤ç”¨ .modal, .modal-content, .modal-header æ ·å¼ */
        .vocab-content { max-width: 700px; }

        .vocab-header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .vocab-search {
            padding: 8px 12px;
            border: 2px solid var(--border-color);
            border-radius: var(--radius-md);
            font-size: 14px;
            width: 200px;
            outline: none;
            transition: border-color var(--transition-fast);
        }
        .vocab-search:focus { border-color: var(--primary-color); }

        /* .vocab-close å¤ç”¨ .modal-close æ ·å¼ */

        .vocab-stats {
            padding: 12px 25px;
            background: var(--bg-lighter);
            border-bottom: 1px solid #eee;
            font-size: 13px;
            color: var(--text-secondary);
        }

        /* .vocab-list å¤ç”¨ .list-body æ ·å¼ */
        .vocab-word {
            padding: 12px 25px;
        }

        .vocab-word-text {
            font-size: 15px;
            color: var(--text-primary);
            font-weight: 500;
        }

        .vocab-word-meta {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .vocab-word-date {
            font-size: 12px;
            color: var(--text-muted);
        }

        .vocab-word-delete {
            background: var(--danger-color);
            opacity: 0;
            transition: opacity var(--transition-fast);
        }
        .vocab-word:hover .vocab-word-delete { opacity: 1; }
        .vocab-word-delete:hover { background: var(--danger-hover); }

        .vocab-empty {
            text-align: center;
            padding: 40px 25px;
            color: var(--text-muted);
            font-size: 14px;
        }

        .vocab-footer {
            padding: 15px 25px;
            border-top: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .vocab-export-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 13px;
        }
        .vocab-export-btn:hover { background: var(--primary-hover); }

        .vocab-clear-btn {
            background: var(--danger-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 13px;
        }
        .vocab-clear-btn:hover { background: var(--danger-hover); }

        /* é˜…è¯»åŒºåŸŸ */
        .reader-container {
            flex: 1;
            overflow-y: auto;
            padding: 40px;
            background: #f9f9f9;
        }

        .reader-content {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 60px 80px;
            border-radius: 8px;
            box-shadow: var(--shadow-md);
            line-height: 1.8;
            font-size: 17px;
            color: #333;
        }

        .reader-content h1, .reader-content h2, .reader-content h3 {
            margin-top: 1.5em;
            margin-bottom: 0.8em;
            color: var(--text-primary);
            line-height: 1.4;
        }

        .reader-content h1 { font-size: 2em; }
        .reader-content h2 { font-size: 1.6em; }
        .reader-content h3 { font-size: 1.3em; }

        .reader-content p {
            margin-bottom: 1.2em;
            text-align: justify;
        }

        .reader-content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
            border-radius: var(--radius-sm);
        }

        .reader-content a {
            color: var(--primary-color);
            text-decoration: none;
        }
        .reader-content a:hover { text-decoration: underline; }

        .chapter-section {
            margin-bottom: 60px;
            padding-bottom: 40px;
            border-bottom: 1px solid #eee;
        }
        .chapter-section:last-child { border-bottom: none; }

        /* æ¬¢è¿ç•Œé¢ */
        .welcome-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            color: var(--text-secondary);
        }

        .welcome-screen svg {
            width: 120px;
            height: 120px;
            margin-bottom: 30px;
            opacity: 0.6;
        }

        .welcome-screen h2 {
            font-size: 24px;
            color: #34495e;
            margin-bottom: 15px;
        }

        .welcome-screen p {
            font-size: 16px;
            margin-bottom: 30px;
        }

        .drop-zone {
            border: 3px dashed #bdc3c7;
            border-radius: var(--radius-lg);
            padding: 60px 80px;
            cursor: pointer;
            transition: all var(--transition-normal);
        }

        .drop-zone:hover, .drop-zone.drag-over {
            border-color: var(--primary-color);
            background: rgba(52, 152, 219, 0.05);
        }

        /* åŠ è½½åŠ¨ç”» */
        .loading {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(255,255,255,0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        .loading.active { display: flex; }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading p {
            margin-top: 20px;
            color: var(--text-secondary);
            font-size: 16px;
        }

        /* æ»šåŠ¨æ¡æ ·å¼ */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb {
            background: #c0c0c0;
            border-radius: var(--radius-sm);
        }
        ::-webkit-scrollbar-thumb:hover { background: #a0a0a0; }

        .toc-container::-webkit-scrollbar-track { background: var(--sidebar-bg); }
        .toc-container::-webkit-scrollbar-thumb { background: #4a6278; }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                bottom: 0;
            }
            .sidebar.collapsed {
                transform: translateX(-100%);
                margin-left: 0;
            }

            .toolbar { padding: 10px 15px; }
            .settings-panel { right: 10px; left: 10px; width: auto; }
            .book-title { display: none; }
            .progress-indicator { padding: 6px 10px; }
            .progress-bar-container { width: 50px; }

            /* ç»Ÿä¸€æŒ‡ç¤ºå™¨ç§»åŠ¨ç«¯æ ·å¼ */
            .indicator,
            .speed-indicator,
            .time-indicator,
            .word-count-indicator,
            .read-count-indicator {
                padding: 5px 10px;
                font-size: 11px;
                gap: 4px;
                border-radius: 8px;
            }
            
            .time-value, .speed-value, .read-count-value, .word-count-value {
                font-size: 12px;
            }
            
            .speed-unit, .read-count-unit, .word-count-unit {
                font-size: 10px;
            }
            
            .time-icon, .speed-icon, .read-count-icon, .word-count-icon {
                font-size: 13px;
            }
            
            .stats-group {
                padding: 4px 6px;
                gap: 6px;
                border-radius: 10px;
            }

            /* ç»Ÿä¸€æŒ‰é’®ç§»åŠ¨ç«¯æ ·å¼ */
            .library-btn,
            .vocab-btn {
                padding: 8px 10px;
                font-size: 12px;
            }

            /* æ¨¡æ€æ¡†ç§»åŠ¨ç«¯é€‚é… */
            .library-content,
            .vocab-content,
            .modal-content {
                width: 95%;
                max-height: 90vh;
            }

            .library-book {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .book-actions {
                margin-left: 0;
                width: 100%;
            }
            .book-actions button { flex: 1; }

            .vocab-header {
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }

            .vocab-header-actions { width: 100%; }
            .vocab-search { flex: 1; width: auto; }
            .vocab-word { padding: 10px 15px; }
            .vocab-word-delete { opacity: 1; }

            .vocab-footer {
                flex-direction: column;
                gap: 10px;
            }
            .vocab-footer button { width: 100%; }
        }

        /* è¯æ±‡æ ‡æ³¨æµ®çª—æ ·å¼ */
        /* è¯é¢‘ â‰¥ é˜ˆå€¼ - ä»…ç»¿è‰²ä¸‹åˆ’çº¿ï¼Œæ— èƒŒæ™¯ */
        .annotation-word {
            position: relative;
            border-bottom: 1px dashed #27ae60;
            cursor: help;
            color: inherit;
        }

        .annotation-word:hover {
            background-color: rgba(39, 174, 95, 0.025);
        }

        /* è¯é¢‘ < é˜ˆå€¼ - ç»¿è‰²ä¸‹åˆ’çº¿ + èƒŒæ™¯ */
        .annotation-word.low-freq {
            background-color: rgba(39, 174, 95, 0.065);
            border-radius: 2px;
            padding: 0 1px;
        }

        .annotation-word.low-freq:hover {
            background-color: rgba(39, 174, 96, 0.2);
        }

        .annotation-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #2c3e50;
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 14px;
            white-space: nowrap;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            pointer-events: none;
            margin-bottom: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .annotation-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #2c3e50;
        }

        .annotation-word:hover .annotation-tooltip {
            opacity: 1;
            visibility: visible;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="spinner"></div>
        <p>æ­£åœ¨åŠ è½½æ–‡ä»¶...</p>
    </div>

    <!-- é€‰è¯æµ®åŠ¨æŒ‰é’® -->
    <button class="word-action-btn" id="word-action-btn">+ åŠ å…¥è¯æ±‡è¡¨</button>

    <div class="container">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h2>ç›®å½•</h2>
            </div>
            <nav class="toc-container" id="toc">
                <div style="padding: 20px; color: #7f8c8d; text-align: center;">
                    è¯·å…ˆä¸Šä¼  EPUB æ–‡ä»¶
                </div>
            </nav>
        </aside>

        <main class="main-content">
            <div class="toolbar">
                <button class="toggle-sidebar" id="toggle-sidebar">â˜° ç›®å½•</button>
                <span class="book-title" id="book-title">ç”µå­ä¹¦é˜…è¯»å™¨</span>
                <div class="progress-indicator" id="progress-indicator" style="display: none;">
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="progress-bar"></div>
                    </div>
                    <span class="progress-text" id="progress-text">0%</span>
                </div>
                <div class="stats-group">
                    <div class="time-indicator" id="time-indicator">
                        <span class="time-icon">â±ï¸</span>
                        <span class="time-value" id="time-value">0åˆ†é’Ÿ</span>
                    </div>
                    <div class="speed-indicator" id="speed-indicator">
                        <span class="speed-icon">âš¡</span>
                        <span class="speed-value" id="speed-value">--</span>
                        <span class="speed-unit">è¯/åˆ†é’Ÿ</span>
                    </div>
                    <div class="read-count-indicator" id="read-count-indicator">
                        <span class="read-count-icon">ğŸ‘ï¸</span>
                        <span class="read-count-value" id="read-count-value">0</span>
                        <span class="read-count-unit">å·²è¯»</span>
                    </div>
                    <div class="word-count-indicator" id="word-count-indicator">
                        <span class="word-count-icon">ğŸ“</span>
                        <span class="word-count-value" id="word-count-value">0</span>
                        <span class="word-count-unit">æ€»è¯</span>
                    </div>
                </div>
                <button class="settings-btn" id="settings-btn">âš™ è®¾ç½®</button>
                <button class="library-btn" id="library-btn">ğŸ“š ä¹¦æ¶</button>
                <button class="vocab-btn" id="vocab-btn">ğŸ“– è¯æ±‡è¡¨</button>
                <label class="upload-btn" for="file-input">ğŸ“‚ æ‰“å¼€æ–‡ä»¶</label>
                <input type="file" id="file-input" accept=".epub,.pdf">
            </div>

            <div class="settings-overlay" id="settings-overlay"></div>
            <div class="settings-panel" id="settings-panel">
                <h3>é˜…è¯»è®¾ç½®</h3>
                
                <div class="setting-group">
                    <label class="setting-label">å­—ä½“</label>
                    <select class="font-select" id="font-family">
                        <option value="system">ç³»ç»Ÿé»˜è®¤</option>
                        <option value="serif">è¡¬çº¿ä½“ (Serif)</option>
                        <option value="sans-serif">æ— è¡¬çº¿ä½“ (Sans-serif)</option>
                        <option value="'Noto Serif SC', 'Source Han Serif SC', serif">æ€æºå®‹ä½“</option>
                        <option value="'Noto Sans SC', 'Source Han Sans SC', sans-serif">æ€æºé»‘ä½“</option>
                        <option value="'LXGW WenKai', cursive">éœé¹œæ–‡æ¥·</option>
                        <option value="Georgia, serif">Georgia</option>
                        <option value="'Palatino Linotype', serif">Palatino</option>
                        <option value="'Times New Roman', serif">Times New Roman</option>
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="Verdana, sans-serif">Verdana</option>
                    </select>
                </div>

                <div class="setting-group">
                    <label class="setting-label">å­—å·</label>
                    <div class="setting-row">
                        <input type="range" id="font-size" min="12" max="28" value="17" step="1">
                        <span class="setting-value" id="font-size-value">17px</span>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">è¡Œé«˜</label>
                    <div class="setting-row">
                        <input type="range" id="line-height" min="1.2" max="2.5" value="1.8" step="0.1">
                        <span class="setting-value" id="line-height-value">1.8</span>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">å†…å®¹å®½åº¦</label>
                    <div class="setting-row">
                        <input type="range" id="content-width" min="500" max="1200" value="800" step="50">
                        <span class="setting-value" id="content-width-value">800px</span>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">ä¾§è¾¹è·</label>
                    <div class="setting-row">
                        <input type="range" id="padding" min="20" max="120" value="80" step="10">
                        <span class="setting-value" id="padding-value">80px</span>
                    </div>
                </div>

                <div class="setting-group" style="border-top: 1px solid #eee; padding-top: 15px; margin-top: 15px;">
                    <label class="setting-label" style="display: flex; align-items: center; justify-content: space-between;">
                        <span>è¯æ±‡æ ‡æ³¨</span>
                        <input type="checkbox" id="annotation-toggle" checked style="width: 18px; height: 18px; cursor: pointer;">
                    </label>
                </div>

                <div class="setting-group" id="freq-range-group">
                    <label class="setting-label">COCAè¯é¢‘èŒƒå›´</label>
                    <div class="setting-row" style="gap: 8px;">
                        <input type="number" id="freq-min" value="10000" min="1" max="60000" style="width: 70px; padding: 6px 8px; border: 2px solid #ecf0f1; border-radius: 6px; font-size: 13px;">
                        <span style="color: #7f8c8d;">-</span>
                        <input type="number" id="freq-max" value="60000" min="1" max="60000" style="width: 70px; padding: 6px 8px; border: 2px solid #ecf0f1; border-radius: 6px; font-size: 13px;">
                    </div>
                    <div style="font-size: 11px; color: #95a5a6; margin-top: 6px;">æ•°å­—è¶Šå¤§è¡¨ç¤ºè¶Šç”Ÿåƒ»çš„è¯æ±‡</div>
                </div>
                <div class="setting-group" id="learning-threshold-group">
                    <label class="setting-label">å­¦ä¹ è¯é¢‘é˜ˆå€¼ <span style="color: #e74c3c;">â—</span></label>
                    <div class="setting-row" style="gap: 8px;">
                        <input type="number" id="learning-threshold" value="20000" min="1" max="60000" style="width: 100px; padding: 6px 8px; border: 2px solid #ecf0f1; border-radius: 6px; font-size: 13px;">
                    </div>
                    <div style="font-size: 11px; color: #95a5a6; margin-top: 6px;">è¯é¢‘ä½äºæ­¤é˜ˆå€¼çš„å•è¯æ˜¾ç¤ºçº¢è‰²ä¸‹åˆ’çº¿</div>
                </div>
                
                <div class="setting-group" style="border-top: 1px solid #eee; padding-top: 15px; margin-top: 15px;">
                    <label class="setting-label">ç¦»çº¿è¯å…¸ (ECDICT)</label>
                    <div style="font-size: 12px; color: #7f8c8d; margin-bottom: 8px;">
                        å½“ Google ç¿»è¯‘ API å¤±æ•ˆæ—¶è‡ªåŠ¨ä½¿ç”¨
                    </div>
                    <div id="dict-status" style="font-size: 11px; color: #27ae60; margin-top: 6px;"></div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px;">
                        <button id="reload-dict-btn" style="padding: 6px 12px; background: #3498db; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">é‡æ–°åŠ è½½</button>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px; margin-top: 12px;">
                        <label class="toggle-switch">
                            <input type="checkbox" id="offline-dict-priority">
                            <span class="toggle-slider"></span>
                        </label>
                        <span style="font-size: 13px; color: #34495e;">ç¦»çº¿è¯å…¸ä¼˜å…ˆ</span>
                    </div>
                    <div style="font-size: 11px; color: #95a5a6; margin-top: 6px;">å¼€å¯åä¼˜å…ˆä½¿ç”¨ç¦»çº¿è¯å…¸ç¿»è¯‘ï¼ŒæŸ¥ä¸åˆ°æ—¶å†ç”¨ Google ç¿»è¯‘</div>
                </div>
            </div>

            <div class="reader-container" id="reader-container">
                <div class="welcome-screen" id="welcome-screen">
                    <div class="drop-zone" id="drop-zone">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <path d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"/>
                        </svg>
                        <h2>ç”µå­ä¹¦é˜…è¯»å™¨</h2>
                        <p>æ‹–æ”¾ EPUB æˆ– PDF æ–‡ä»¶åˆ°æ­¤å¤„ï¼Œæˆ–ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®é€‰æ‹©æ–‡ä»¶</p>
                    </div>
                </div>
                <div class="reader-content" id="reader-content" style="display: none;"></div>
            </div>
        </main>
    </div>

    <script>
        // ==================== å¸¸é‡å®šä¹‰ ====================
        const CONFIG = {
            // æ•°æ®åº“é…ç½®
            DB_NAME: 'EPUBReaderDB',
            DB_VERSION: 5,
            STORES: {
                BOOKS: 'books',
                PROGRESS: 'progress',
                TRANSLATIONS: 'translations',
                KNOWN_WORDS: 'knownWords',
                OFFLINE_DICT: 'offlineDict'
            },
            
            // æ—¶é—´é—´éš”ï¼ˆæ¯«ç§’ï¼‰
            INTERVALS: {
                SAVE_PROGRESS: 60000,      // ä¿å­˜è¿›åº¦é—´éš”
                UPDATE_TIME_DISPLAY: 10000, // æ›´æ–°æ—¶é—´æ˜¾ç¤ºé—´éš”
                UPDATE_SPEED: 3000,         // æ›´æ–°é˜…è¯»é€Ÿåº¦é—´éš”
                CHECK_READ: 500,            // æ£€æŸ¥å·²è¯»æ®µè½é—´éš”
                SAVE_DEBOUNCE: 500          // ä¿å­˜è¿›åº¦é˜²æŠ–
            },
            
            // é˜…è¯»è¿½è¸ªé…ç½®
            READING: {
                SPEED_HISTORY_MINUTES: 5,   // ä¿ç•™é˜…è¯»é€Ÿåº¦å†å²æ—¶é•¿
                SPEED_CALC_MINUTES: 2,      // è®¡ç®—é€Ÿåº¦ä½¿ç”¨çš„æ—¶é—´èŒƒå›´
                MIN_SPEED_TIME: 0.25,       // æœ€å°è®¡ç®—æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
                MIN_WPM: 5,                 // æœ€å°åˆç†é˜…è¯»é€Ÿåº¦
                MAX_WPM: 2000,              // æœ€å¤§åˆç†é˜…è¯»é€Ÿåº¦
                WORDS_PER_SECOND: 5,        // å‡è®¾é˜…è¯»é€Ÿåº¦
                ANNOTATION_GAP: 10          // è¯æ±‡æ ‡æ³¨å»é‡æ®µè½é—´éš”
            },
            
            // COCA è¯é¢‘é…ç½®
            COCA: {
                DEFAULT_MIN: 10000,
                DEFAULT_MAX: 60000,
                DEFAULT_THRESHOLD: 20000
            },
            
            // é»˜è®¤é˜…è¯»è®¾ç½®
            DEFAULT_SETTINGS: {
                fontFamily: 'system',
                fontSize: 17,
                lineHeight: 1.8,
                contentWidth: 800,
                padding: 80
            },
            
            // å¤–éƒ¨èµ„æºURL
            URLS: {
                COCA: 'https://huiget.github.io/filtered_COCA60000.txt',
                DICT: [
                    'https://cdn.jsdelivr.net/gh/weirany/ecdict_json_import@master/words_bnc_only.json',
                    'https://raw.githubusercontent.com/weirany/ecdict_json_import/master/words_bnc_only.json'
                ],
                PDF_WORKER: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js'
            }
        };

        // ==================== å·¥å…·å‡½æ•° ====================
        const Utils = {
            // é˜²æŠ–å‡½æ•°
            debounce(fn, delay) {
                let timer = null;
                return function(...args) {
                    clearTimeout(timer);
                    timer = setTimeout(() => fn.apply(this, args), delay);
                };
            },
            
            // èŠ‚æµå‡½æ•°
            throttle(fn, limit) {
                let inThrottle = false;
                return function(...args) {
                    if (!inThrottle) {
                        fn.apply(this, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                };
            },
            
            // å®‰å…¨çš„ JSON è§£æ
            safeJsonParse(str, fallback = null) {
                try {
                    return JSON.parse(str);
                } catch {
                    return fallback;
                }
            },
            
            // æ ¼å¼åŒ–æ•°å­—ï¼ˆæ·»åŠ åƒä½åˆ†éš”ç¬¦ï¼‰
            formatNumber(num) {
                return num.toLocaleString();
            },
            
            // æ ¼å¼åŒ–æ—¶é—´
            formatReadingTime(ms) {
                const seconds = Math.floor(ms / 1000);
                const minutes = Math.floor(seconds / 60);
                const hours = Math.floor(minutes / 60);
                
                if (hours > 0) return `${hours}å°æ—¶${minutes % 60}åˆ†é’Ÿ`;
                if (minutes > 0) return `${minutes}åˆ†é’Ÿ`;
                return `${seconds}ç§’`;
            },
            
            // æ ¼å¼åŒ–æ—¥æœŸ
            formatDate(timestamp) {
                const date = new Date(timestamp);
                const now = new Date();
                const diffDays = Math.floor((now - date) / (1000 * 60 * 60 * 24));
                
                if (diffDays === 0) return 'ä»Šå¤©';
                if (diffDays === 1) return 'æ˜¨å¤©';
                if (diffDays < 7) return `${diffDays}å¤©å‰`;
                return date.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });
            },
            
            // è®¡ç®—å•è¯æ•°
            countWords(text) {
                if (!text) return 0;
                return text.trim().split(/\s+/).filter(w => w.length > 0).length;
            },
            
            // è·å– DOM å…ƒç´ ï¼ˆå¸¦ç¼“å­˜ï¼‰
            getElement: (() => {
                const cache = new Map();
                return (id) => {
                    if (!cache.has(id)) {
                        cache.set(id, document.getElementById(id));
                    }
                    return cache.get(id);
                };
            })(),
            
            // æ¸…é™¤å…ƒç´ ç¼“å­˜ï¼ˆç”¨äºåŠ¨æ€å†…å®¹ï¼‰
            clearElementCache() {
                this.getElement = (() => {
                    const cache = new Map();
                    return (id) => {
                        if (!cache.has(id)) {
                            cache.set(id, document.getElementById(id));
                        }
                        return cache.get(id);
                    };
                })();
            },
            
            // åˆ›å»º Promise åŒ…è£…çš„ IndexedDB è¯·æ±‚
            promisifyRequest(request) {
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            },
            
            // åˆ›å»º Promise åŒ…è£…çš„äº‹åŠ¡
            promisifyTransaction(transaction) {
                return new Promise((resolve, reject) => {
                    transaction.oncomplete = () => resolve();
                    transaction.onerror = () => reject(transaction.error);
                });
            }
        };

        // ==================== IndexedDB å·¥å…·ç±» ====================
        class BookStorage {
            constructor() {
                this.dbName = CONFIG.DB_NAME;
                this.stores = CONFIG.STORES;
                this.db = null;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, CONFIG.DB_VERSION);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve();
                    };
                    
                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        const { BOOKS, PROGRESS, TRANSLATIONS, KNOWN_WORDS, OFFLINE_DICT } = this.stores;
                        
                        // ä¹¦ç±å­˜å‚¨
                        if (!db.objectStoreNames.contains(BOOKS)) {
                            const bookStore = db.createObjectStore(BOOKS, { keyPath: 'id' });
                            bookStore.createIndex('lastOpenedAt', 'lastOpenedAt', { unique: false });
                        }
                        
                        // é˜…è¯»è¿›åº¦å­˜å‚¨
                        if (!db.objectStoreNames.contains(PROGRESS)) {
                            db.createObjectStore(PROGRESS, { keyPath: 'bookId' });
                        }
                        
                        // ç¿»è¯‘ç¼“å­˜å­˜å‚¨
                        if (!db.objectStoreNames.contains(TRANSLATIONS)) {
                            db.createObjectStore(TRANSLATIONS, { keyPath: 'word' });
                        }
                        
                        // å·²çŸ¥è¯æ±‡å­˜å‚¨ï¼ˆè·¨ä¹¦æœ¬ï¼‰
                        if (!db.objectStoreNames.contains(KNOWN_WORDS)) {
                            const knownWordsStore = db.createObjectStore(KNOWN_WORDS, { keyPath: 'lemma' });
                            knownWordsStore.createIndex('addedAt', 'addedAt', { unique: false });
                        }
                        
                        // ç¦»çº¿è¯å…¸å­˜å‚¨
                        if (!db.objectStoreNames.contains(OFFLINE_DICT)) {
                            db.createObjectStore(OFFLINE_DICT, { keyPath: 'id' });
                        }
                    };
                });
            }
            
            // é€šç”¨å­˜å‚¨æ“ä½œ - ç®€åŒ–é‡å¤ä»£ç 
            _getStore(storeName, mode = 'readonly') {
                const transaction = this.db.transaction([storeName], mode);
                return transaction.objectStore(storeName);
            }
            
            async _simpleGet(storeName, key) {
                const store = this._getStore(storeName);
                return Utils.promisifyRequest(store.get(key));
            }
            
            async _simplePut(storeName, data) {
                const store = this._getStore(storeName, 'readwrite');
                return Utils.promisifyRequest(store.put(data));
            }
            
            async _simpleDelete(storeName, key) {
                const store = this._getStore(storeName, 'readwrite');
                return Utils.promisifyRequest(store.delete(key));
            }
            
            async _simpleGetAll(storeName) {
                const store = this._getStore(storeName);
                return Utils.promisifyRequest(store.getAll());
            }

            // ä¿å­˜ç¦»çº¿è¯å…¸
            async saveOfflineDict(dictData) {
                return this._simplePut(this.stores.OFFLINE_DICT, {
                    id: 'ecdict',
                    data: dictData,
                    cachedAt: Date.now()
                });
            }
            
            // è·å–ç¦»çº¿è¯å…¸
            async getOfflineDict() {
                return this._simpleGet(this.stores.OFFLINE_DICT, 'ecdict');
            }

            // ç”Ÿæˆä¹¦ç±å”¯ä¸€æ ‡è¯†
            async generateBookId(arrayBuffer, fileName) {
                const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.slice(0, 8).map(b => b.toString(16).padStart(2, '0')).join('');
                return `${fileName}-${hashHex}`;
            }

            // ä¿å­˜ä¹¦ç±
            async saveBook(arrayBuffer, fileName, metadata = {}, fileType = 'epub') {
                const bookId = await this.generateBookId(arrayBuffer, fileName);
                const now = Date.now();
                
                await this._simplePut(this.stores.BOOKS, {
                    id: bookId,
                    data: arrayBuffer,
                    fileName,
                    title: metadata.title || fileName,
                    author: metadata.author || '',
                    fileType,
                    lastOpenedAt: now,
                    addedAt: now
                });
                
                return bookId;
            }

            // æ›´æ–°ä¹¦ç±çš„æœ€åæ‰“å¼€æ—¶é—´
            async updateLastOpened(bookId) {
                const book = await this._simpleGet(this.stores.BOOKS, bookId);
                if (book) {
                    book.lastOpenedAt = Date.now();
                    await this._simplePut(this.stores.BOOKS, book);
                }
            }

            // è·å–ä¹¦ç±
            async getBook(bookId) {
                return this._simpleGet(this.stores.BOOKS, bookId);
            }

            // è·å–æ‰€æœ‰ä¹¦ç±ï¼ˆæŒ‰æœ€åæ‰“å¼€æ—¶é—´æ’åºï¼‰
            async getAllBooks() {
                const books = await this._simpleGetAll(this.stores.BOOKS) || [];
                return books.sort((a, b) => (b.lastOpenedAt || 0) - (a.lastOpenedAt || 0));
            }

            // åˆ é™¤ä¹¦ç±
            async deleteBook(bookId) {
                const { BOOKS, PROGRESS } = this.stores;
                const transaction = this.db.transaction([BOOKS, PROGRESS], 'readwrite');
                transaction.objectStore(BOOKS).delete(bookId);
                transaction.objectStore(PROGRESS).delete(bookId);
                return Utils.promisifyTransaction(transaction);
            }

            // ä¿å­˜é˜…è¯»è¿›åº¦
            async saveProgress(bookId, progressData) {
                return this._simplePut(this.stores.PROGRESS, {
                    bookId,
                    scrollPosition: progressData.scrollPosition,
                    scrollPercentage: progressData.scrollPercentage,
                    totalReadingTime: progressData.totalReadingTime || 0,
                    lastReadAt: Date.now()
                });
            }

            // è·å–é˜…è¯»è¿›åº¦
            async getProgress(bookId) {
                return this._simpleGet(this.stores.PROGRESS, bookId);
            }

            // ä¿å­˜ç¿»è¯‘åˆ°ç¼“å­˜
            async saveTranslation(word, translation) {
                return this._simplePut(this.stores.TRANSLATIONS, { 
                    word, 
                    translation, 
                    cachedAt: Date.now() 
                });
            }

            // è·å–ç¼“å­˜çš„ç¿»è¯‘
            async getTranslation(word) {
                const result = await this._simpleGet(this.stores.TRANSLATIONS, word);
                return result?.translation || null;
            }

            // æ‰¹é‡è·å–ç¼“å­˜çš„ç¿»è¯‘
            async getAllTranslations() {
                return this._simpleGetAll(this.stores.TRANSLATIONS) || [];
            }

            // æ·»åŠ å·²çŸ¥è¯æ±‡
            async addKnownWord(lemma) {
                return this._simplePut(this.stores.KNOWN_WORDS, {
                    lemma: lemma.toLowerCase(),
                    addedAt: Date.now()
                });
            }

            // ç§»é™¤å·²çŸ¥è¯æ±‡
            async removeKnownWord(lemma) {
                return this._simpleDelete(this.stores.KNOWN_WORDS, lemma.toLowerCase());
            }

            // æ£€æŸ¥è¯æ±‡æ˜¯å¦å·²çŸ¥
            async isKnownWord(lemma) {
                const result = await this._simpleGet(this.stores.KNOWN_WORDS, lemma.toLowerCase());
                return !!result;
            }

            // è·å–æ‰€æœ‰å·²çŸ¥è¯æ±‡
            async getAllKnownWords() {
                const words = await this._simpleGetAll(this.stores.KNOWN_WORDS) || [];
                return words.sort((a, b) => (b.addedAt || 0) - (a.addedAt || 0));
            }

            // æ¸…ç©ºæ‰€æœ‰å·²çŸ¥è¯æ±‡
            async clearAllKnownWords() {
                const store = this._getStore(this.stores.KNOWN_WORDS, 'readwrite');
                return Utils.promisifyRequest(store.clear());
            }

            // è·å–æœ€è¿‘é˜…è¯»çš„ä¹¦ç±ID
            getLastBookId() {
                return localStorage.getItem('epubLastBookId');
            }

            // è®¾ç½®æœ€è¿‘é˜…è¯»çš„ä¹¦ç±ID
            setLastBookId(bookId) {
                localStorage.setItem('epubLastBookId', bookId);
            }
        }

        class EPUBReader {
            constructor() {
                // æ–‡ä»¶ç›¸å…³çŠ¶æ€
                this.zip = null;
                this.pdfDoc = null;
                this.opfPath = '';
                this.opfDir = '';
                this.manifest = {};
                this.spine = [];
                this.toc = [];
                this.metadata = {};
                this.chapterElements = [];
                this.currentFileName = '';
                this.currentBookId = null;
                this.currentFileType = 'epub';
                this.bookStorage = new BookStorage();
                this.pendingScrollPosition = null;
                
                // é˜…è¯»è¿½è¸ªçŠ¶æ€
                this.readingHistory = [];
                this.totalCharacters = 0;
                this.speedUpdateInterval = null;
                this.readObserver = null;
                this.readParagraphs = new Map();
                this.totalReadCharacters = 0;
                this.lastReadCountTime = Date.now();
                this.readingSpeedHistory = [];
                this.readCheckInterval = null;
                
                // æ—¶é—´è¿½è¸ªçŠ¶æ€
                this.totalReadingTime = 0;
                this.sessionStartTime = null;
                this.isPageVisible = true;
                this.readingTimeInterval = null;
                this.timeDisplayInterval = null;
                
                // ä½¿ç”¨å¸¸é‡é»˜è®¤è®¾ç½®
                this.settings = { ...CONFIG.DEFAULT_SETTINGS };
                
                // è¯æ±‡æ ‡æ³¨çŠ¶æ€
                this.annotationEnabled = true;
                this.freqMin = CONFIG.COCA.DEFAULT_MIN;
                this.freqMax = CONFIG.COCA.DEFAULT_MAX;
                this.learningThreshold = CONFIG.COCA.DEFAULT_THRESHOLD;
                this.cocaRanks = new Map();
                this.translationCache = new Map();
                this.cocaLoaded = false;
                this.annotationObserver = null;
                this.annotatedParagraphs = new Set();
                
                // è¯æ±‡è¡¨çŠ¶æ€
                this.knownWords = new Set();
                this.selectedWordInfo = null;
                
                // ç¦»çº¿è¯å…¸çŠ¶æ€
                this.offlineDict = new Map();
                this.offlineDictLoaded = false;
                this.offlineDictPriority = false;
                
                // åˆå§‹åŒ–
                this._init();
            }
            
            // åˆå§‹åŒ–æ–¹æ³• - åˆ†ç¦»æ„é€ å‡½æ•°é€»è¾‘
            _init() {
                this.loadSettings();
                this.loadAnnotationSettings();
                this.initEventListeners();
                this.initSettingsListeners();
                this.initVisibilityTracking();
                this.applySettings();
                this.initStorage();
            }

            // åˆå§‹åŒ–é¡µé¢å¯è§æ€§è·Ÿè¸ª
            initVisibilityTracking() {
                // é¡µé¢å¯è§æ€§å˜åŒ–
                document.addEventListener('visibilitychange', () => {
                    document.hidden ? this.pauseReadingTime() : this.resumeReadingTime();
                });
                
                // çª—å£ç„¦ç‚¹å˜åŒ–
                window.addEventListener('blur', () => this.pauseReadingTime());
                window.addEventListener('focus', () => this.resumeReadingTime());
                
                // é¡µé¢å¸è½½æ—¶ä¿å­˜å¹¶æ¸…ç†
                window.addEventListener('beforeunload', () => {
                    this.pauseReadingTime();
                    this.saveReadingProgress();
                    this.cleanup();
                });
            }

            // æ¸…é™¤å®šæ—¶å™¨çš„è¾…åŠ©æ–¹æ³•
            _clearIntervals(...intervals) {
                intervals.forEach(intervalName => {
                    if (this[intervalName]) {
                        clearInterval(this[intervalName]);
                        this[intervalName] = null;
                    }
                });
            }

            // å¼€å§‹è®¡æ—¶
            startReadingTime() {
                this._clearIntervals('readingTimeInterval', 'timeDisplayInterval');
                
                this.sessionStartTime = Date.now();
                this.isPageVisible = !document.hidden;
                
                const { SAVE_PROGRESS, UPDATE_TIME_DISPLAY } = CONFIG.INTERVALS;
                
                this.readingTimeInterval = setInterval(() => {
                    if (this.isPageVisible && this.currentBookId) {
                        this.saveReadingProgress();
                    }
                }, SAVE_PROGRESS);
                
                this.timeDisplayInterval = setInterval(() => {
                    this.updateTimeDisplay();
                }, UPDATE_TIME_DISPLAY);
            }

            // æš‚åœè®¡æ—¶
            pauseReadingTime() {
                if (this.isPageVisible && this.sessionStartTime) {
                    this.totalReadingTime += Date.now() - this.sessionStartTime;
                    this.sessionStartTime = null;
                }
                this.isPageVisible = false;
            }

            // æ¢å¤è®¡æ—¶
            resumeReadingTime() {
                if (!this.isPageVisible && this.currentBookId) {
                    this.sessionStartTime = Date.now();
                    this.isPageVisible = true;
                }
            }

            // è·å–å½“å‰ç´¯è®¡é˜…è¯»æ—¶é—´
            getCurrentReadingTime() {
                let total = this.totalReadingTime;
                if (this.isPageVisible && this.sessionStartTime) {
                    total += Date.now() - this.sessionStartTime;
                }
                return total;
            }

            // ä½¿ç”¨å·¥å…·å‡½æ•°æ ¼å¼åŒ–æ—¶é—´
            formatReadingTime(ms) {
                return Utils.formatReadingTime(ms);
            }

            // åˆå§‹åŒ–å­˜å‚¨å¹¶å°è¯•åŠ è½½ä¸Šæ¬¡çš„ä¹¦ç±
            async initStorage() {
                try {
                    await this.bookStorage.init();
                    // å¹¶è¡ŒåŠ è½½COCAè¯é¢‘è¡¨ã€ç¿»è¯‘ç¼“å­˜ã€å·²çŸ¥è¯æ±‡å’Œç¦»çº¿è¯å…¸
                    await Promise.all([
                        this.loadCOCAList(),
                        this.initTranslationCache(),
                        this.initKnownWords(),
                        this.loadOfflineDict()
                    ]);
                    await this.loadLastBook();
                } catch (e) {
                    console.warn('æ— æ³•åˆå§‹åŒ–å­˜å‚¨:', e);
                }
            }
            
            // åŠ è½½ç¦»çº¿è¯å…¸ï¼ˆä¼˜å…ˆä» IndexedDB ç¼“å­˜ï¼Œå¦åˆ™ä» CDN åŠ è½½ï¼‰
            async loadOfflineDict(forceReload = false) {
                // å…ˆå°è¯•ä» IndexedDB åŠ è½½ç¼“å­˜
                if (!forceReload) {
                    try {
                        const cached = await this.bookStorage.getOfflineDict();
                        if (cached?.data) {
                            this._populateOfflineDict(cached.data);
                            this.offlineDictLoaded = true;
                            console.log(`ç¦»çº¿è¯å…¸ä»ç¼“å­˜åŠ è½½å®Œæˆï¼Œå…± ${this.offlineDict.size} æ¡`);
                            this.updateDictStatus();
                            return;
                        }
                    } catch (e) {
                        console.warn('ä» IndexedDB åŠ è½½è¯å…¸ç¼“å­˜å¤±è´¥:', e);
                    }
                }
                
                this.updateDictStatus('æ­£åœ¨åŠ è½½è¯å…¸...');
                
                // ä» CDN åŠ è½½
                for (const url of CONFIG.URLS.DICT) {
                    try {
                        console.log(`å°è¯•ä» ${url} åŠ è½½è¯å…¸...`);
                        const response = await fetch(url);
                        if (!response.ok) continue;
                        
                        const data = await response.json();
                        this.offlineDict.clear();
                        this._parseDictData(data);
                        
                        this.offlineDictLoaded = true;
                        console.log(`ç¦»çº¿è¯å…¸åŠ è½½å®Œæˆï¼Œå…± ${this.offlineDict.size} æ¡`);
                        
                        // ç¼“å­˜åˆ° IndexedDB
                        this._cacheDictToStorage();
                        this.updateDictStatus();
                        return;
                    } catch (e) {
                        console.warn(`ä» ${url} åŠ è½½è¯å…¸å¤±è´¥:`, e);
                    }
                }
                
                console.warn('æ‰€æœ‰è¯å…¸æºåŠ è½½å¤±è´¥');
                this.updateDictStatus('åŠ è½½å¤±è´¥ï¼Œç¿»è¯‘å°†ä½¿ç”¨ Google API');
            }
            
            // è¾…åŠ©æ–¹æ³•ï¼šå¡«å……ç¦»çº¿è¯å…¸
            _populateOfflineDict(data) {
                for (const [word, translation] of Object.entries(data)) {
                    this.offlineDict.set(word.toLowerCase(), translation);
                }
            }
            
            // è¾…åŠ©æ–¹æ³•ï¼šè§£æè¯å…¸æ•°æ®
            _parseDictData(data) {
                if (Array.isArray(data)) {
                    // æ•°ç»„æ ¼å¼
                    for (const item of data) {
                        if (item.word && item.translation) {
                            this.offlineDict.set(item.word.toLowerCase(), item.translation);
                        }
                    }
                } else {
                    // å¯¹è±¡æ ¼å¼
                    for (const [word, value] of Object.entries(data)) {
                        const translation = typeof value === 'string' 
                            ? value 
                            : (value?.translation || value?.trans || value?.zh || '');
                        if (translation) {
                            this.offlineDict.set(word.toLowerCase(), translation);
                        }
                    }
                }
            }
            
            // è¾…åŠ©æ–¹æ³•ï¼šç¼“å­˜è¯å…¸åˆ°å­˜å‚¨
            async _cacheDictToStorage() {
                try {
                    const cacheObj = Object.fromEntries(this.offlineDict);
                    await this.bookStorage.saveOfflineDict(cacheObj);
                    console.log('è¯å…¸å·²ç¼“å­˜åˆ° IndexedDB');
                } catch (e) {
                    console.warn('ç¼“å­˜è¯å…¸å¤±è´¥:', e);
                }
            }
            
            // ä»ç¦»çº¿è¯å…¸æŸ¥è¯¢ç¿»è¯‘
            getOfflineTranslation(word) {
                if (!this.offlineDictLoaded || this.offlineDict.size === 0) return null;
                return this.offlineDict.get(word.toLowerCase()) || null;
            }

            // åˆå§‹åŒ–å·²çŸ¥è¯æ±‡è¡¨
            async initKnownWords() {
                try {
                    const words = await this.bookStorage.getAllKnownWords();
                    this.knownWords = new Set(words.map(w => w.lemma));
                    console.log(`å·²çŸ¥è¯æ±‡è¡¨åŠ è½½å®Œæˆï¼Œå…± ${this.knownWords.size} ä¸ªè¯`);
                } catch (e) {
                    console.warn('åŠ è½½å·²çŸ¥è¯æ±‡è¡¨å¤±è´¥:', e);
                }
            }

            // åŠ è½½ä¸Šæ¬¡æ‰“å¼€çš„ä¹¦ç±
            async loadLastBook() {
                try {
                    const lastBookId = this.bookStorage.getLastBookId();
                    if (lastBookId) {
                        const book = await this.bookStorage.getBook(lastBookId);
                        if (book && book.data) {
                            // è·å–ä¿å­˜çš„é˜…è¯»è¿›åº¦
                            const progress = await this.bookStorage.getProgress(lastBookId);
                            if (progress) {
                                this.pendingScrollPosition = progress.scrollPosition;
                                this.totalReadingTime = progress.totalReadingTime || 0;
                            }
                            
                            this.currentFileName = book.fileName;
                            this.currentBookId = lastBookId;
                            this.currentFileType = book.fileType || 'epub';
                            
                            // æ ¹æ®æ–‡ä»¶ç±»å‹é€‰æ‹©åŠ è½½æ–¹æ³•
                            if (book.fileType === 'pdf' || book.fileName.toLowerCase().endsWith('.pdf')) {
                                await this.loadPDFFromArrayBuffer(book.data, book.fileName, true);
                            } else {
                                await this.loadEPUBFromArrayBuffer(book.data, book.fileName, true);
                            }
                        }
                    }
                } catch (e) {
                    console.warn('æ— æ³•åŠ è½½ä¸Šæ¬¡çš„ä¹¦ç±:', e);
                }
            }

            // ä¿å­˜é˜…è¯»è¿›åº¦
            async saveReadingProgress() {
                if (!this.currentBookId) return;
                
                const container = document.getElementById('reader-container');
                const scrollHeight = container.scrollHeight - container.clientHeight;
                const scrollPercentage = scrollHeight > 0 
                    ? Math.round((container.scrollTop / scrollHeight) * 100) 
                    : 0;
                
                try {
                    await this.bookStorage.saveProgress(this.currentBookId, {
                        scrollPosition: container.scrollTop,
                        scrollPercentage: scrollPercentage,
                        totalReadingTime: this.getCurrentReadingTime()
                    });
                } catch (e) {
                    console.warn('ä¿å­˜è¿›åº¦å¤±è´¥:', e);
                }
            }

            // æ˜¾ç¤ºä¹¦æ¶
            async showLibrary() {
                const books = await this.bookStorage.getAllBooks();
                
                if (books.length === 0) {
                    return;
                }
                
                // è·å–æ¯æœ¬ä¹¦çš„è¿›åº¦
                const booksWithProgress = await Promise.all(books.map(async (book) => {
                    const progress = await this.bookStorage.getProgress(book.id);
                    return { ...book, progress };
                }));
                
                this.renderLibrary(booksWithProgress);
            }

            // æ¸²æŸ“ä¹¦æ¶
            renderLibrary(books) {
                const modal = document.createElement('div');
                modal.className = 'library-modal';
                modal.innerHTML = `
                    <div class="library-content">
                        <div class="library-header">
                            <h2>é˜…è¯»å†å²</h2>
                            <button class="library-close" id="library-close">âœ•</button>
                        </div>
                        <div class="library-books" id="library-books">
                            ${books.map(book => {
                                const fileType = book.fileType || (book.fileName.toLowerCase().endsWith('.pdf') ? 'pdf' : 'epub');
                                return `
                                <div class="library-book" data-book-id="${book.id}">
                                    <div class="book-info">
                                        <div class="book-title">
                                            <span class="file-type-badge ${fileType}">${fileType.toUpperCase()}</span>
                                            ${book.title || book.fileName}
                                        </div>
                                        <div class="book-meta">
                                            ${book.author ? `<span class="book-author">${book.author}</span>` : ''}
                                            <span class="book-progress">${book.progress ? book.progress.scrollPercentage + '%' : '0%'}</span>
                                            ${book.progress && book.progress.totalReadingTime ? 
                                                `<span class="book-time">å·²è¯» ${this.formatReadingTime(book.progress.totalReadingTime)}</span>` : ''}
                                        </div>
                                    </div>
                                    <div class="book-actions">
                                        <button class="book-open" data-book-id="${book.id}">æ‰“å¼€</button>
                                        <button class="book-delete" data-book-id="${book.id}">åˆ é™¤</button>
                                    </div>
                                </div>
                            `;}).join('')}
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // å…³é—­æŒ‰é’®
                document.getElementById('library-close').addEventListener('click', () => {
                    modal.remove();
                });
                
                // ç‚¹å‡»èƒŒæ™¯å…³é—­
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
                // æ‰“å¼€ä¹¦ç±
                modal.querySelectorAll('.book-open').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const bookId = btn.dataset.bookId;
                        modal.remove();
                        await this.openBookById(bookId);
                    });
                });
                
                // åˆ é™¤ä¹¦ç±
                modal.querySelectorAll('.book-delete').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const bookId = btn.dataset.bookId;
                        if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æœ¬ä¹¦å—ï¼Ÿ')) {
                            await this.bookStorage.deleteBook(bookId);
                            btn.closest('.library-book').remove();
                            
                            // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰ä¹¦ç±
                            if (bookId === this.currentBookId) {
                                this.currentBookId = null;
                                document.getElementById('welcome-screen').style.display = 'flex';
                                document.getElementById('reader-content').style.display = 'none';
                            }
                        }
                    });
                });
            }

            // é€šè¿‡IDæ‰“å¼€ä¹¦ç±
            async openBookById(bookId) {
                this.showLoading(true);
                try {
                    const book = await this.bookStorage.getBook(bookId);
                    if (book && book.data) {
                        const progress = await this.bookStorage.getProgress(bookId);
                        if (progress) {
                            this.pendingScrollPosition = progress.scrollPosition;
                            this.totalReadingTime = progress.totalReadingTime || 0;
                        } else {
                            this.totalReadingTime = 0;
                        }
                        
                        this.currentFileName = book.fileName;
                        this.currentBookId = bookId;
                        this.currentFileType = book.fileType || 'epub';
                        this.bookStorage.setLastBookId(bookId);
                        await this.bookStorage.updateLastOpened(bookId);
                        
                        // æ ¹æ®æ–‡ä»¶ç±»å‹é€‰æ‹©åŠ è½½æ–¹æ³•
                        if (book.fileType === 'pdf' || book.fileName.toLowerCase().endsWith('.pdf')) {
                            await this.loadPDFFromArrayBuffer(book.data, book.fileName, true);
                        } else {
                            await this.loadEPUBFromArrayBuffer(book.data, book.fileName, true);
                        }
                    }
                } catch (e) {
                    console.error('æ‰“å¼€ä¹¦ç±å¤±è´¥:', e);
                    alert('æ‰“å¼€ä¹¦ç±å¤±è´¥');
                } finally {
                    this.showLoading(false);
                }
            }

            // åˆå§‹åŒ–ç²¾ç¡®é˜…è¯»è¿½è¸ª
            initPreciseReadingTracker() {
                // æ¸…ç†ä¹‹å‰çš„è§‚å¯Ÿå™¨
                if (this.readObserver) {
                    this.readObserver.disconnect();
                }
                this.readParagraphs.clear();
                this.totalReadCharacters = 0;
                this.lastReadCountTime = Date.now();
                this.readingSpeedHistory = [];
                
                const readerContent = document.getElementById('reader-content');
                if (!readerContent) return;
                
                // è·å–æ‰€æœ‰æ–‡æœ¬æ®µè½ï¼ˆp, h1-h6, li, blockquote ç­‰ï¼‰
                const textElements = readerContent.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, blockquote, td, th, dt, dd, figcaption');
                
                // ä¸ºæ¯ä¸ªæ®µè½åˆ›å»ºè¿½è¸ªæ•°æ®
                textElements.forEach((el, index) => {
                    const text = el.textContent || '';
                    const wordCount = this.countWords(text);
                    if (wordCount > 0) {
                        el.dataset.paragraphId = `para-${index}`;
                        this.readParagraphs.set(el.dataset.paragraphId, {
                            element: el,
                            wordCount: wordCount,
                            isRead: false,
                            visibleSince: null,
                            totalVisibleTime: 0
                        });
                    }
                });
                
                // åˆ›å»º Intersection Observer
                const container = document.getElementById('reader-container');
                this.readObserver = new IntersectionObserver((entries) => {
                    if (!this.isPageVisible) return;
                    
                    const now = Date.now();
                    entries.forEach(entry => {
                        const paraId = entry.target.dataset.paragraphId;
                        if (!paraId) return;
                        
                        const paraData = this.readParagraphs.get(paraId);
                        if (!paraData || paraData.isRead) return;
                        
                        // å¯¹äºçŸ­æ®µè½ï¼ˆ<= 10è¯ï¼‰ï¼Œåªéœ€è¦ä»»æ„å¯è§å³å¯ï¼›è¾ƒé•¿æ®µè½éœ€è¦50%å¯è§
                        const visibilityThreshold = paraData.wordCount <= 10 ? 0 : 0.5;
                        
                        if (entry.isIntersecting && entry.intersectionRatio > visibilityThreshold) {
                            // æ®µè½è¿›å…¥å¯è§†åŒºåŸŸ
                            if (!paraData.visibleSince) {
                                paraData.visibleSince = now;
                            }
                        } else {
                            // æ®µè½ç¦»å¼€å¯è§†åŒºåŸŸ
                            if (paraData.visibleSince) {
                                paraData.totalVisibleTime += now - paraData.visibleSince;
                                paraData.visibleSince = null;
                                
                                // ç¦»å¼€æ—¶ç«‹å³æ£€æŸ¥æ˜¯å¦å¯ä»¥æ ‡è®°ä¸ºå·²è¯»
                                this.checkSingleParagraph(paraId, paraData, now);
                            }
                        }
                    });
                }, {
                    root: container,
                    threshold: [0, 0.1, 0.25, 0.5, 0.75, 1.0],
                    rootMargin: '0px'
                });
                
                // å¼€å§‹è§‚å¯Ÿæ‰€æœ‰æ®µè½
                this.readParagraphs.forEach((data) => {
                    this.readObserver.observe(data.element);
                });
                
                // å®šæœŸæ£€æŸ¥å¹¶æ ‡è®°å·²è¯»æ®µè½
                this._clearIntervals('readCheckInterval');
                this.readCheckInterval = setInterval(() => {
                    this.checkReadParagraphs();
                }, CONFIG.INTERVALS.CHECK_READ);
            }
            
            // è®¡ç®—æ®µè½æ‰€éœ€çš„æœ€å°é˜…è¯»æ—¶é—´
            calculateRequiredReadTime(wordCount) {
                // çŸ­æ®µè½ï¼ˆ1-5è¯ï¼‰ï¼š200-400ms
                // ä¸­ç­‰æ®µè½ï¼ˆ6-20è¯ï¼‰ï¼š400-800ms  
                // é•¿æ®µè½ï¼ˆ20+è¯ï¼‰ï¼šæ ¹æ®é˜…è¯»é€Ÿåº¦è®¡ç®—ï¼Œä½†è‡³å°‘800ms
                
                if (wordCount <= 5) {
                    return 200 + wordCount * 40;
                } else if (wordCount <= 20) {
                    return 300 + wordCount * 25;
                } else {
                    const { WORDS_PER_SECOND } = CONFIG.READING;
                    return Math.max(800, (wordCount / WORDS_PER_SECOND) * 1000 * 0.3);
                }
            }
            
            // æ£€æŸ¥å•ä¸ªæ®µè½æ˜¯å¦å·²è¯»
            checkSingleParagraph(paraId, data, now) {
                if (data.isRead) return;
                
                let totalTime = data.totalVisibleTime;
                if (data.visibleSince) {
                    totalTime += now - data.visibleSince;
                }
                
                const requiredTime = this.calculateRequiredReadTime(data.wordCount);
                
                if (totalTime >= requiredTime) {
                    data.isRead = true;
                    this.totalReadCharacters += data.wordCount;
                    // è°ƒè¯•ï¼šç»™å·²è¯»æ®µè½æ·»åŠ è§†è§‰æ ‡è®°
                    // data.element.style.backgroundColor = 'rgba(46, 204, 113, 0.1)';
                }
            }
            
            // æ£€æŸ¥å¹¶æ ‡è®°å·²è¯»æ®µè½
            checkReadParagraphs() {
                if (!this.isPageVisible) return;
                
                const now = Date.now();
                
                this.readParagraphs.forEach((data, paraId) => {
                    this.checkSingleParagraph(paraId, data, now);
                });
            }
            
            // è®°å½•é˜…è¯»é€Ÿåº¦æ•°æ®ç‚¹
            recordReadingSpeedPoint() {
                const now = Date.now();
                
                // ç¡®ä¿å½“å‰å¯è§çš„æ®µè½æ—¶é—´è¢«è®¡å…¥
                this.checkReadParagraphs();
                
                this.readingSpeedHistory.push({
                    timestamp: now,
                    wordsRead: this.totalReadCharacters
                });
                
                // åªä¿ç•™é…ç½®æ—¶é•¿çš„æ•°æ®
                const cutoffTime = now - CONFIG.READING.SPEED_HISTORY_MINUTES * 60 * 1000;
                this.readingSpeedHistory = this.readingSpeedHistory.filter(h => h.timestamp >= cutoffTime);
            }

            // è®¡ç®—ç²¾ç¡®é˜…è¯»é€Ÿåº¦ï¼ˆè¯/åˆ†é’Ÿï¼‰
            calculateReadingSpeed() {
                if (this.readingSpeedHistory.length < 2) return null;
                
                const now = Date.now();
                const { SPEED_CALC_MINUTES, MIN_SPEED_TIME, MIN_WPM, MAX_WPM } = CONFIG.READING;
                
                // ä½¿ç”¨æœ€è¿‘æ•°æ®è®¡ç®—é€Ÿåº¦
                const cutoffTime = now - SPEED_CALC_MINUTES * 60 * 1000;
                const recentHistory = this.readingSpeedHistory.filter(h => h.timestamp >= cutoffTime);
                
                if (recentHistory.length < 2) return null;
                
                const oldest = recentHistory[0];
                const newest = recentHistory[recentHistory.length - 1];
                
                const timeDiffMinutes = (newest.timestamp - oldest.timestamp) / 60000;
                const wordsDiff = newest.wordsRead - oldest.wordsRead;
                
                // æœ€å°æ—¶é—´å’Œæ­£å‘é˜…è¯»æ£€æŸ¥
                if (timeDiffMinutes < MIN_SPEED_TIME || wordsDiff <= 0) return null;
                
                const wpm = Math.round(wordsDiff / timeDiffMinutes);
                
                // åˆç†èŒƒå›´æ£€æŸ¥
                return (wpm >= MIN_WPM && wpm <= MAX_WPM) ? wpm : null;
            }

            // æ›´æ–°é˜…è¯»é€Ÿåº¦æ˜¾ç¤º
            updateSpeedDisplay() {
                const speed = this.calculateReadingSpeed();
                const speedIndicator = document.getElementById('speed-indicator');
                const speedValue = document.getElementById('speed-value');
                
                if (speed !== null) {
                    speedIndicator.classList.add('active');
                    speedValue.textContent = speed;
                } else {
                    speedValue.textContent = '--';
                }
                
                // åŒæ—¶æ›´æ–°å·²è¯»å­—æ•°æ˜¾ç¤º
                this.updateReadCountDisplay();
            }
            
            // æ›´æ–°å·²è¯»å­—æ•°æ˜¾ç¤º
            updateReadCountDisplay() {
                const readCountIndicator = document.getElementById('read-count-indicator');
                const readCountValue = document.getElementById('read-count-value');
                
                if (readCountIndicator && readCountValue) {
                    readCountIndicator.classList.add('active');
                    readCountValue.textContent = this.totalReadCharacters.toLocaleString();
                }
            }

            // å¼€å§‹é˜…è¯»é€Ÿåº¦è·Ÿè¸ª
            startSpeedTracking() {
                // åœæ­¢ä¹‹å‰çš„è·Ÿè¸ª
                this.stopSpeedTracking();
                
                // åˆå§‹åŒ–ç²¾ç¡®é˜…è¯»è¿½è¸ª
                this.initPreciseReadingTracker();
                
                // è®°å½•åˆå§‹ç‚¹
                this.recordReadingSpeedPoint();
                
                // æ˜¾ç¤ºé€Ÿåº¦æŒ‡ç¤ºå™¨
                document.getElementById('speed-indicator').classList.add('active');
                
                // å®šæœŸè®°å½•é€Ÿåº¦æ•°æ®å¹¶æ›´æ–°æ˜¾ç¤º
                this.speedUpdateInterval = setInterval(() => {
                    this.recordReadingSpeedPoint();
                    this.updateSpeedDisplay();
                }, CONFIG.INTERVALS.UPDATE_SPEED);
            }

            // åœæ­¢é˜…è¯»é€Ÿåº¦è·Ÿè¸ª
            stopSpeedTracking() {
                this._clearIntervals('speedUpdateInterval', 'readCheckInterval');
                
                if (this.readObserver) {
                    this.readObserver.disconnect();
                    this.readObserver = null;
                }
            }
            
            // æ¸…ç†æ‰€æœ‰èµ„æºï¼ˆç”¨äºé¡µé¢å¸è½½æˆ–é‡æ–°åŠ è½½ä¹¦ç±æ—¶ï¼‰
            cleanup() {
                this.stopSpeedTracking();
                this._clearIntervals('readingTimeInterval', 'timeDisplayInterval');
                
                if (this.annotationObserver) {
                    this.annotationObserver.disconnect();
                    this.annotationObserver = null;
                }
                
                // æ¸…ç†å¤§å‹æ•°æ®ç»“æ„
                this.readParagraphs.clear();
                this.readingSpeedHistory = [];
                this.annotatedParagraphs.clear();
            }

            // æ›´æ–°é˜…è¯»æ—¶é—´æ˜¾ç¤º
            updateTimeDisplay() {
                const timeValue = document.getElementById('time-value');
                if (timeValue) {
                    timeValue.textContent = this.formatReadingTime(this.getCurrentReadingTime());
                }
            }

            // æ›´æ–°æ€»å­—æ•°æ˜¾ç¤º
            updateWordCountDisplay() {
                const wordCountIndicator = document.getElementById('word-count-indicator');
                const wordCountValue = document.getElementById('word-count-value');
                
                if (wordCountIndicator && wordCountValue) {
                    wordCountIndicator.classList.add('active');
                    wordCountValue.textContent = Utils.formatNumber(this.totalCharacters);
                }
            }

            // è®¡ç®—å•è¯æ•° - ä½¿ç”¨å·¥å…·å‡½æ•°
            countWords(text) {
                return Utils.countWords(text);
            }

            // åŠ è½½è¯æ±‡æ ‡æ³¨è®¾ç½®
            loadAnnotationSettings() {
                const saved = localStorage.getItem('annotationSettings');
                const settings = Utils.safeJsonParse(saved, {});
                const { DEFAULT_MIN, DEFAULT_MAX, DEFAULT_THRESHOLD } = CONFIG.COCA;
                
                this.annotationEnabled = settings.enabled ?? true;
                this.freqMin = settings.freqMin ?? DEFAULT_MIN;
                this.freqMax = settings.freqMax ?? DEFAULT_MAX;
                this.learningThreshold = settings.learningThreshold ?? DEFAULT_THRESHOLD;
                this.offlineDictPriority = settings.offlineDictPriority ?? false;
            }

            // ä¿å­˜è¯æ±‡æ ‡æ³¨è®¾ç½®
            saveAnnotationSettings() {
                localStorage.setItem('annotationSettings', JSON.stringify({
                    enabled: this.annotationEnabled,
                    freqMin: this.freqMin,
                    freqMax: this.freqMax,
                    learningThreshold: this.learningThreshold,
                    offlineDictPriority: this.offlineDictPriority
                }));
            }

            // åŠ è½½COCAè¯é¢‘è¡¨
            async loadCOCAList() {
                if (this.cocaLoaded) return;
                
                try {
                    const response = await fetch(CONFIG.URLS.COCA);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    
                    const text = await response.text();
                    const lines = text.trim().split('\n');
                    this.cocaRanks = new Map();
                    
                    lines.forEach((word, index) => {
                        this.cocaRanks.set(word.toLowerCase().trim(), index + 1);
                    });
                    
                    this.cocaLoaded = true;
                    console.log(`COCAè¯é¢‘è¡¨åŠ è½½å®Œæˆï¼Œå…± ${this.cocaRanks.size} ä¸ªè¯`);
                } catch (e) {
                    console.warn('åŠ è½½COCAè¯é¢‘è¡¨å¤±è´¥:', e);
                }
            }

            // åˆå§‹åŒ–ç¿»è¯‘ç¼“å­˜
            async initTranslationCache() {
                try {
                    const cached = await this.bookStorage.getAllTranslations();
                    cached.forEach(item => {
                        this.translationCache.set(item.word, item.translation);
                    });
                    console.log(`ç¿»è¯‘ç¼“å­˜åŠ è½½å®Œæˆï¼Œå…± ${this.translationCache.size} æ¡`);
                } catch (e) {
                    console.warn('åŠ è½½ç¿»è¯‘ç¼“å­˜å¤±è´¥:', e);
                }
            }

            // è°ƒç”¨Googleç¿»è¯‘APIï¼ˆæŸ¥è¯¢åŸè¯ï¼‰ï¼Œå¤±è´¥æ—¶å›é€€åˆ°ç¦»çº¿è¯å…¸
            // å¦‚æœå¼€å¯äº†ç¦»çº¿è¯å…¸ä¼˜å…ˆï¼Œåˆ™å…ˆæŸ¥ç¦»çº¿è¯å…¸ï¼ŒæŸ¥ä¸åˆ°å†ç”¨Googleç¿»è¯‘
            async translateWord(word, lemma = null) {
                // ç¦»çº¿è¯å…¸ä¼˜å…ˆæ¨¡å¼
                if (this.offlineDictPriority) {
                    // å…ˆæŸ¥åŸè¯
                    let offlineResult = this.getOfflineTranslation(word);
                    if (offlineResult) {
                        console.log(`[ç¦»çº¿ä¼˜å…ˆ] ä½¿ç”¨ç¦»çº¿è¯å…¸ç¿»è¯‘(åŸè¯): ${word} -> ${offlineResult}`);
                        return offlineResult;
                    }
                    
                    // åŸè¯æŸ¥ä¸åˆ°ï¼Œå°è¯•æŸ¥ lemma
                    if (lemma && lemma !== word.toLowerCase()) {
                        offlineResult = this.getOfflineTranslation(lemma);
                        if (offlineResult) {
                            console.log(`[ç¦»çº¿ä¼˜å…ˆ] ä½¿ç”¨ç¦»çº¿è¯å…¸ç¿»è¯‘(lemma): ${lemma} -> ${offlineResult}`);
                            return offlineResult;
                        }
                    }
                    
                    // ç¦»çº¿è¯å…¸æŸ¥ä¸åˆ°ï¼Œå›é€€åˆ° Google ç¿»è¯‘
                    const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=zh-CN&dt=t&q=${encodeURIComponent(word)}`;
                    try {
                        const response = await fetch(url);
                        const data = await response.json();
                        const result = data[0]?.[0]?.[0] || null;
                        if (result) {
                            console.log(`[ç¦»çº¿ä¼˜å…ˆ] ç¦»çº¿è¯å…¸æ— ç»“æœï¼Œä½¿ç”¨Googleç¿»è¯‘: ${word} -> ${result}`);
                            return result;
                        }
                    } catch (e) {
                        console.warn(`Googleç¿»è¯‘APIå¤±è´¥: ${word}`, e);
                    }
                    return null;
                }
                
                // é»˜è®¤æ¨¡å¼ï¼šGoogle ç¿»è¯‘ä¼˜å…ˆ
                const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=zh-CN&dt=t&q=${encodeURIComponent(word)}`;
                
                try {
                    const response = await fetch(url);
                    const data = await response.json();
                    const result = data[0]?.[0]?.[0] || null;
                    if (result) return result;
                } catch (e) {
                    console.warn(`Googleç¿»è¯‘APIå¤±è´¥: ${word}`, e);
                }
                
                // API å¤±è´¥æ—¶ï¼Œå›é€€åˆ°ç¦»çº¿è¯å…¸
                // å…ˆæŸ¥åŸè¯
                let offlineResult = this.getOfflineTranslation(word);
                if (offlineResult) {
                    console.log(`ä½¿ç”¨ç¦»çº¿è¯å…¸ç¿»è¯‘(åŸè¯): ${word} -> ${offlineResult}`);
                    return offlineResult;
                }
                
                // åŸè¯æŸ¥ä¸åˆ°ï¼Œå°è¯•æŸ¥ lemma
                if (lemma && lemma !== word.toLowerCase()) {
                    offlineResult = this.getOfflineTranslation(lemma);
                    if (offlineResult) {
                        console.log(`ä½¿ç”¨ç¦»çº¿è¯å…¸ç¿»è¯‘(lemma): ${lemma} -> ${offlineResult}`);
                        return offlineResult;
                    }
                }
                
                return null;
            }

            // è·å–ç¿»è¯‘ï¼ˆä¼˜å…ˆä»ç¼“å­˜è·å–ï¼‰
            // word: åŸè¯, lemma: è¯æ ¹å½¢å¼ï¼ˆå¯é€‰ï¼Œç”¨äºç¦»çº¿è¯å…¸å¤‡é€‰æŸ¥è¯¢ï¼‰
            async getTranslation(word, lemma = null) {
                const lowerWord = word.toLowerCase();
                
                // å…ˆæ£€æŸ¥å†…å­˜ç¼“å­˜ï¼ˆæŒ‰åŸè¯ç¼“å­˜ï¼‰
                if (this.translationCache.has(lowerWord)) {
                    return this.translationCache.get(lowerWord);
                }
                
                // è°ƒç”¨ç¿»è¯‘API
                const translation = await this.translateWord(word, lemma);
                if (translation) {
                    this.translationCache.set(lowerWord, translation);
                    // å¼‚æ­¥ä¿å­˜åˆ°IndexedDB
                    this.bookStorage.saveTranslation(lowerWord, translation).catch(e => {
                        console.warn('ä¿å­˜ç¿»è¯‘ç¼“å­˜å¤±è´¥:', e);
                    });
                }
                return translation;
            }

            // ä»¥å¥å­ä¸ºå•ä½è·å–æ‰€æœ‰å•è¯çš„åŸå½¢ï¼ˆlemmaï¼‰å’Œè¯æ€§
            // è¿”å› Map<åŸè¯å°å†™, {lemma, pos}>
            getLemmasFromText(text) {
                // console.log('getLemmasFromText', text);
                const lemmaMap = new Map();
                if (!text || text.trim().length === 0) return lemmaMap;
                
                try {
                    const doc = nlp(text);
                    
                    // éå†æ‰€æœ‰ termsï¼Œå¯¹æ¯ä¸ªå•è¯å•ç‹¬è¿›è¡ŒåŸå½¢è½¬æ¢
                    const terms = doc.terms().json();
                    for (const term of terms) {
                        const originalWord = term.text;
                        if (!originalWord || originalWord.length < 2) continue;
                        if (!/^[a-zA-Z]+$/.test(originalWord)) continue;
                        
                        const lowerWord = originalWord.toLowerCase();
                        if (lemmaMap.has(lowerWord)) continue;
                        
                        let lemma = lowerWord;
                        let pos = 'Unknown';
                        const tags = term.terms?.[0]?.tags || [];
                        
                        if (tags.includes('Verb')) {
                            pos = 'Verb';
                            // æ„é€ å¸¦ä¸»è¯­çš„å¥å­å¸®åŠ© compromise è¯†åˆ«åŠ¨è¯ï¼Œå¹¶æ ‡è®°è¯æ€§
                            const sentenceDoc = nlp('I ' + originalWord);
                            sentenceDoc.match(originalWord).tag('Verb');
                            const verbs = sentenceDoc.verbs();
                            if (verbs.length) {
                                verbs.toInfinitive();
                                // æå–è½¬æ¢åçš„åŠ¨è¯ï¼ˆå»æ‰ "I "ï¼‰
                                const result = sentenceDoc.text().toLowerCase().trim();
                                const infinitive = result.startsWith('i ') ? result.slice(2).trim() : result;
                                if (infinitive && infinitive.length > 0 && /^[a-z]+$/.test(infinitive)) {
                                    lemma = infinitive;
                                }
                            }
                        } else if (tags.includes('Noun')) {
                            pos = 'Noun';
                            // å¯¹å•ä¸ªåè¯è¿›è¡Œå•æ•°è½¬æ¢
                            const wordDoc = nlp(originalWord);
                            const nouns = wordDoc.nouns();
                            if (nouns.length) {
                                nouns.toSingular();
                                const singular = wordDoc.text().toLowerCase().trim();
                                if (singular && singular.length > 0 && /^[a-z]+$/.test(singular)) {
                                    lemma = singular;
                                }
                            }
                        } else if (tags.includes('Adjective')) {
                            pos = 'Adjective';
                            // å¯¹å½¢å®¹è¯è¿›è¡ŒåŸå½¢å¤„ç†ï¼ˆå¤„ç†æ¯”è¾ƒçº§å’Œæœ€é«˜çº§ï¼‰
                            lemma = this.getAdjectiveAdverbLemma(lowerWord);
                        } else if (tags.includes('Adverb')) {
                            pos = 'Adverb';
                            // å¯¹å‰¯è¯è¿›è¡ŒåŸå½¢å¤„ç†
                            lemma = this.getAdjectiveAdverbLemma(lowerWord);
                        } else {
                            pos = tags.length > 0 ? tags[0] : 'Unknown';
                        }
                        
                        lemmaMap.set(lowerWord, { lemma, pos });
                    }
                } catch (e) {
                    console.warn('getLemmasFromText error:', e);
                }
                
                return lemmaMap;
            }

            // ä¸è§„åˆ™å½¢å®¹è¯/å‰¯è¯æ˜ å°„è¡¨
            static IRREGULAR_ADJ_ADV = {
                // good/well
                'better': 'good', 'best': 'good',
                // bad/badly
                'worse': 'bad', 'worst': 'bad',
                // much/many
                'more': 'much', 'most': 'much',
                // little
                'less': 'little', 'least': 'little',
                // far
                'further': 'far', 'furthest': 'far', 'farther': 'far', 'farthest': 'far',
                // old
                'elder': 'old', 'eldest': 'old', 'older': 'old', 'oldest': 'old',
                // late
                'later': 'late', 'latest': 'late', 'latter': 'late',
            };

            // è·å–å½¢å®¹è¯/å‰¯è¯åŸå½¢
            getAdjectiveAdverbLemma(word) {
                if (!word) return word;
                const lower = word.toLowerCase();
                
                // 1. æ£€æŸ¥ä¸è§„åˆ™å½¢å¼
                if (EPUBReader.IRREGULAR_ADJ_ADV[lower]) {
                    return EPUBReader.IRREGULAR_ADJ_ADV[lower];
                }
                
                // 2. å¤„ç†è§„åˆ™å˜åŒ–çš„æ¯”è¾ƒçº§/æœ€é«˜çº§
                // -iest -> -y (happiest -> happy)
                if (lower.endsWith('iest') && lower.length > 5) {
                    return lower.slice(0, -4) + 'y';
                }
                // -ier -> -y (happier -> happy)
                if (lower.endsWith('ier') && lower.length > 4) {
                    return lower.slice(0, -3) + 'y';
                }
                // åŒå†™è¾…éŸ³ + est (biggest -> big)
                if (lower.endsWith('est') && lower.length > 5) {
                    const base = lower.slice(0, -3);
                    if (base.length >= 2 && base[base.length - 1] === base[base.length - 2]) {
                        return base.slice(0, -1);
                    }
                }
                // åŒå†™è¾…éŸ³ + er (bigger -> big)
                if (lower.endsWith('er') && lower.length > 4) {
                    const base = lower.slice(0, -2);
                    if (base.length >= 2 && base[base.length - 1] === base[base.length - 2]) {
                        return base.slice(0, -1);
                    }
                }
                // -est (tallest -> tall, ä½†è¦é¿å… test, best ç­‰)
                if (lower.endsWith('est') && lower.length > 4) {
                    const base = lower.slice(0, -3);
                    // æ£€æŸ¥æ˜¯å¦æ˜¯åˆç†çš„å½¢å®¹è¯è¯æ ¹
                    if (/[aeiou][^aeiou]$/.test(base) || /[^aeiou]{2}$/.test(base)) {
                        return base;
                    }
                }
                // -er (taller -> tall, ä½†è¦é¿å… water, after ç­‰å¸¸è§è¯)
                if (lower.endsWith('er') && lower.length > 3) {
                    const base = lower.slice(0, -2);
                    // åªå¤„ç†æ˜æ˜¾çš„æ¯”è¾ƒçº§æ¨¡å¼
                    if (/[aeiou][^aeiou]$/.test(base) || /[^aeiou]{2}$/.test(base)) {
                        return base;
                    }
                }
                
                return lower;
            }

            // ä½¿ç”¨Compromiseè·å–å•è¯åŸå½¢ï¼ˆå•è¯æ¨¡å¼ï¼Œä½œä¸ºå¤‡ç”¨ï¼‰
            getLemma(word) {
                if (!word || word.length < 2) return word;
                
                try {
                    const doc = nlp(word);
                    
                    // å°è¯•è·å–åŠ¨è¯åŸå½¢
                    const verbs = doc.verbs();
                    if (verbs.length) {
                        const infinitive = verbs.toInfinitive().out('text');
                        if (infinitive && infinitive.length > 0) {
                            return infinitive.toLowerCase();
                        }
                    }
                    
                    // å°è¯•è·å–åè¯å•æ•°å½¢å¼
                    const nouns = doc.nouns();
                    if (nouns.length) {
                        const singular = nouns.toSingular().out('text');
                        if (singular && singular.length > 0) {
                            return singular.toLowerCase();
                        }
                    }
                    
                    // è¿”å›åŸè¯å°å†™
                    return word.toLowerCase();
                } catch (e) {
                    return word.toLowerCase();
                }
            }

            // åˆå§‹åŒ–æ‡’åŠ è½½æ ‡æ³¨è§‚å¯Ÿå™¨
            initAnnotationObserver() {
                // æ¸…ç†ä¹‹å‰çš„è§‚å¯Ÿå™¨
                if (this.annotationObserver) {
                    this.annotationObserver.disconnect();
                }
                this.annotatedParagraphs = new Set();
                this.annotatedWordsHistory = new Map(); // è·Ÿè¸ªè¯æœ€è¿‘å‡ºç°çš„æ®µè½ç´¢å¼•ï¼Œkey: lemma, value: æ®µè½ç´¢å¼•
                this.currentParagraphIndex = 0; // å½“å‰æ®µè½ç´¢å¼•
                this.annotationQueue = []; // å¾…æ ‡æ³¨çš„æ®µè½é˜Ÿåˆ—
                this.isProcessingAnnotation = false; // æ˜¯å¦æ­£åœ¨å¤„ç†æ ‡æ³¨
                
                if (!this.annotationEnabled || !this.cocaLoaded) return;
                
                const readerContent = document.getElementById('reader-content');
                if (!readerContent) return;
                
                // è·å–æ‰€æœ‰å¯æ ‡æ³¨çš„æ®µè½å…ƒç´ 
                const paragraphs = readerContent.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, blockquote, td, th, dt, dd, figcaption');
                
                // ä¸ºæ¯ä¸ªæ®µè½åˆ†é…å”¯ä¸€ID
                paragraphs.forEach((el, index) => {
                    if (!el.dataset.annotationId) {
                        el.dataset.annotationId = `anno-${index}`;
                    }
                });
                
                const container = document.getElementById('reader-container');
                
                // åˆ›å»º IntersectionObserver ç”¨äºæ‡’åŠ è½½æ ‡æ³¨
                this.annotationObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const paraId = entry.target.dataset.annotationId;
                            if (paraId && !this.annotatedParagraphs.has(paraId)) {
                                this.annotatedParagraphs.add(paraId);
                                // åŠ å…¥é˜Ÿåˆ—è€Œä¸æ˜¯ç›´æ¥è°ƒç”¨ï¼Œç¡®ä¿ä¸²è¡Œå¤„ç†
                                this.annotationQueue.push(entry.target);
                                this.processAnnotationQueue();
                            }
                        }
                    });
                }, {
                    root: container,
                    rootMargin: '200px 0px', // æå‰200pxå¼€å§‹æ ‡æ³¨
                    threshold: 0
                });
                
                // å¼€å§‹è§‚å¯Ÿæ‰€æœ‰æ®µè½
                paragraphs.forEach(el => {
                    this.annotationObserver.observe(el);
                });
            }

            // ä¸²è¡Œå¤„ç†æ ‡æ³¨é˜Ÿåˆ—ï¼Œé¿å…å¹¶å‘å¯¼è‡´å»é‡å¤±æ•ˆ
            async processAnnotationQueue() {
                if (this.isProcessingAnnotation) return; // å·²æœ‰å¤„ç†ä¸­ï¼Œç›´æ¥è¿”å›
                this.isProcessingAnnotation = true;
                
                while (this.annotationQueue.length > 0) {
                    const element = this.annotationQueue.shift();
                    await this.annotateParagraph(element);
                }
                
                this.isProcessingAnnotation = false;
            }

            // æ ‡æ³¨å•ä¸ªæ®µè½ï¼ˆä»¥å¥å­ä¸ºå•ä½è¿›è¡Œlemmatizeï¼‰
            async annotateParagraph(element) {
                if (!this.annotationEnabled || !this.cocaLoaded) return;
                
                // é€’å¢æ®µè½ç´¢å¼•
                this.currentParagraphIndex++;
                
                const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);
                const textNodes = [];
                while (walker.nextNode()) {
                    textNodes.push(walker.currentNode);
                }
                
                for (const node of textNodes) {
                    // è·³è¿‡ç‰¹æ®Šæ ‡ç­¾
                    const parentTag = node.parentNode?.tagName?.toUpperCase();
                    if (['SCRIPT', 'STYLE', 'CODE', 'PRE', 'TEXTAREA'].includes(parentTag)) {
                        continue;
                    }
                    
                    const text = node.textContent;
                    if (!text || text.trim().length === 0) continue;
                    
                    // æå–æ‰€æœ‰è‹±æ–‡å•è¯ï¼ˆæ”¯æŒè¿å­—ç¬¦è¯æ±‡å¦‚ gold-rimmedï¼‰
                    const wordMatches = [...text.matchAll(/[a-zA-Z]+(?:-[a-zA-Z]+)*/g)];
                    if (wordMatches.length === 0) continue;
                    
                    // ä»¥å¥å­ä¸ºå•ä½è·å–æ‰€æœ‰å•è¯çš„lemmaå’Œè¯æ€§
                    // å°†æ•´ä¸ªæ–‡æœ¬ä¼ ç»™Compromiseï¼Œè®©å®ƒæ ¹æ®ä¸Šä¸‹æ–‡åˆ¤æ–­è¯æ€§
                    const lemmaMap = this.getLemmasFromText(text);
                    
                    // æ”¶é›†éœ€è¦æ ‡æ³¨çš„å•è¯
                    const annotations = new Map();
                    for (const match of wordMatches) {
                        const word = match[0];
                        if (word.length < 2) continue;
                        
                        const lowerWord = word.toLowerCase();
                        // ä¼˜å…ˆä½¿ç”¨å¥å­ä¸Šä¸‹æ–‡ä¸­è·å–çš„lemmaå’Œè¯æ€§ï¼Œå¦åˆ™ä½¿ç”¨å•è¯æ¨¡å¼
                        const lemmaInfo = lemmaMap.get(lowerWord);
                        const lemma = lemmaInfo?.lemma || this.getLemma(word);
                        const pos = lemmaInfo?.pos || 'Unknown';
                        const rank = this.cocaRanks.get(lemma);
                        
                        if (rank && rank >= this.freqMin && rank <= this.freqMax) {
                            // è·³è¿‡å·²çŸ¥è¯æ±‡
                            if (this.knownWords.has(lemma)) {
                                continue;
                            }
                            
                            // æ£€æŸ¥è¿™ä¸ªè¯ï¼ˆæŒ‰lemmaï¼‰æ˜¯å¦åœ¨è¿‘æœŸæ®µè½å†…å·²æ ‡æ³¨è¿‡
                            const lastSeenParagraph = this.annotatedWordsHistory.get(lemma);
                            const isRecentlyAnnotated = lastSeenParagraph !== undefined && 
                                (this.currentParagraphIndex - lastSeenParagraph) <= CONFIG.READING.ANNOTATION_GAP;
                            
                            if (!isRecentlyAnnotated && !annotations.has(lowerWord)) {
                                // æŸ¥è¯¢ç¿»è¯‘ï¼šGoogleç”¨åŸè¯ï¼Œç¦»çº¿è¯å…¸å…ˆæŸ¥åŸè¯å†æŸ¥lemma
                                const cn = await this.getTranslation(lowerWord, lemma);
                                if (cn && cn !== lemma && cn !== lowerWord) {
                                    annotations.set(lowerWord, { cn, rank });
                                    this.annotatedWordsHistory.set(lemma, this.currentParagraphIndex); // è®°å½•è¯å‡ºç°çš„æ®µè½ç´¢å¼•
                                    console.log(`[æ ‡æ³¨] åŸè¯: ${word}, è¯æ€§: ${pos}, åŸå½¢: ${lemma}, COCAè¯é¢‘: ${rank}, ç¿»è¯‘: ${cn}`);
                                }
                            }
                        }
                    }
                    
                    // æ›¿æ¢æ–‡æœ¬ä¸ºå¸¦æµ®çª—çš„span
                    if (annotations.size > 0) {
                        // æ„å»ºæ­£åˆ™åŒ¹é…æ‰€æœ‰éœ€è¦æ ‡æ³¨çš„å•è¯
                        const wordsToMatch = Array.from(annotations.keys()).map(w => w.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
                        const regex = new RegExp(`\\b(${wordsToMatch.join('|')})\\b`, 'gi');
                        
                        // åˆ›å»ºæ–‡æ¡£ç‰‡æ®µ
                        const fragment = document.createDocumentFragment();
                        let lastIndex = 0;
                        let match;
                        
                        while ((match = regex.exec(text)) !== null) {
                            // æ·»åŠ åŒ¹é…å‰çš„æ–‡æœ¬
                            if (match.index > lastIndex) {
                                fragment.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
                            }
                            
                            // åˆ›å»ºå¸¦æµ®çª—çš„span
                            const word = match[1];
                            const info = annotations.get(word.toLowerCase());
                            if (info) {
                                const span = document.createElement('span');
                                span.className = info.rank < this.learningThreshold ? 'annotation-word low-freq' : 'annotation-word';
                                span.textContent = word;
                                
                                const tooltip = document.createElement('span');
                                tooltip.className = 'annotation-tooltip';
                                tooltip.textContent = `${info.cn} [COCA: ${info.rank}]`;
                                span.appendChild(tooltip);
                                
                                fragment.appendChild(span);
                            } else {
                                fragment.appendChild(document.createTextNode(word));
                            }
                            
                            lastIndex = regex.lastIndex;
                        }
                        
                        // æ·»åŠ å‰©ä½™æ–‡æœ¬
                        if (lastIndex < text.length) {
                            fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
                        }
                        
                        // æ›¿æ¢åŸèŠ‚ç‚¹
                        node.parentNode.replaceChild(fragment, node);
                    }
                }
            }

            // ä» localStorage åŠ è½½è®¾ç½®
            loadSettings() {
                const saved = localStorage.getItem('epubReaderSettings');
                const parsed = Utils.safeJsonParse(saved, {});
                this.settings = { ...CONFIG.DEFAULT_SETTINGS, ...parsed };
            }

            // ä¿å­˜è®¾ç½®åˆ° localStorage
            saveSettings() {
                localStorage.setItem('epubReaderSettings', JSON.stringify(this.settings));
            }

            // åº”ç”¨è®¾ç½®åˆ°ç•Œé¢
            applySettings() {
                const readerContent = document.getElementById('reader-content');
                
                // å­—ä½“
                if (this.settings.fontFamily === 'system') {
                    readerContent.style.fontFamily = "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif";
                } else {
                    readerContent.style.fontFamily = this.settings.fontFamily;
                }
                
                // å­—å·
                readerContent.style.fontSize = this.settings.fontSize + 'px';
                
                // è¡Œé«˜
                readerContent.style.lineHeight = this.settings.lineHeight;
                
                // å†…å®¹å®½åº¦
                readerContent.style.maxWidth = this.settings.contentWidth + 'px';
                
                // ä¾§è¾¹è·
                readerContent.style.paddingLeft = this.settings.padding + 'px';
                readerContent.style.paddingRight = this.settings.padding + 'px';
                
                // æ›´æ–°æ§ä»¶æ˜¾ç¤ºå€¼
                document.getElementById('font-family').value = this.settings.fontFamily;
                document.getElementById('font-size').value = this.settings.fontSize;
                document.getElementById('font-size-value').textContent = this.settings.fontSize + 'px';
                document.getElementById('line-height').value = this.settings.lineHeight;
                document.getElementById('line-height-value').textContent = this.settings.lineHeight;
                document.getElementById('content-width').value = this.settings.contentWidth;
                document.getElementById('content-width-value').textContent = this.settings.contentWidth + 'px';
                document.getElementById('padding').value = this.settings.padding;
                document.getElementById('padding-value').textContent = this.settings.padding + 'px';
                
                // æ›´æ–°è¯æ±‡æ ‡æ³¨è®¾ç½®
                document.getElementById('annotation-toggle').checked = this.annotationEnabled;
                document.getElementById('freq-min').value = this.freqMin;
                document.getElementById('freq-max').value = this.freqMax;
                document.getElementById('learning-threshold').value = this.learningThreshold;
                document.getElementById('offline-dict-priority').checked = this.offlineDictPriority;
                this.updateFreqRangeVisibility();
            }

            // åˆå§‹åŒ–è®¾ç½®é¢æ¿äº‹ä»¶
            initSettingsListeners() {
                const settingsBtn = document.getElementById('settings-btn');
                const settingsPanel = document.getElementById('settings-panel');
                const settingsOverlay = document.getElementById('settings-overlay');

                // æ‰“å¼€/å…³é—­è®¾ç½®é¢æ¿
                settingsBtn.addEventListener('click', () => {
                    settingsPanel.classList.toggle('active');
                    settingsOverlay.classList.toggle('active');
                    // æ›´æ–°è¯å…¸çŠ¶æ€æ˜¾ç¤º
                    if (settingsPanel.classList.contains('active')) {
                        this.updateDictStatus();
                    }
                });

                settingsOverlay.addEventListener('click', () => {
                    settingsPanel.classList.remove('active');
                    settingsOverlay.classList.remove('active');
                });

                // å­—ä½“é€‰æ‹©
                document.getElementById('font-family').addEventListener('change', (e) => {
                    this.settings.fontFamily = e.target.value;
                    this.applySettings();
                    this.saveSettings();
                });

                // å­—å·æ»‘å—
                document.getElementById('font-size').addEventListener('input', (e) => {
                    this.settings.fontSize = parseInt(e.target.value);
                    this.applySettings();
                    this.saveSettings();
                });

                // è¡Œé«˜æ»‘å—
                document.getElementById('line-height').addEventListener('input', (e) => {
                    this.settings.lineHeight = parseFloat(e.target.value);
                    this.applySettings();
                    this.saveSettings();
                });

                // å†…å®¹å®½åº¦æ»‘å—
                document.getElementById('content-width').addEventListener('input', (e) => {
                    this.settings.contentWidth = parseInt(e.target.value);
                    this.applySettings();
                    this.saveSettings();
                });

                // ä¾§è¾¹è·æ»‘å—
                document.getElementById('padding').addEventListener('input', (e) => {
                    this.settings.padding = parseInt(e.target.value);
                    this.applySettings();
                    this.saveSettings();
                });

                // è¯æ±‡æ ‡æ³¨å¼€å…³
                document.getElementById('annotation-toggle').addEventListener('change', (e) => {
                    this.annotationEnabled = e.target.checked;
                    this.saveAnnotationSettings();
                    this.updateFreqRangeVisibility();
                });

                // è¯é¢‘èŒƒå›´è®¾ç½®
                document.getElementById('freq-min').addEventListener('change', (e) => {
                    const value = parseInt(e.target.value);
                    if (value >= 1 && value <= 60000 && value < this.freqMax) {
                        this.freqMin = value;
                        this.saveAnnotationSettings();
                    } else {
                        e.target.value = this.freqMin;
                    }
                });

                document.getElementById('freq-max').addEventListener('change', (e) => {
                    const value = parseInt(e.target.value);
                    if (value >= 1 && value <= 60000 && value > this.freqMin) {
                        this.freqMax = value;
                        this.saveAnnotationSettings();
                    } else {
                        e.target.value = this.freqMax;
                    }
                });

                // å­¦ä¹ è¯é¢‘é˜ˆå€¼è®¾ç½®
                document.getElementById('learning-threshold').addEventListener('change', (e) => {
                    const value = parseInt(e.target.value);
                    if (value >= 1 && value <= 60000) {
                        this.learningThreshold = value;
                        this.saveAnnotationSettings();
                    } else {
                        e.target.value = this.learningThreshold;
                    }
                });
                
                // ç¦»çº¿è¯å…¸é‡æ–°åŠ è½½æŒ‰é’®
                document.getElementById('reload-dict-btn').addEventListener('click', async () => {
                    await this.loadOfflineDict(true);
                });
                
                // ç¦»çº¿è¯å…¸ä¼˜å…ˆå¼€å…³
                document.getElementById('offline-dict-priority').addEventListener('change', (e) => {
                    this.offlineDictPriority = e.target.checked;
                    this.saveAnnotationSettings();
                });
            }
            
            // æ›´æ–°è¯å…¸çŠ¶æ€æ˜¾ç¤º
            updateDictStatus(message = null) {
                const statusEl = document.getElementById('dict-status');
                if (statusEl) {
                    if (message) {
                        statusEl.textContent = message;
                        statusEl.style.color = '#f39c12';
                    } else if (this.offlineDictLoaded && this.offlineDict.size > 0) {
                        statusEl.textContent = `å·²åŠ è½½ ${this.offlineDict.size} ä¸ªè¯æ¡`;
                        statusEl.style.color = '#27ae60';
                    } else {
                        statusEl.textContent = 'æœªåŠ è½½';
                        statusEl.style.color = '#95a5a6';
                    }
                }
            }

            // æ›´æ–°è¯é¢‘èŒƒå›´è®¾ç½®çš„å¯è§æ€§
            updateFreqRangeVisibility() {
                const freqRangeGroup = document.getElementById('freq-range-group');
                const learningThresholdGroup = document.getElementById('learning-threshold-group');
                if (freqRangeGroup) {
                    freqRangeGroup.style.display = this.annotationEnabled ? 'block' : 'none';
                }
                if (learningThresholdGroup) {
                    learningThresholdGroup.style.display = this.annotationEnabled ? 'block' : 'none';
                }
            }

            initEventListeners() {
                // æ–‡ä»¶ä¸Šä¼ 
                document.getElementById('file-input').addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.loadFile(e.target.files[0]);
                    }
                });

                // ä¾§è¾¹æ åˆ‡æ¢
                document.getElementById('toggle-sidebar').addEventListener('click', () => {
                    document.getElementById('sidebar').classList.toggle('collapsed');
                });

                // æ‹–æ”¾æ”¯æŒ
                const dropZone = document.getElementById('drop-zone');
                const container = document.getElementById('reader-container');

                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    container.addEventListener(eventName, (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });

                container.addEventListener('dragenter', () => dropZone.classList.add('drag-over'));
                container.addEventListener('dragleave', () => dropZone.classList.remove('drag-over'));
                container.addEventListener('drop', (e) => {
                    dropZone.classList.remove('drag-over');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        const fileName = files[0].name.toLowerCase();
                        if (fileName.endsWith('.epub') || fileName.endsWith('.pdf')) {
                            this.loadFile(files[0]);
                        }
                    }
                });

                // æ»šåŠ¨æ—¶æ›´æ–°ç›®å½•é«˜äº®å’Œè¿›åº¦ - ä½¿ç”¨èŠ‚æµå’Œé˜²æŠ–ä¼˜åŒ–æ€§èƒ½
                const throttledUpdate = Utils.throttle(() => {
                    this.updateActiveTocItem();
                    this.updateProgress();
                }, 100);
                
                const debouncedSave = Utils.debounce(() => {
                    this.saveReadingProgress();
                }, CONFIG.INTERVALS.SAVE_DEBOUNCE);
                
                document.getElementById('reader-container').addEventListener('scroll', () => {
                    throttledUpdate();
                    debouncedSave();
                }, { passive: true });

                // ä¹¦æ¶æŒ‰é’®
                document.getElementById('library-btn').addEventListener('click', () => {
                    this.showLibrary();
                });

                // è¯æ±‡è¡¨æŒ‰é’®
                document.getElementById('vocab-btn').addEventListener('click', () => {
                    this.showVocabularyModal();
                });

                // é€‰è¯æµ®åŠ¨æŒ‰é’®
                this.initWordSelection();
            }

            // åˆå§‹åŒ–é€‰è¯åŠŸèƒ½
            initWordSelection() {
                const wordActionBtn = document.getElementById('word-action-btn');
                const readerContainer = document.getElementById('reader-container');

                // ç›‘å¬é¼ æ ‡æŠ¬èµ·äº‹ä»¶ï¼ˆæ–‡æœ¬é€‰æ‹©ç»“æŸï¼‰
                readerContainer.addEventListener('mouseup', (e) => {
                    // å»¶è¿Ÿå¤„ç†ï¼Œç¡®ä¿é€‰åŒºå·²ç»å»ºç«‹
                    setTimeout(() => {
                        this.handleTextSelection(e);
                    }, 10);
                });

                // ç›‘å¬ç‚¹å‡»äº‹ä»¶éšè—æŒ‰é’®
                document.addEventListener('mousedown', (e) => {
                    if (e.target !== wordActionBtn) {
                        this.hideWordActionBtn();
                    }
                });

                // ç‚¹å‡»æµ®åŠ¨æŒ‰é’®
                wordActionBtn.addEventListener('click', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (this.selectedWordInfo) {
                        await this.toggleKnownWord(this.selectedWordInfo.lemma);
                    }
                });
            }

            // å¤„ç†æ–‡æœ¬é€‰æ‹©
            handleTextSelection(e) {
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();

                // æ£€æŸ¥æ˜¯å¦é€‰ä¸­äº†å•ä¸ªå•è¯
                if (!selectedText || !/^[a-zA-Z]+(?:-[a-zA-Z]+)?$/.test(selectedText)) {
                    this.hideWordActionBtn();
                    return;
                }

                // è·å–å•è¯çš„åŸå½¢
                const lemma = this.getLemma(selectedText);
                const isKnown = this.knownWords.has(lemma.toLowerCase());

                // ä¿å­˜é€‰ä¸­ä¿¡æ¯
                this.selectedWordInfo = {
                    word: selectedText,
                    lemma: lemma.toLowerCase(),
                    isKnown: isKnown
                };

                // æ˜¾ç¤ºæµ®åŠ¨æŒ‰é’®
                this.showWordActionBtn(e.clientX, e.clientY, isKnown);
            }

            // æ˜¾ç¤ºé€‰è¯æµ®åŠ¨æŒ‰é’®
            showWordActionBtn(x, y, isKnown) {
                const btn = document.getElementById('word-action-btn');
                
                // æ›´æ–°æŒ‰é’®æ–‡æœ¬å’Œæ ·å¼
                if (isKnown) {
                    btn.textContent = '- ä»è¯æ±‡è¡¨ç§»é™¤';
                    btn.classList.add('remove');
                } else {
                    btn.textContent = '+ åŠ å…¥è¯æ±‡è¡¨';
                    btn.classList.remove('remove');
                }

                // è®¡ç®—æŒ‰é’®ä½ç½®ï¼ˆåœ¨é€‰åŒºä¸Šæ–¹æˆ–ä¸‹æ–¹ï¼‰
                const btnHeight = 36;
                const btnWidth = 130;
                let posX = x - btnWidth / 2;
                let posY = y - btnHeight - 10;

                // ç¡®ä¿ä¸è¶…å‡ºå±å¹•è¾¹ç•Œ
                posX = Math.max(10, Math.min(posX, window.innerWidth - btnWidth - 10));
                if (posY < 10) {
                    posY = y + 20; // å¦‚æœä¸Šæ–¹ç©ºé—´ä¸è¶³ï¼Œæ˜¾ç¤ºåœ¨ä¸‹æ–¹
                }

                btn.style.left = posX + 'px';
                btn.style.top = posY + 'px';
                btn.style.display = 'block';
            }

            // éšè—é€‰è¯æµ®åŠ¨æŒ‰é’®
            hideWordActionBtn() {
                const btn = document.getElementById('word-action-btn');
                btn.style.display = 'none';
                this.selectedWordInfo = null;
            }

            // åˆ‡æ¢å·²çŸ¥è¯æ±‡çŠ¶æ€
            async toggleKnownWord(lemma) {
                const lowerLemma = lemma.toLowerCase();
                
                try {
                    if (this.knownWords.has(lowerLemma)) {
                        // ä»å·²çŸ¥è¯æ±‡ä¸­ç§»é™¤
                        await this.bookStorage.removeKnownWord(lowerLemma);
                        this.knownWords.delete(lowerLemma);
                        console.log(`å·²ä»è¯æ±‡è¡¨ç§»é™¤: ${lowerLemma}`);
                    } else {
                        // æ·»åŠ åˆ°å·²çŸ¥è¯æ±‡
                        await this.bookStorage.addKnownWord(lowerLemma);
                        this.knownWords.add(lowerLemma);
                        console.log(`å·²åŠ å…¥è¯æ±‡è¡¨: ${lowerLemma}`);
                    }
                } catch (e) {
                    console.error('æ›´æ–°è¯æ±‡è¡¨å¤±è´¥:', e);
                }

                this.hideWordActionBtn();
                // æ¸…é™¤é€‰åŒº
                window.getSelection().removeAllRanges();
            }

            // æ˜¾ç¤ºè¯æ±‡è¡¨æ¨¡æ€æ¡†
            async showVocabularyModal() {
                const words = await this.bookStorage.getAllKnownWords();
                this.renderVocabularyModal(words);
            }

            // æ¸²æŸ“è¯æ±‡è¡¨æ¨¡æ€æ¡†
            renderVocabularyModal(words, filterText = '') {
                // è¿‡æ»¤è¯æ±‡
                const filteredWords = filterText 
                    ? words.filter(w => w.lemma.includes(filterText.toLowerCase()))
                    : words;

                const modal = document.createElement('div');
                modal.className = 'vocab-modal';
                modal.id = 'vocab-modal';
                modal.innerHTML = `
                    <div class="vocab-content">
                        <div class="vocab-header">
                            <h2>å·²çŸ¥è¯æ±‡è¡¨</h2>
                            <div class="vocab-header-actions">
                                <input type="text" class="vocab-search" id="vocab-search" placeholder="æœç´¢è¯æ±‡..." value="${filterText}">
                                <button class="vocab-close" id="vocab-close">âœ•</button>
                            </div>
                        </div>
                        <div class="vocab-stats">
                            å…± ${words.length} ä¸ªè¯æ±‡${filterText ? `ï¼Œæ˜¾ç¤º ${filteredWords.length} ä¸ªåŒ¹é…ç»“æœ` : ''}
                        </div>
                        <div class="vocab-list" id="vocab-list">
                            ${filteredWords.length === 0 ? `
                                <div class="vocab-empty">
                                    ${filterText ? 'æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„è¯æ±‡' : 'è¯æ±‡è¡¨ä¸ºç©ºï¼Œé€‰ä¸­å•è¯åç‚¹å‡»"åŠ å…¥è¯æ±‡è¡¨"æŒ‰é’®æ·»åŠ '}
                                </div>
                            ` : filteredWords.map(word => `
                                <div class="vocab-word" data-lemma="${word.lemma}">
                                    <span class="vocab-word-text">${word.lemma}</span>
                                    <div class="vocab-word-meta">
                                        <span class="vocab-word-date">${this.formatDate(word.addedAt)}</span>
                                        <button class="vocab-word-delete" data-lemma="${word.lemma}">åˆ é™¤</button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <div class="vocab-footer">
                            <button class="vocab-export-btn" id="vocab-export">å¯¼å‡ºè¯æ±‡è¡¨</button>
                            <button class="vocab-clear-btn" id="vocab-clear">æ¸…ç©ºå…¨éƒ¨</button>
                        </div>
                    </div>
                `;

                // ç§»é™¤å·²å­˜åœ¨çš„æ¨¡æ€æ¡†
                const existingModal = document.getElementById('vocab-modal');
                if (existingModal) {
                    existingModal.remove();
                }

                document.body.appendChild(modal);

                // å…³é—­æŒ‰é’®
                document.getElementById('vocab-close').addEventListener('click', () => {
                    modal.remove();
                });

                // ç‚¹å‡»èƒŒæ™¯å…³é—­
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });

                // æœç´¢åŠŸèƒ½
                let searchTimeout = null;
                document.getElementById('vocab-search').addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        modal.remove();
                        this.renderVocabularyModal(words, e.target.value);
                        // èšç„¦åˆ°æœç´¢æ¡†å¹¶ä¿æŒå…‰æ ‡ä½ç½®
                        const searchInput = document.getElementById('vocab-search');
                        if (searchInput) {
                            searchInput.focus();
                            searchInput.setSelectionRange(e.target.value.length, e.target.value.length);
                        }
                    }, 300);
                });

                // åˆ é™¤å•ä¸ªè¯æ±‡
                modal.querySelectorAll('.vocab-word-delete').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const lemma = btn.dataset.lemma;
                        await this.bookStorage.removeKnownWord(lemma);
                        this.knownWords.delete(lemma);
                        btn.closest('.vocab-word').remove();
                        // æ›´æ–°ç»Ÿè®¡
                        const statsEl = modal.querySelector('.vocab-stats');
                        const newWords = await this.bookStorage.getAllKnownWords();
                        const newFiltered = filterText 
                            ? newWords.filter(w => w.lemma.includes(filterText.toLowerCase()))
                            : newWords;
                        statsEl.textContent = `å…± ${newWords.length} ä¸ªè¯æ±‡${filterText ? `ï¼Œæ˜¾ç¤º ${newFiltered.length} ä¸ªåŒ¹é…ç»“æœ` : ''}`;
                        
                        // å¦‚æœåˆ—è¡¨ä¸ºç©ºï¼Œæ˜¾ç¤ºç©ºçŠ¶æ€
                        if (newFiltered.length === 0) {
                            document.getElementById('vocab-list').innerHTML = `
                                <div class="vocab-empty">
                                    ${filterText ? 'æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„è¯æ±‡' : 'è¯æ±‡è¡¨ä¸ºç©ºï¼Œé€‰ä¸­å•è¯åç‚¹å‡»"åŠ å…¥è¯æ±‡è¡¨"æŒ‰é’®æ·»åŠ '}
                                </div>
                            `;
                        }
                    });
                });

                // å¯¼å‡ºè¯æ±‡è¡¨
                document.getElementById('vocab-export').addEventListener('click', () => {
                    this.exportVocabulary(words);
                });

                // æ¸…ç©ºå…¨éƒ¨
                document.getElementById('vocab-clear').addEventListener('click', async () => {
                    if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å·²çŸ¥è¯æ±‡å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚')) {
                        await this.bookStorage.clearAllKnownWords();
                        this.knownWords.clear();
                        modal.remove();
                        this.showVocabularyModal();
                    }
                });
            }

            // æ ¼å¼åŒ–æ—¥æœŸ - ä½¿ç”¨å·¥å…·å‡½æ•°
            formatDate(timestamp) {
                return Utils.formatDate(timestamp);
            }

            // å¯¼å‡ºè¯æ±‡è¡¨
            exportVocabulary(words) {
                const content = words.map(w => w.lemma).join('\n');
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `vocabulary_${new Date().toISOString().slice(0,10)}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // æ›´æ–°é˜…è¯»è¿›åº¦
            updateProgress() {
                const container = document.getElementById('reader-container');
                const readerContent = document.getElementById('reader-content');
                
                if (readerContent.style.display === 'none') return;
                
                const scrollTop = container.scrollTop;
                const scrollHeight = container.scrollHeight - container.clientHeight;
                
                let progress = 0;
                if (scrollHeight > 0) {
                    progress = Math.min(100, Math.round((scrollTop / scrollHeight) * 100));
                }
                
                document.getElementById('progress-bar').style.width = progress + '%';
                document.getElementById('progress-text').textContent = progress + '%';
            }

            showLoading(show) {
                document.getElementById('loading').classList.toggle('active', show);
            }

            // æ ¹æ®æ–‡ä»¶ç±»å‹åŠ è½½æ–‡ä»¶
            async loadFile(file) {
                const fileName = file.name.toLowerCase();
                if (fileName.endsWith('.pdf')) {
                    await this.loadPDF(file);
                } else if (fileName.endsWith('.epub')) {
                    await this.loadEPUB(file);
                } else {
                    alert('ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ï¼Œè¯·ä¸Šä¼  EPUB æˆ– PDF æ–‡ä»¶ã€‚');
                }
            }

            async loadEPUB(file) {
                this.showLoading(true);
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    this.currentFileName = file.name;
                    
                    // å…ˆè§£æè·å–å…ƒæ•°æ®
                    const tempZip = await JSZip.loadAsync(arrayBuffer);
                    const containerXml = await tempZip.file('META-INF/container.xml').async('text');
                    const containerDoc = new DOMParser().parseFromString(containerXml, 'application/xml');
                    const opfPath = containerDoc.querySelector('rootfile').getAttribute('full-path');
                    const opfContent = await tempZip.file(opfPath).async('text');
                    const opfDoc = new DOMParser().parseFromString(opfContent, 'application/xml');
                    const metadataEl = opfDoc.querySelector('metadata');
                    const metadata = {
                        title: metadataEl?.querySelector('title')?.textContent || file.name,
                        author: metadataEl?.querySelector('creator')?.textContent || ''
                    };
                    
                    // ä¿å­˜åˆ° IndexedDB
                    try {
                        const bookId = await this.bookStorage.saveBook(arrayBuffer, file.name, metadata);
                        this.currentBookId = bookId;
                        this.bookStorage.setLastBookId(bookId);
                    } catch (e) {
                        console.warn('æ— æ³•ä¿å­˜ä¹¦ç±åˆ°å­˜å‚¨:', e);
                    }
                    
                    // é‡ç½®é˜…è¯»æ—¶é—´å’Œæ»šåŠ¨ä½ç½®ï¼ˆæ–°æ–‡ä»¶ï¼‰
                    this.pendingScrollPosition = null;
                    this.totalReadingTime = 0;
                    
                    await this.loadEPUBFromArrayBuffer(arrayBuffer, file.name, false);
                } catch (error) {
                    console.error('åŠ è½½ EPUB å¤±è´¥:', error);
                    alert('åŠ è½½ EPUB æ–‡ä»¶å¤±è´¥ï¼Œè¯·ç¡®ä¿æ–‡ä»¶æ ¼å¼æ­£ç¡®ã€‚');
                    this.showLoading(false);
                }
            }

            async loadEPUBFromArrayBuffer(arrayBuffer, fileName, isReload = false) {
                this.showLoading(true);
                try {
                    this.zip = await JSZip.loadAsync(arrayBuffer);
                    
                    // è§£æ container.xml è·å– OPF è·¯å¾„
                    const containerXml = await this.zip.file('META-INF/container.xml').async('text');
                    const containerDoc = new DOMParser().parseFromString(containerXml, 'application/xml');
                    this.opfPath = containerDoc.querySelector('rootfile').getAttribute('full-path');
                    this.opfDir = this.opfPath.substring(0, this.opfPath.lastIndexOf('/') + 1);

                    // è§£æ OPF æ–‡ä»¶
                    const opfContent = await this.zip.file(this.opfPath).async('text');
                    const opfDoc = new DOMParser().parseFromString(opfContent, 'application/xml');
                    
                    this.parseMetadata(opfDoc);
                    this.parseManifest(opfDoc);
                    this.parseSpine(opfDoc);
                    await this.parseTOC(opfDoc);
                    
                    await this.renderBook();
                    this.renderTOC();
                    
                    document.getElementById('book-title').textContent = this.metadata.title || fileName;
                    document.getElementById('welcome-screen').style.display = 'none';
                    document.getElementById('reader-content').style.display = 'block';
                    document.getElementById('progress-indicator').style.display = 'flex';
                    document.getElementById('time-indicator').classList.add('active');
                    
                    // è®¡ç®—æ€»å•è¯æ•°ï¼ˆæŒ‰è‹±æ–‡å•è¯æ•°é‡ï¼‰
                    const readerContent = document.getElementById('reader-content');
                    this.totalCharacters = this.countWords(readerContent.textContent);
                    
                    // æ˜¾ç¤ºæ€»å­—æ•°
                    this.updateWordCountDisplay();
                    
                    // å¼€å§‹é˜…è¯»é€Ÿåº¦è·Ÿè¸ª
                    this.startSpeedTracking();
                    
                    // åˆå§‹åŒ–æ‡’åŠ è½½è¯æ±‡æ ‡æ³¨
                    this.initAnnotationObserver();
                    
                    // å¼€å§‹é˜…è¯»æ—¶é—´è·Ÿè¸ª
                    this.startReadingTime();
                    this.updateTimeDisplay();
                    
                    // æ¢å¤é˜…è¯»ä½ç½®
                    if (this.pendingScrollPosition !== null) {
                        const container = document.getElementById('reader-container');
                        // ä½¿ç”¨ requestAnimationFrame ç¡®ä¿ DOM å·²æ¸²æŸ“
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                container.scrollTop = this.pendingScrollPosition;
                                this.pendingScrollPosition = null;
                                this.updateProgress();
                                this.updateActiveTocItem();
                            });
                        });
                    } else {
                        this.updateProgress();
                    }
                } catch (error) {
                    console.error('åŠ è½½ EPUB å¤±è´¥:', error);
                    alert('åŠ è½½ EPUB æ–‡ä»¶å¤±è´¥ï¼Œè¯·ç¡®ä¿æ–‡ä»¶æ ¼å¼æ­£ç¡®ã€‚');
                } finally {
                    this.showLoading(false);
                }
            }

            // PDF åŠ è½½æ–¹æ³•
            async loadPDF(file) {
                this.showLoading(true);
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    this.currentFileName = file.name;
                    this.currentFileType = 'pdf';
                    
                    // å¤åˆ¶ ArrayBuffer ç”¨äºå­˜å‚¨ï¼ˆå› ä¸º PDF.js ä¼š detach åŸå§‹ bufferï¼‰
                    const arrayBufferCopy = arrayBuffer.slice(0);
                    
                    // è®¾ç½® PDF.js worker
                    pdfjsLib.GlobalWorkerOptions.workerSrc = CONFIG.URLS.PDF_WORKER;
                    
                    // åŠ è½½ PDF æ–‡æ¡£è·å–å…ƒæ•°æ®
                    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                    
                    // è·å– PDF å…ƒæ•°æ®
                    const pdfMetadata = await pdf.getMetadata().catch(() => ({}));
                    const metadata = {
                        title: pdfMetadata.info?.Title || file.name.replace(/\.pdf$/i, ''),
                        author: pdfMetadata.info?.Author || ''
                    };
                    
                    // ä¿å­˜åˆ° IndexedDBï¼ˆä½¿ç”¨å¤åˆ¶çš„ bufferï¼‰
                    try {
                        const bookId = await this.bookStorage.saveBook(arrayBufferCopy, file.name, metadata, 'pdf');
                        this.currentBookId = bookId;
                        this.bookStorage.setLastBookId(bookId);
                    } catch (e) {
                        console.warn('æ— æ³•ä¿å­˜ä¹¦ç±åˆ°å­˜å‚¨:', e);
                    }
                    
                    // é‡ç½®é˜…è¯»æ—¶é—´å’Œæ»šåŠ¨ä½ç½®ï¼ˆæ–°æ–‡ä»¶ï¼‰
                    this.pendingScrollPosition = null;
                    this.totalReadingTime = 0;
                    
                    // ç›´æ¥ä½¿ç”¨å·²åŠ è½½çš„ PDF æ–‡æ¡£æ¸²æŸ“
                    await this.renderPDFFromDocument(pdf, file.name, false);
                } catch (error) {
                    console.error('åŠ è½½ PDF å¤±è´¥:', error);
                    alert('åŠ è½½ PDF æ–‡ä»¶å¤±è´¥ï¼Œè¯·ç¡®ä¿æ–‡ä»¶æ ¼å¼æ­£ç¡®ã€‚');
                    this.showLoading(false);
                }
            }

            async loadPDFFromArrayBuffer(arrayBuffer, fileName, isReload = false) {
                this.showLoading(true);
                try {
                    // è®¾ç½® PDF.js worker
                    pdfjsLib.GlobalWorkerOptions.workerSrc = CONFIG.URLS.PDF_WORKER;
                    
                    // å¤åˆ¶ ArrayBufferï¼ˆé˜²æ­¢è¢« detachï¼‰
                    const bufferCopy = arrayBuffer.slice(0);
                    
                    // åŠ è½½ PDF æ–‡æ¡£
                    const pdf = await pdfjsLib.getDocument({ data: bufferCopy }).promise;
                    
                    await this.renderPDFFromDocument(pdf, fileName, isReload);
                } catch (error) {
                    console.error('åŠ è½½ PDF å¤±è´¥:', error);
                    alert('åŠ è½½ PDF æ–‡ä»¶å¤±è´¥ï¼Œè¯·ç¡®ä¿æ–‡ä»¶æ ¼å¼æ­£ç¡®ã€‚');
                    this.showLoading(false);
                }
            }

            // ä»å·²åŠ è½½çš„ PDF æ–‡æ¡£æ¸²æŸ“å†…å®¹
            async renderPDFFromDocument(pdf, fileName, isReload = false) {
                try {
                    this.pdfDoc = pdf;
                    const numPages = this.pdfDoc.numPages;
                    
                    // è·å–å…ƒæ•°æ®
                    const pdfMetadata = await this.pdfDoc.getMetadata().catch(() => ({}));
                    this.metadata = {
                        title: pdfMetadata.info?.Title || fileName.replace(/\.pdf$/i, ''),
                        creator: pdfMetadata.info?.Author || '',
                        language: ''
                    };
                    
                    // æ¸…ç©ºç›®å½•ï¼ˆPDF ç›®å½•ç¨åå¤„ç†ï¼‰
                    this.toc = [];
                    this.chapterElements = [];
                    
                    // æ¸²æŸ“æ‰€æœ‰é¡µé¢çš„æ–‡æœ¬å†…å®¹
                    const readerContent = document.getElementById('reader-content');
                    readerContent.innerHTML = '';
                    
                    for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                        const page = await this.pdfDoc.getPage(pageNum);
                        const textContent = await page.getTextContent();
                        
                        // åˆ›å»ºç« èŠ‚å®¹å™¨
                        const chapterDiv = document.createElement('div');
                        chapterDiv.className = 'chapter';
                        chapterDiv.id = `pdf-page-${pageNum}`;
                        
                        // æ·»åŠ é¡µç æ ‡é¢˜
                        const pageHeader = document.createElement('div');
                        pageHeader.className = 'pdf-page-header';
                        pageHeader.style.cssText = 'text-align: center; color: #999; font-size: 12px; margin-bottom: 20px; padding-top: 20px; border-top: 1px solid #eee;';
                        pageHeader.textContent = `ç¬¬ ${pageNum} é¡µ`;
                        if (pageNum > 1) {
                            chapterDiv.appendChild(pageHeader);
                        }
                        
                        // å¤„ç†æ–‡æœ¬å†…å®¹ - æ™ºèƒ½æ®µè½æ£€æµ‹
                        let currentParagraph = document.createElement('p');
                        let paragraphText = '';
                        
                        // é¦–å…ˆæ”¶é›†æ‰€æœ‰æ–‡æœ¬é¡¹å¹¶è®¡ç®—å…¸å‹è¡Œé«˜
                        const textItems = textContent.items.filter(item => item.str.trim() !== '');
                        
                        // è®¡ç®—è¡Œé«˜ï¼šåˆ†æè¿ç»­è¡Œä¹‹é—´çš„ Y åæ ‡å·®å€¼
                        const lineGaps = [];
                        for (let i = 1; i < textItems.length; i++) {
                            const gap = Math.abs(textItems[i].transform[5] - textItems[i-1].transform[5]);
                            if (gap > 0 && gap < 100) { // å¿½ç•¥åŒä¸€è¡Œçš„é¡¹ç›®å’Œè¿‡å¤§çš„è·³è·ƒ
                                lineGaps.push(gap);
                            }
                        }
                        
                        // ä½¿ç”¨ä¸­ä½æ•°æˆ–å¹³å‡å€¼ä½œä¸ºå…¸å‹è¡Œé«˜
                        let typicalLineHeight = 14; // é»˜è®¤å€¼
                        if (lineGaps.length > 0) {
                            lineGaps.sort((a, b) => a - b);
                            // å–ä¸­ä½æ•°é™„è¿‘çš„å€¼ä½œä¸ºå…¸å‹è¡Œé«˜
                            const midIndex = Math.floor(lineGaps.length / 2);
                            typicalLineHeight = lineGaps[midIndex];
                        }
                        
                        // æ®µè½é—´è·é˜ˆå€¼ï¼šå…¸å‹è¡Œé«˜çš„ 1.8 å€
                        const paragraphThreshold = typicalLineHeight * 1.8;
                        
                        let lastY = null;
                        let lastX = null;
                        
                        for (const item of textItems) {
                            const currentY = item.transform[5];
                            const currentX = item.transform[4];
                            
                            // æ£€æµ‹æ˜¯å¦éœ€è¦æ¢æ®µè½
                            let shouldBreak = false;
                            
                            if (lastY !== null) {
                                const yGap = Math.abs(currentY - lastY);
                                
                                // æ¡ä»¶1ï¼šY åæ ‡å·®å€¼è¶…è¿‡æ®µè½é˜ˆå€¼
                                if (yGap > paragraphThreshold) {
                                    shouldBreak = true;
                                }
                                
                                // æ¡ä»¶2ï¼šæ–°è¡Œä¸” X åæ ‡æœ‰æ˜æ˜¾ç¼©è¿›ï¼ˆå¯èƒ½æ˜¯æ–°æ®µè½ï¼‰
                                // åŒæ—¶ Y åæ ‡å˜åŒ–è¶…è¿‡æ™®é€šè¡Œé«˜
                                if (yGap > typicalLineHeight * 0.8 && lastX !== null) {
                                    const xDiff = currentX - lastX;
                                    // å¦‚æœæ–°è¡Œæœ‰æ˜æ˜¾ç¼©è¿›ï¼ˆè¶…è¿‡20åƒç´ ï¼‰ï¼Œå¯èƒ½æ˜¯æ–°æ®µè½
                                    if (xDiff > 20) {
                                        shouldBreak = true;
                                    }
                                }
                            }
                            
                            if (shouldBreak && paragraphText.trim()) {
                                currentParagraph.textContent = paragraphText.trim();
                                chapterDiv.appendChild(currentParagraph);
                                currentParagraph = document.createElement('p');
                                paragraphText = '';
                            }
                            
                            // å¦‚æœæ˜¯åŒä¸€è¡Œå†…çš„æ–‡æœ¬ï¼Œç›´æ¥è¿æ¥
                            // å¦‚æœæ˜¯æ¢è¡Œï¼Œæ·»åŠ ç©ºæ ¼è¿æ¥ï¼ˆé¿å…å•è¯ç²˜è¿ï¼‰
                            if (lastY !== null && Math.abs(currentY - lastY) > 2) {
                                // æ¢è¡Œäº†ï¼Œç¡®ä¿æœ‰ç©ºæ ¼
                                if (paragraphText && !paragraphText.endsWith(' ') && !paragraphText.endsWith('-')) {
                                    paragraphText += ' ';
                                }
                            }
                            
                            paragraphText += item.str;
                            lastY = currentY;
                            lastX = currentX;
                        }
                        
                        // æ·»åŠ æœ€åä¸€ä¸ªæ®µè½
                        if (paragraphText.trim()) {
                            currentParagraph.textContent = paragraphText.trim();
                            chapterDiv.appendChild(currentParagraph);
                        }
                        
                        readerContent.appendChild(chapterDiv);
                        
                        // æ·»åŠ åˆ°ç« èŠ‚å…ƒç´ æ•°ç»„ç”¨äºç›®å½•å¯¼èˆª
                        this.chapterElements.push({
                            element: chapterDiv,
                            href: `pdf-page-${pageNum}`
                        });
                        
                        // ä¸º PDF ç”Ÿæˆç®€å•ç›®å½•ï¼ˆæ¯é¡µä¸€ä¸ªæ¡ç›®ï¼‰
                        this.toc.push({
                            label: `ç¬¬ ${pageNum} é¡µ`,
                            href: `pdf-page-${pageNum}`,
                            level: 1
                        });
                    }
                    
                    // å°è¯•è·å– PDF å¤§çº²ï¼ˆä¹¦ç­¾ï¼‰
                    try {
                        const outline = await this.pdfDoc.getOutline();
                        if (outline && outline.length > 0) {
                            this.toc = [];
                            await this.parsePDFOutline(outline, 1);
                        }
                    } catch (e) {
                        console.warn('æ— æ³•è·å– PDF å¤§çº²:', e);
                    }
                    
                    this.renderTOC();
                    
                    document.getElementById('book-title').textContent = this.metadata.title || fileName;
                    document.getElementById('welcome-screen').style.display = 'none';
                    document.getElementById('reader-content').style.display = 'block';
                    document.getElementById('progress-indicator').style.display = 'flex';
                    document.getElementById('time-indicator').classList.add('active');
                    
                    // è®¡ç®—æ€»å•è¯æ•°
                    this.totalCharacters = this.countWords(readerContent.textContent);
                    
                    // æ˜¾ç¤ºæ€»å­—æ•°
                    this.updateWordCountDisplay();
                    
                    // å¼€å§‹é˜…è¯»é€Ÿåº¦è·Ÿè¸ª
                    this.startSpeedTracking();
                    
                    // åˆå§‹åŒ–æ‡’åŠ è½½è¯æ±‡æ ‡æ³¨
                    this.initAnnotationObserver();
                    
                    // å¼€å§‹é˜…è¯»æ—¶é—´è·Ÿè¸ª
                    this.startReadingTime();
                    this.updateTimeDisplay();
                    
                    // æ¢å¤é˜…è¯»ä½ç½®
                    if (this.pendingScrollPosition !== null) {
                        const container = document.getElementById('reader-container');
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                container.scrollTop = this.pendingScrollPosition;
                                this.pendingScrollPosition = null;
                                this.updateProgress();
                                this.updateActiveTocItem();
                            });
                        });
                    } else {
                        this.updateProgress();
                    }
                } catch (error) {
                    console.error('æ¸²æŸ“ PDF å¤±è´¥:', error);
                    alert('æ¸²æŸ“ PDF æ–‡ä»¶å¤±è´¥ã€‚');
                } finally {
                    this.showLoading(false);
                }
            }

            // è§£æ PDF å¤§çº²ï¼ˆä¹¦ç­¾ï¼‰
            async parsePDFOutline(outline, level) {
                for (const item of outline) {
                    let pageNum = 1;
                    try {
                        if (item.dest) {
                            let dest = item.dest;
                            if (typeof dest === 'string') {
                                dest = await this.pdfDoc.getDestination(dest);
                            }
                            if (dest && dest[0]) {
                                const pageIndex = await this.pdfDoc.getPageIndex(dest[0]);
                                pageNum = pageIndex + 1;
                            }
                        }
                    } catch (e) {
                        console.warn('æ— æ³•è§£æä¹¦ç­¾ç›®æ ‡:', e);
                    }
                    
                    this.toc.push({
                        label: item.title,
                        href: `pdf-page-${pageNum}`,
                        level: level
                    });
                    
                    if (item.items && item.items.length > 0) {
                        await this.parsePDFOutline(item.items, level + 1);
                    }
                }
            }

            parseMetadata(opfDoc) {
                const metadata = opfDoc.querySelector('metadata');
                this.metadata = {
                    title: metadata.querySelector('title')?.textContent || '',
                    creator: metadata.querySelector('creator')?.textContent || '',
                    language: metadata.querySelector('language')?.textContent || ''
                };
            }

            parseManifest(opfDoc) {
                this.manifest = {};
                opfDoc.querySelectorAll('manifest item').forEach(item => {
                    this.manifest[item.getAttribute('id')] = {
                        href: item.getAttribute('href'),
                        mediaType: item.getAttribute('media-type'),
                        properties: item.getAttribute('properties') || ''
                    };
                });
            }

            parseSpine(opfDoc) {
                this.spine = [];
                opfDoc.querySelectorAll('spine itemref').forEach(itemref => {
                    const idref = itemref.getAttribute('idref');
                    if (this.manifest[idref]) {
                        this.spine.push(this.manifest[idref].href);
                    }
                });
            }

            async parseTOC(opfDoc) {
                this.toc = [];
                
                // é¦–å…ˆå°è¯• EPUB3 çš„ nav æ–‡æ¡£
                const navItem = Object.values(this.manifest).find(item => 
                    item.properties.includes('nav')
                );
                
                if (navItem) {
                    await this.parseNavTOC(navItem.href);
                } else {
                    // å›é€€åˆ° NCX
                    const ncxItem = Object.values(this.manifest).find(item =>
                        item.mediaType === 'application/x-dtbncx+xml'
                    );
                    if (ncxItem) {
                        await this.parseNCXTOC(ncxItem.href);
                    }
                }
            }

            async parseNavTOC(navHref) {
                const navPath = this.opfDir + navHref;
                const navContent = await this.zip.file(navPath).async('text');
                const navDoc = new DOMParser().parseFromString(navContent, 'application/xhtml+xml');
                
                const tocNav = navDoc.querySelector('nav[epub\\:type="toc"], nav[*|type="toc"], nav');
                if (tocNav) {
                    this.extractNavItems(tocNav.querySelector('ol'), 1);
                }
            }

            extractNavItems(ol, level) {
                if (!ol) return;
                ol.querySelectorAll(':scope > li').forEach(li => {
                    const a = li.querySelector(':scope > a');
                    if (a) {
                        this.toc.push({
                            title: a.textContent.trim(),
                            href: a.getAttribute('href'),
                            level: level
                        });
                    }
                    const subOl = li.querySelector(':scope > ol');
                    if (subOl) {
                        this.extractNavItems(subOl, level + 1);
                    }
                });
            }

            async parseNCXTOC(ncxHref) {
                const ncxPath = this.opfDir + ncxHref;
                const ncxContent = await this.zip.file(ncxPath).async('text');
                const ncxDoc = new DOMParser().parseFromString(ncxContent, 'application/xml');
                
                this.extractNCXNavPoints(ncxDoc.querySelector('navMap'), 1);
            }

            extractNCXNavPoints(parent, level) {
                if (!parent) return;
                parent.querySelectorAll(':scope > navPoint').forEach(navPoint => {
                    const label = navPoint.querySelector('navLabel text')?.textContent?.trim();
                    const src = navPoint.querySelector('content')?.getAttribute('src');
                    if (label && src) {
                        this.toc.push({
                            title: label,
                            href: src,
                            level: level
                        });
                    }
                    this.extractNCXNavPoints(navPoint, level + 1);
                });
            }

            async renderBook() {
                const readerContent = document.getElementById('reader-content');
                readerContent.innerHTML = '';
                this.chapterElements = [];

                for (let i = 0; i < this.spine.length; i++) {
                    const href = this.spine[i];
                    const chapterPath = this.opfDir + href;
                    
                    try {
                        let content = await this.zip.file(chapterPath).async('text');
                        const chapterDoc = new DOMParser().parseFromString(content, 'application/xhtml+xml');
                        
                        // å¤„ç†å›¾ç‰‡
                        await this.processImages(chapterDoc, chapterPath);
                        
                        // åˆ›å»ºç« èŠ‚å®¹å™¨
                        const section = document.createElement('section');
                        section.className = 'chapter-section';
                        section.id = `chapter-${i}`;
                        section.dataset.href = href;
                        
                        // æå– body å†…å®¹
                        const body = chapterDoc.querySelector('body');
                        if (body) {
                            section.innerHTML = body.innerHTML;
                        }
                        
                        // ä¸ºæ‰€æœ‰å¸¦ id çš„å…ƒç´ æ·»åŠ å”¯ä¸€å‰ç¼€
                        section.querySelectorAll('[id]').forEach(el => {
                            el.id = `ch${i}-${el.id}`;
                        });
                        
                        readerContent.appendChild(section);
                        this.chapterElements.push({
                            element: section,
                            href: href
                        });
                    } catch (e) {
                        console.warn(`æ— æ³•åŠ è½½ç« èŠ‚: ${href}`, e);
                    }
                }
            }

            async processImages(doc, chapterPath) {
                const chapterDir = chapterPath.substring(0, chapterPath.lastIndexOf('/') + 1);
                const images = doc.querySelectorAll('img, image');
                
                for (const img of images) {
                    const src = img.getAttribute('src') || img.getAttribute('xlink:href');
                    if (!src) continue;
                    
                    let imagePath = src;
                    if (!src.startsWith('/')) {
                        imagePath = this.resolvePath(chapterDir, src);
                    } else {
                        imagePath = src.substring(1);
                    }
                    
                    try {
                        const imageFile = this.zip.file(imagePath);
                        if (imageFile) {
                            const imageData = await imageFile.async('base64');
                            const mimeType = this.getMimeType(imagePath);
                            const dataUrl = `data:${mimeType};base64,${imageData}`;
                            
                            if (img.tagName.toLowerCase() === 'image') {
                                img.setAttribute('xlink:href', dataUrl);
                            } else {
                                img.setAttribute('src', dataUrl);
                            }
                        }
                    } catch (e) {
                        console.warn(`æ— æ³•åŠ è½½å›¾ç‰‡: ${imagePath}`, e);
                    }
                }
            }

            resolvePath(basePath, relativePath) {
                const baseDir = basePath.substring(0, basePath.lastIndexOf('/') + 1);
                const parts = (baseDir + relativePath).split('/');
                const resolved = [];
                
                for (const part of parts) {
                    if (part === '..') {
                        resolved.pop();
                    } else if (part !== '.' && part !== '') {
                        resolved.push(part);
                    }
                }
                
                return resolved.join('/');
            }

            getMimeType(path) {
                const ext = path.split('.').pop().toLowerCase();
                const mimeTypes = {
                    'jpg': 'image/jpeg',
                    'jpeg': 'image/jpeg',
                    'png': 'image/png',
                    'gif': 'image/gif',
                    'svg': 'image/svg+xml',
                    'webp': 'image/webp'
                };
                return mimeTypes[ext] || 'image/jpeg';
            }

            renderTOC() {
                const tocContainer = document.getElementById('toc');
                tocContainer.innerHTML = '';

                if (this.toc.length === 0) {
                    // å¦‚æœæ²¡æœ‰ç›®å½•ï¼Œä½¿ç”¨ spine é¡ºåºä½œä¸ºç›®å½•
                    this.spine.forEach((href, index) => {
                        const item = document.createElement('div');
                        item.className = 'toc-item level-1';
                        item.textContent = `ç« èŠ‚ ${index + 1}`;
                        item.dataset.href = href;
                        item.addEventListener('click', () => this.navigateTo(href));
                        tocContainer.appendChild(item);
                    });
                } else {
                    this.toc.forEach((item, index) => {
                        const tocItem = document.createElement('div');
                        tocItem.className = `toc-item level-${Math.min(item.level, 3)}`;
                        tocItem.textContent = item.title;
                        tocItem.dataset.href = item.href;
                        tocItem.dataset.index = index;
                        tocItem.addEventListener('click', () => this.navigateTo(item.href));
                        tocContainer.appendChild(tocItem);
                    });
                }
            }

            navigateTo(href) {
                // åˆ†ç¦»æ–‡ä»¶è·¯å¾„å’Œé”šç‚¹
                const [filePath, anchor] = href.split('#');
                
                // æŸ¥æ‰¾å¯¹åº”çš„ç« èŠ‚
                for (let i = 0; i < this.chapterElements.length; i++) {
                    const chapter = this.chapterElements[i];
                    if (chapter.href === filePath || chapter.href.endsWith(filePath)) {
                        let targetElement = chapter.element;
                        
                        // å¦‚æœæœ‰é”šç‚¹ï¼Œå°è¯•æ‰¾åˆ°å¯¹åº”å…ƒç´ 
                        if (anchor) {
                            const anchorEl = document.getElementById(`ch${i}-${anchor}`);
                            if (anchorEl) {
                                targetElement = anchorEl;
                            }
                        }
                        
                        targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        this.highlightTocItem(href);
                        break;
                    }
                }
            }

            highlightTocItem(href) {
                document.querySelectorAll('.toc-item').forEach(item => {
                    item.classList.remove('active');
                    if (item.dataset.href === href || href.includes(item.dataset.href)) {
                        item.classList.add('active');
                    }
                });
            }

            updateActiveTocItem() {
                const container = document.getElementById('reader-container');
                const scrollTop = container.scrollTop;
                
                let activeChapter = null;
                for (const chapter of this.chapterElements) {
                    if (chapter.element.offsetTop <= scrollTop + 100) {
                        activeChapter = chapter;
                    } else {
                        break;
                    }
                }
                
                if (activeChapter) {
                    this.highlightTocItem(activeChapter.href);
                }
            }
        }

        // åˆå§‹åŒ–é˜…è¯»å™¨
        const reader = new EPUBReader();
    </script>
</body>
</html>
