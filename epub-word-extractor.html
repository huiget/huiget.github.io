<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å•è¯æå–å™¨</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- PDF.js for PDF parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- Compromise NLP: è‡ªåŒ…å«çš„è‹±è¯­ NLP åº“ï¼Œæ— éœ€åŠ è½½å¤–éƒ¨è¯å…¸ -->
    <script src="https://unpkg.com/compromise@14.14.5/builds/compromise.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 40px 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2em;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .upload-section {
            background: white;
            border-radius: 16px;
            padding: 40px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }

        .drop-zone {
            border: 3px dashed #bdc3c7;
            border-radius: 12px;
            padding: 60px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .drop-zone:hover, .drop-zone.drag-over {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }

        .drop-zone svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            color: #95a5a6;
        }

        .drop-zone h2 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1.5em;
        }

        .drop-zone p {
            color: #7f8c8d;
            font-size: 16px;
        }

        #file-input {
            display: none;
        }

        .options-section {
            background: white;
            border-radius: 16px;
            padding: 25px 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }

        .options-section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .options-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
        }

        .option-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .option-item label {
            color: #34495e;
            font-size: 14px;
            cursor: pointer;
        }

        .option-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .option-item input[type="number"] {
            width: 80px;
            padding: 6px 10px;
            border: 2px solid #ecf0f1;
            border-radius: 6px;
            font-size: 14px;
        }

        .option-item input[type="number"].coca-range-input {
            width: 100px;
        }

        /* åŒç«¯æ»‘å—æ ·å¼ */
        .range-slider-container {
            width: 100%;
            margin-top: 15px;
            padding: 0 10px;
        }

        .range-slider-wrapper {
            position: relative;
            height: 40px;
            display: flex;
            align-items: center;
        }

        .range-slider-track {
            position: absolute;
            width: 100%;
            height: 6px;
            background: #ecf0f1;
            border-radius: 3px;
        }

        .range-slider-range {
            position: absolute;
            height: 6px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 3px;
        }

        .range-slider-wrapper input[type="range"] {
            position: absolute;
            width: 100%;
            height: 6px;
            background: transparent;
            pointer-events: none;
            -webkit-appearance: none;
            appearance: none;
            margin: 0;
        }

        .range-slider-wrapper input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: white;
            border: 3px solid #667eea;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: transform 0.15s, box-shadow 0.15s;
        }

        .range-slider-wrapper input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.4);
        }

        .range-slider-wrapper input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: white;
            border: 3px solid #667eea;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        .range-slider-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 12px;
            color: #7f8c8d;
        }

        .stats-section {
            background: white;
            border-radius: 16px;
            padding: 25px 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            display: none;
        }

        .stats-section.active {
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .stat-value {
            font-size: 2em;
            font-weight: 700;
            color: #667eea;
            display: block;
        }

        .stat-label {
            font-size: 13px;
            color: #7f8c8d;
            margin-top: 5px;
        }

        .result-section {
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            display: none;
        }

        .result-section.active {
            display: block;
        }

        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .result-header h3 {
            color: #2c3e50;
            font-size: 1.2em;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a6fd6;
        }

        .btn-secondary {
            background: #27ae60;
            color: white;
        }

        .btn-secondary:hover {
            background: #219a52;
        }

        .word-list {
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #ecf0f1;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 15px;
            line-height: 1.8;
            color: #2c3e50;
            background: #fafafa;
        }

        .word-item {
            padding: 6px 0;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .word-item:last-child {
            border-bottom: none;
        }

        .word-lemma {
            font-weight: 600;
            color: #2c3e50;
            min-width: 120px;
        }

        .word-arrow {
            color: #bdc3c7;
            font-size: 12px;
        }

        .word-originals {
            color: #7f8c8d;
            font-size: 13px;
            flex: 1;
        }

        .word-original-tag {
            display: inline-block;
            background: #ecf0f1;
            padding: 2px 8px;
            border-radius: 4px;
            margin: 2px 4px 2px 0;
            font-size: 12px;
        }

        .loading {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.95);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .loading.active {
            display: flex;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading p {
            margin-top: 20px;
            color: #667eea;
            font-size: 16px;
        }

        .loading .progress-text {
            margin-top: 10px;
            color: #95a5a6;
            font-size: 14px;
        }

        /* æ»šåŠ¨æ¡æ ·å¼ */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #c0c0c0;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a0a0a0;
        }

        /* è¾“å…¥æ–¹å¼é€‰é¡¹å¡ */
        .input-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .input-tab {
            flex: 1;
            padding: 12px 20px;
            border: 2px solid #ecf0f1;
            border-radius: 10px;
            background: #f8f9fa;
            color: #7f8c8d;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .input-tab:hover {
            border-color: #667eea;
            color: #667eea;
        }

        .input-tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: transparent;
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .text-input-area {
            width: 100%;
        }

        .text-input-area textarea {
            width: 100%;
            height: 250px;
            padding: 20px;
            border: 2px solid #ecf0f1;
            border-radius: 12px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            font-size: 15px;
            line-height: 1.6;
            resize: vertical;
            transition: border-color 0.2s;
        }

        .text-input-area textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .text-input-area textarea::placeholder {
            color: #bdc3c7;
        }

        @media (max-width: 600px) {
            body {
                padding: 20px 15px;
            }

            h1 {
                font-size: 1.5em;
            }

            .upload-section, .options-section, .stats-section, .result-section {
                padding: 20px;
            }

            .drop-zone {
                padding: 40px 20px;
            }

            .options-row {
                flex-direction: column;
                align-items: flex-start;
            }

            .result-header {
                flex-direction: column;
                align-items: stretch;
            }

            .action-buttons {
                flex-direction: column;
            }

            .btn {
                width: 100%;
                text-align: center;
            }

            .input-tabs {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="spinner"></div>
        <p id="loading-text">æ­£åœ¨å¤„ç†æ–‡ä»¶...</p>
        <span class="progress-text" id="progress-text"></span>
    </div>

    <div class="container">
        <h1>ğŸ“š å•è¯æå–å™¨</h1>

        <div class="upload-section">
            <!-- è¾“å…¥æ–¹å¼é€‰é¡¹å¡ -->
            <div class="input-tabs">
                <button class="input-tab active" data-tab="file">ğŸ“ ä¸Šä¼ æ–‡ä»¶</button>
                <button class="input-tab" data-tab="text">ğŸ“ ç²˜è´´æ–‡æœ¬</button>
            </div>

            <!-- æ–‡ä»¶ä¸Šä¼ åŒºåŸŸ -->
            <div class="tab-content active" id="tab-file">
                <label for="file-input">
                    <div class="drop-zone" id="drop-zone">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <path d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"/>
                        </svg>
                        <h2>ä¸Šä¼  EPUB æˆ– PDF æ–‡ä»¶</h2>
                        <p>æ‹–æ”¾æ–‡ä»¶åˆ°æ­¤å¤„ï¼Œæˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</p>
                        <p style="font-size: 12px; color: #95a5a6; margin-top: 10px;">æ”¯æŒæ ¼å¼ï¼š.epub, .pdf</p>
                    </div>
                </label>
                <input type="file" id="file-input" accept=".epub,.pdf">
            </div>

            <!-- æ–‡æœ¬ç²˜è´´åŒºåŸŸ -->
            <div class="tab-content" id="tab-text">
                <div class="text-input-area">
                    <textarea id="text-input" placeholder="åœ¨æ­¤ç²˜è´´è¦æå–å•è¯çš„è‹±æ–‡æ–‡æœ¬..."></textarea>
                    <button class="btn btn-primary" id="extract-text-btn" style="margin-top: 15px; width: 100%;">ğŸ” æå–å•è¯</button>
                </div>
            </div>
        </div>

        <div class="options-section">
            <h3>âš™ï¸ æå–é€‰é¡¹</h3>
            <div class="options-row">
                <div class="option-item">
                    <input type="checkbox" id="opt-unique" checked>
                    <label for="opt-unique">å»é‡ï¼ˆåªä¿ç•™å”¯ä¸€å•è¯ï¼‰</label>
                </div>
                <div class="option-item">
                    <input type="checkbox" id="opt-sort" checked>
                    <label for="opt-sort">æŒ‰å­—æ¯æ’åº</label>
                </div>
                <div class="option-item">
                    <input type="checkbox" id="opt-lowercase" checked>
                    <label for="opt-lowercase">å…¨éƒ¨å°å†™</label>
                </div>
                <div class="option-item">
                    <input type="checkbox" id="opt-filter-short">
                    <label for="opt-filter-short">è¿‡æ»¤çŸ­è¯ï¼ˆå°‘äº</label>
                    <input type="number" id="opt-min-length" value="3" min="1" max="10">
                    <label for="opt-min-length">ä¸ªå­—æ¯ï¼‰</label>
                </div>
            </div>
            <h3 style="margin-top: 20px;">ğŸ“Š COCA è¯é¢‘ç­›é€‰</h3>
            <div class="options-row" style="margin-top: 10px;">
                <div class="option-item">
                    <input type="checkbox" id="opt-coca-enable">
                    <label for="opt-coca-enable">å¯ç”¨ COCA è¯é¢‘ç­›é€‰</label>
                    <span id="coca-status" style="font-size: 12px; color: #95a5a6; margin-left: 8px;">(æœªåŠ è½½)</span>
                </div>
                <div class="option-item">
                    <label for="opt-coca-min">æ’åèŒƒå›´:</label>
                    <input type="number" id="opt-coca-min" value="1" min="1" max="60000" class="coca-range-input">
                    <label>è‡³</label>
                    <input type="number" id="opt-coca-max" value="60000" min="1" max="60000" class="coca-range-input">
                </div>
                <div class="option-item">
                    <input type="checkbox" id="opt-coca-show-rank">
                    <label for="opt-coca-show-rank">æ˜¾ç¤º COCA æ’å</label>
                </div>
                <div class="option-item">
                    <input type="checkbox" id="opt-coca-sort-by-rank">
                    <label for="opt-coca-sort-by-rank">æŒ‰ COCA æ’åº</label>
                </div>
                <div class="option-item">
                    <input type="checkbox" id="opt-sort-by-freq">
                    <label for="opt-sort-by-freq">æŒ‰ä¹¦ä¸­è¯é¢‘æ’åº</label>
                </div>
            </div>
            <div class="range-slider-container">
                <div class="range-slider-wrapper">
                    <div class="range-slider-track"></div>
                    <div class="range-slider-range" id="slider-range"></div>
                    <input type="range" id="slider-min" min="1" max="60000" value="1">
                    <input type="range" id="slider-max" min="1" max="60000" value="60000">
                </div>
                <div class="range-slider-labels">
                    <span>1</span>
                    <span>15000</span>
                    <span>30000</span>
                    <span>45000</span>
                    <span>60000</span>
                </div>
            </div>
        </div>

        <div class="stats-section" id="stats-section">
            <div class="stats-grid">
                <div class="stat-item">
                    <span class="stat-value" id="stat-total">0</span>
                    <span class="stat-label">åŸå§‹å•è¯æ•°</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="stat-lemmatized">0</span>
                    <span class="stat-label">å”¯ä¸€è¯å½¢æ•°</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="stat-unique">0</span>
                    <span class="stat-label" id="stat-unique-label">æœ€ç»ˆè¯æ•°</span>
                </div>
                <div class="stat-item" id="stat-coca-container" style="display: none;">
                    <span class="stat-value" id="stat-coca-in-range">0</span>
                    <span class="stat-label">COCA èŒƒå›´å†…</span>
                </div>
                <div class="stat-item" id="stat-coca-unknown-container" style="display: none;">
                    <span class="stat-value" id="stat-coca-unknown">0</span>
                    <span class="stat-label">é COCA è¯æ±‡</span>
                </div>
            </div>
        </div>

        <div class="result-section" id="result-section">
            <div class="result-header">
                <h3>ğŸ“ æå–çš„å•è¯åˆ—è¡¨</h3>
                <div class="action-buttons">
                    <button class="btn btn-primary" id="copy-btn">ğŸ“‹ å¤åˆ¶åˆ°å‰ªè´´æ¿</button>
                    <button class="btn btn-secondary" id="download-btn">ğŸ’¾ ä¸‹è½½ä¸º TXT</button>
                </div>
            </div>
            <div class="word-list" id="word-list"></div>
        </div>
    </div>

    <script>
        // è®¾ç½® PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        class WordExtractor {
            constructor() {
                this.zip = null;
                this.opfPath = '';
                this.opfDir = '';
                this.manifest = {};
                this.spine = [];
                this.extractedWords = [];
                this.currentFileName = '';
                
                // COCA è¯é¢‘è¡¨
                this.cocaMap = null;
                this.cocaLoaded = false;
                this.cocaLoading = false;
                
                this.initEventListeners();
                this.initCOCAListeners();
                this.initTabListeners();
            }

            initTabListeners() {
                // é€‰é¡¹å¡åˆ‡æ¢
                document.querySelectorAll('.input-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        const targetTab = tab.dataset.tab;
                        
                        // æ›´æ–°é€‰é¡¹å¡çŠ¶æ€
                        document.querySelectorAll('.input-tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        
                        // æ›´æ–°å†…å®¹åŒºåŸŸ
                        document.querySelectorAll('.tab-content').forEach(content => {
                            content.classList.remove('active');
                        });
                        document.getElementById(`tab-${targetTab}`).classList.add('active');
                    });
                });

                // æ–‡æœ¬æå–æŒ‰é’®
                document.getElementById('extract-text-btn').addEventListener('click', () => {
                    this.processText();
                });

                // æ”¯æŒ Ctrl+Enter å¿«æ·é”®æå–æ–‡æœ¬
                document.getElementById('text-input').addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                        e.preventDefault();
                        this.processText();
                    }
                });
            }

            async loadCOCA() {
                if (this.cocaLoaded || this.cocaLoading) return;
                
                this.cocaLoading = true;
                const statusEl = document.getElementById('coca-status');
                statusEl.textContent = '(åŠ è½½ä¸­...)';
                statusEl.style.color = '#f39c12';
                
                try {
                    const response = await fetch('https://huiget.github.io/filtered_COCA60000.txt');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    const text = await response.text();
                    const lines = text.split(/\r?\n/);
                    
                    this.cocaMap = new Map();
                    for (let i = 0; i < lines.length; i++) {
                        const word = lines[i].trim();
                        if (word) {
                            this.cocaMap.set(word.toLowerCase(), i + 1);
                        }
                    }
                    
                    this.cocaLoaded = true;
                    statusEl.textContent = `(å·²åŠ è½½ ${this.cocaMap.size.toLocaleString()} è¯)`;
                    statusEl.style.color = '#27ae60';
                    console.log(`COCA è¯é¢‘è¡¨åŠ è½½æˆåŠŸ: ${this.cocaMap.size} è¯`);
                    
                    // å¦‚æœå·²æœ‰æå–çš„å•è¯ï¼Œé‡æ–°æ˜¾ç¤º
                    if (this.extractedWords.length > 0) {
                        this.displayWords();
                    }
                } catch (error) {
                    console.error('åŠ è½½ COCA è¯é¢‘è¡¨å¤±è´¥:', error);
                    statusEl.textContent = '(åŠ è½½å¤±è´¥)';
                    statusEl.style.color = '#e74c3c';
                    this.cocaLoaded = false;
                    document.getElementById('opt-coca-enable').checked = false;
                    alert('åŠ è½½ COCA è¯é¢‘è¡¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ã€‚\n\né”™è¯¯: ' + error.message);
                } finally {
                    this.cocaLoading = false;
                }
            }

            getCOCARank(word) {
                if (!this.cocaMap) return null;
                return this.cocaMap.get(word.toLowerCase()) || null;
            }

            initCOCAListeners() {
                // å¯ç”¨ COCA ç­›é€‰æ—¶åŠ è½½è¯é¢‘è¡¨
                document.getElementById('opt-coca-enable').addEventListener('change', async (e) => {
                    if (e.target.checked && !this.cocaLoaded) {
                        await this.loadCOCA();
                    }
                    if (this.extractedWords.length > 0) {
                        this.displayWords();
                    }
                });
                
                // COCA ç›¸å…³é€‰é¡¹å˜åŒ–æ—¶é‡æ–°æ˜¾ç¤º
                ['opt-coca-min', 'opt-coca-max', 'opt-coca-show-rank', 'opt-coca-sort-by-rank', 'opt-sort-by-freq'].forEach(id => {
                    document.getElementById(id).addEventListener('change', () => {
                        if (this.extractedWords.length > 0) {
                            this.displayWords();
                        }
                    });
                });
                
                // åˆå§‹åŒ–åŒç«¯æ»‘å—
                this.initRangeSlider();
            }
            
            initRangeSlider() {
                const sliderMin = document.getElementById('slider-min');
                const sliderMax = document.getElementById('slider-max');
                const sliderRange = document.getElementById('slider-range');
                const inputMin = document.getElementById('opt-coca-min');
                const inputMax = document.getElementById('opt-coca-max');
                
                const updateSliderRange = () => {
                    const min = parseInt(sliderMin.value);
                    const max = parseInt(sliderMax.value);
                    const minPercent = ((min - 1) / 59999) * 100;
                    const maxPercent = ((max - 1) / 59999) * 100;
                    sliderRange.style.left = minPercent + '%';
                    sliderRange.style.width = (maxPercent - minPercent) + '%';
                };
                
                const syncFromSliders = () => {
                    let minVal = parseInt(sliderMin.value);
                    let maxVal = parseInt(sliderMax.value);
                    
                    // ç¡®ä¿ min ä¸è¶…è¿‡ max
                    if (minVal > maxVal) {
                        [minVal, maxVal] = [maxVal, minVal];
                        sliderMin.value = minVal;
                        sliderMax.value = maxVal;
                    }
                    
                    inputMin.value = minVal;
                    inputMax.value = maxVal;
                    updateSliderRange();
                    
                    if (this.extractedWords.length > 0) {
                        this.displayWords();
                    }
                };
                
                const syncFromInputs = () => {
                    let minVal = parseInt(inputMin.value) || 1;
                    let maxVal = parseInt(inputMax.value) || 60000;
                    
                    // é™åˆ¶èŒƒå›´
                    minVal = Math.max(1, Math.min(60000, minVal));
                    maxVal = Math.max(1, Math.min(60000, maxVal));
                    
                    // ç¡®ä¿ min ä¸è¶…è¿‡ max
                    if (minVal > maxVal) {
                        [minVal, maxVal] = [maxVal, minVal];
                    }
                    
                    inputMin.value = minVal;
                    inputMax.value = maxVal;
                    sliderMin.value = minVal;
                    sliderMax.value = maxVal;
                    updateSliderRange();
                };
                
                // æ»‘å—äº‹ä»¶
                sliderMin.addEventListener('input', syncFromSliders);
                sliderMax.addEventListener('input', syncFromSliders);
                
                // è¾“å…¥æ¡†äº‹ä»¶
                inputMin.addEventListener('input', syncFromInputs);
                inputMax.addEventListener('input', syncFromInputs);
                
                // åˆå§‹åŒ–æ»‘å—ä½ç½®
                updateSliderRange();
            }

            initEventListeners() {
                // æ–‡ä»¶ä¸Šä¼ 
                document.getElementById('file-input').addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.processFile(e.target.files[0]);
                    }
                });

                // æ‹–æ”¾æ”¯æŒ
                const dropZone = document.getElementById('drop-zone');

                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    dropZone.addEventListener(eventName, (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });

                dropZone.addEventListener('dragenter', () => dropZone.classList.add('drag-over'));
                dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drag-over'));
                dropZone.addEventListener('drop', (e) => {
                    dropZone.classList.remove('drag-over');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        const file = files[0];
                        const ext = file.name.toLowerCase();
                        if (ext.endsWith('.epub') || ext.endsWith('.pdf')) {
                            this.processFile(file);
                        } else {
                            alert('è¯·ä¸Šä¼  EPUB æˆ– PDF æ–‡ä»¶');
                        }
                    }
                });

                // å¤åˆ¶æŒ‰é’®
                document.getElementById('copy-btn').addEventListener('click', () => {
                    this.copyToClipboard();
                });

                // ä¸‹è½½æŒ‰é’®
                document.getElementById('download-btn').addEventListener('click', () => {
                    this.downloadAsTxt();
                });

                // é€‰é¡¹å˜åŒ–æ—¶é‡æ–°å¤„ç†
                ['opt-unique', 'opt-sort', 'opt-lowercase', 'opt-filter-short', 'opt-min-length'].forEach(id => {
                    document.getElementById(id).addEventListener('change', () => {
                        if (this.extractedWords.length > 0) {
                            this.displayWords();
                        }
                    });
                });
            }

            showLoading(show, text = 'æ­£åœ¨å¤„ç†æ–‡ä»¶...', progress = '') {
                const loading = document.getElementById('loading');
                const loadingText = document.getElementById('loading-text');
                const progressText = document.getElementById('progress-text');
                
                loading.classList.toggle('active', show);
                loadingText.textContent = text;
                progressText.textContent = progress;
            }

            // å¤„ç†æ–‡ä»¶ï¼ˆè‡ªåŠ¨æ£€æµ‹ç±»å‹ï¼‰
            async processFile(file) {
                const fileName = file.name.toLowerCase();
                if (fileName.endsWith('.epub')) {
                    await this.processEPUB(file);
                } else if (fileName.endsWith('.pdf')) {
                    await this.processPDF(file);
                } else {
                    alert('ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ï¼Œè¯·ä¸Šä¼  EPUB æˆ– PDF æ–‡ä»¶');
                }
            }

            // å¤„ç†ç²˜è´´çš„æ–‡æœ¬
            async processText() {
                const textInput = document.getElementById('text-input');
                const text = textInput.value.trim();
                
                if (!text) {
                    alert('è¯·å…ˆè¾“å…¥è¦æå–å•è¯çš„æ–‡æœ¬');
                    return;
                }
                
                this.showLoading(true, 'æ­£åœ¨æå–å•è¯...');
                this.currentFileName = 'pasted-text';
                
                try {
                    // æå–å•è¯
                    const rawWords = this.extractWords(text);
                    
                    document.getElementById('stat-total').textContent = rawWords.length.toLocaleString();
                    
                    this.showLoading(true, 'æ­£åœ¨è¿›è¡Œè¯å½¢è¿˜åŸ...');
                    
                    // è¯å½¢è¿˜åŸ
                    this.extractedWords = await this.lemmatizeWords(rawWords);
                    
                    // ç»Ÿè®¡å»é‡åçš„è¯å½¢æ•°é‡
                    const uniqueLemmas = new Set(this.extractedWords.map(w => w.lemma.toLowerCase()));
                    document.getElementById('stat-lemmatized').textContent = uniqueLemmas.size.toLocaleString();
                    
                    // æ˜¾ç¤ºç»“æœ
                    this.displayWords();
                    
                    document.getElementById('stats-section').classList.add('active');
                    document.getElementById('result-section').classList.add('active');
                    
                } catch (error) {
                    console.error('å¤„ç†æ–‡æœ¬å¤±è´¥:', error);
                    alert('å¤„ç†æ–‡æœ¬å¤±è´¥ã€‚\n\né”™è¯¯ä¿¡æ¯: ' + error.message);
                } finally {
                    this.showLoading(false);
                }
            }

            // å¤„ç† PDF æ–‡ä»¶
            async processPDF(file) {
                this.showLoading(true, 'æ­£åœ¨è§£æ PDF æ–‡ä»¶...');
                this.currentFileName = file.name.replace('.pdf', '');
                
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                    
                    let allText = '';
                    const totalPages = pdf.numPages;
                    
                    for (let i = 1; i <= totalPages; i++) {
                        this.showLoading(true, 'æ­£åœ¨æå–æ–‡æœ¬å†…å®¹...', `${i} / ${totalPages} é¡µ`);
                        
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        const pageText = textContent.items.map(item => item.str).join(' ');
                        allText += ' ' + pageText;
                    }
                    
                    this.showLoading(true, 'æ­£åœ¨æå–å•è¯...');
                    
                    // æå–å•è¯
                    const rawWords = this.extractWords(allText);
                    
                    document.getElementById('stat-total').textContent = rawWords.length.toLocaleString();
                    
                    this.showLoading(true, 'æ­£åœ¨è¿›è¡Œè¯å½¢è¿˜åŸ...');
                    
                    // è¯å½¢è¿˜åŸ
                    this.extractedWords = await this.lemmatizeWords(rawWords);
                    
                    // ç»Ÿè®¡å»é‡åçš„è¯å½¢æ•°é‡
                    const uniqueLemmas = new Set(this.extractedWords.map(w => w.lemma.toLowerCase()));
                    document.getElementById('stat-lemmatized').textContent = uniqueLemmas.size.toLocaleString();
                    
                    // æ˜¾ç¤ºç»“æœ
                    this.displayWords();
                    
                    document.getElementById('stats-section').classList.add('active');
                    document.getElementById('result-section').classList.add('active');
                    
                } catch (error) {
                    console.error('å¤„ç† PDF å¤±è´¥:', error);
                    alert('å¤„ç† PDF æ–‡ä»¶å¤±è´¥ï¼Œè¯·ç¡®ä¿æ–‡ä»¶æ ¼å¼æ­£ç¡®ã€‚\n\né”™è¯¯ä¿¡æ¯: ' + error.message);
                } finally {
                    this.showLoading(false);
                }
            }

            async processEPUB(file) {
                this.showLoading(true, 'æ­£åœ¨è§£æ EPUB æ–‡ä»¶...');
                this.currentFileName = file.name.replace('.epub', '');
                
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    this.zip = await JSZip.loadAsync(arrayBuffer);
                    
                    this.showLoading(true, 'æ­£åœ¨è¯»å–ç›®å½•ç»“æ„...');
                    
                    // è§£æ container.xml è·å– OPF è·¯å¾„
                    const containerXml = await this.zip.file('META-INF/container.xml').async('text');
                    const containerDoc = new DOMParser().parseFromString(containerXml, 'application/xml');
                    this.opfPath = containerDoc.querySelector('rootfile').getAttribute('full-path');
                    this.opfDir = this.opfPath.substring(0, this.opfPath.lastIndexOf('/') + 1);

                    // è§£æ OPF æ–‡ä»¶
                    const opfContent = await this.zip.file(this.opfPath).async('text');
                    const opfDoc = new DOMParser().parseFromString(opfContent, 'application/xml');
                    
                    this.parseManifest(opfDoc);
                    this.parseSpine(opfDoc);
                    
                    this.showLoading(true, 'æ­£åœ¨æå–æ–‡æœ¬å†…å®¹...');
                    
                    // æå–æ‰€æœ‰æ–‡æœ¬
                    const allText = await this.extractAllText();
                    
                    this.showLoading(true, 'æ­£åœ¨æå–å•è¯...');
                    
                    // æå–å•è¯
                    const rawWords = this.extractWords(allText);
                    
                    document.getElementById('stat-total').textContent = rawWords.length.toLocaleString();
                    
                    this.showLoading(true, 'æ­£åœ¨è¿›è¡Œè¯å½¢è¿˜åŸ...');
                    
                    // è¯å½¢è¿˜åŸï¼ˆå¼‚æ­¥ï¼Œæ”¯æŒè¿›åº¦æ˜¾ç¤ºï¼‰
                    this.extractedWords = await this.lemmatizeWords(rawWords);
                    
                    // ç»Ÿè®¡å»é‡åçš„è¯å½¢æ•°é‡
                    const uniqueLemmas = new Set(this.extractedWords.map(w => w.lemma.toLowerCase()));
                    document.getElementById('stat-lemmatized').textContent = uniqueLemmas.size.toLocaleString();
                    
                    // æ˜¾ç¤ºç»“æœ
                    this.displayWords();
                    
                    document.getElementById('stats-section').classList.add('active');
                    document.getElementById('result-section').classList.add('active');
                    
                } catch (error) {
                    console.error('å¤„ç† EPUB å¤±è´¥:', error);
                    alert('å¤„ç† EPUB æ–‡ä»¶å¤±è´¥ï¼Œè¯·ç¡®ä¿æ–‡ä»¶æ ¼å¼æ­£ç¡®ã€‚\n\né”™è¯¯ä¿¡æ¯: ' + error.message);
                } finally {
                    this.showLoading(false);
                }
            }

            parseManifest(opfDoc) {
                this.manifest = {};
                opfDoc.querySelectorAll('manifest item').forEach(item => {
                    this.manifest[item.getAttribute('id')] = {
                        href: item.getAttribute('href'),
                        mediaType: item.getAttribute('media-type')
                    };
                });
            }

            parseSpine(opfDoc) {
                this.spine = [];
                opfDoc.querySelectorAll('spine itemref').forEach(itemref => {
                    const idref = itemref.getAttribute('idref');
                    if (this.manifest[idref]) {
                        this.spine.push(this.manifest[idref].href);
                    }
                });
            }

            async extractAllText() {
                let allText = '';
                
                for (let i = 0; i < this.spine.length; i++) {
                    const href = this.spine[i];
                    const chapterPath = this.opfDir + href;
                    
                    this.showLoading(true, 'æ­£åœ¨æå–æ–‡æœ¬å†…å®¹...', `${i + 1} / ${this.spine.length}`);
                    
                    try {
                        const content = await this.zip.file(chapterPath).async('text');
                        const doc = new DOMParser().parseFromString(content, 'application/xhtml+xml');
                        
                        // ç§»é™¤è„šæœ¬å’Œæ ·å¼
                        doc.querySelectorAll('script, style').forEach(el => el.remove());
                        
                        // è·å–çº¯æ–‡æœ¬
                        const body = doc.querySelector('body');
                        if (body) {
                            allText += ' ' + body.textContent;
                        }
                    } catch (e) {
                        console.warn(`æ— æ³•è¯»å–ç« èŠ‚: ${href}`, e);
                    }
                }
                
                return allText;
            }

            extractWords(text) {
                // æå–è‹±æ–‡å•è¯ï¼ˆåŒ…æ‹¬å¸¦è¿å­—ç¬¦çš„å¤åˆè¯ï¼‰
                // åŒ¹é…ï¼šçº¯å­—æ¯å•è¯ã€å¸¦æ’‡å·çš„ç¼©å†™å½¢å¼
                const wordPattern = /[a-zA-Z]+(?:[''][a-zA-Z]+)?/g;
                const matches = text.match(wordPattern) || [];
                
                // è¿‡æ»¤æ‰å•å­—æ¯å’Œçº¯ç¼©å†™å½¢å¼
                return matches.filter(word => {
                    // ç§»é™¤æ’‡å·éƒ¨åˆ†ï¼Œåªä¿ç•™ä¸»ä½“
                    const mainWord = word.replace(/[''].+$/, '');
                    return mainWord.length >= 1;
                });
            }

            async lemmatizeWords(words) {
                const lemmatized = [];
                
                // æ£€æŸ¥ compromise åº“æ˜¯å¦åŠ è½½æˆåŠŸ
                const hasNlp = typeof nlp !== 'undefined';
                
                if (hasNlp) {
                    console.log('Compromise NLP åº“åŠ è½½æˆåŠŸ');
                } else {
                    console.warn('Compromise NLP åº“æœªåŠ è½½ï¼Œå°†ä½¿ç”¨åŸå§‹å•è¯');
                }
                
                // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šå…ˆå»é‡ï¼Œåªå¯¹å”¯ä¸€å•è¯è¿›è¡Œè¯å½¢è¿˜åŸ
                // æ­¥éª¤1ï¼šé¢„å¤„ç†æ‰€æœ‰å•è¯ï¼Œæ”¶é›†å”¯ä¸€çš„å¤„ç†åå•è¯
                const uniqueWordsMap = new Map(); // processedWord -> Set of original words
                const wordToProcessed = new Map(); // original word -> processedWord
                
                for (const word of words) {
                    // å¤„ç†æ’‡å·ç¼©å†™ï¼šdon't -> do, can't -> can, etc.
                    const processedWord = word.replace(/[''][a-zA-Z]+$/, '');
                    if (!processedWord || processedWord.length === 0) continue;
                    
                    const lowerProcessed = processedWord.toLowerCase();
                    wordToProcessed.set(word, lowerProcessed);
                    
                    if (!uniqueWordsMap.has(lowerProcessed)) {
                        uniqueWordsMap.set(lowerProcessed, new Set());
                    }
                    uniqueWordsMap.get(lowerProcessed).add(word);
                }
                
                const uniqueWords = Array.from(uniqueWordsMap.keys());
                console.log(`è¯å½¢è¿˜åŸä¼˜åŒ–ï¼šä» ${words.length} ä¸ªå•è¯ä¸­æå–å‡º ${uniqueWords.length} ä¸ªå”¯ä¸€å•è¯`);
                
                // æ­¥éª¤2ï¼šåªå¯¹å”¯ä¸€å•è¯è¿›è¡Œè¯å½¢è¿˜åŸ
                const lemmaCache = new Map(); // processedWord -> lemma
                
                if (hasNlp) {
                    // åˆ†æ‰¹å¤„ç†ï¼Œæ¯æ‰¹æ˜¾ç¤ºè¿›åº¦
                    const batchSize = 500;
                    const totalBatches = Math.ceil(uniqueWords.length / batchSize);
                    
                    for (let i = 0; i < uniqueWords.length; i += batchSize) {
                        const batch = uniqueWords.slice(i, i + batchSize);
                        const batchNum = Math.floor(i / batchSize) + 1;
                        
                        // æ›´æ–°è¿›åº¦
                        if (totalBatches > 1) {
                            this.showLoading(true, 'æ­£åœ¨è¿›è¡Œè¯å½¢è¿˜åŸ...', `${batchNum} / ${totalBatches} æ‰¹`);
                        }
                        
                        for (const processedWord of batch) {
                            try {
                                let lemma = processedWord;
                                const doc = nlp(processedWord);
                                
                                // å°è¯•è·å–åŠ¨è¯åŸå½¢
                                if (doc.verbs().found) {
                                    const infinitive = doc.verbs().toInfinitive().text();
                                    if (infinitive) {
                                        lemma = infinitive.toLowerCase();
                                    }
                                }
                                // å°è¯•è·å–åè¯å•æ•°å½¢å¼
                                else if (doc.nouns().found) {
                                    const singular = doc.nouns().toSingular().text();
                                    if (singular) {
                                        lemma = singular.toLowerCase();
                                    }
                                }
                                
                                lemmaCache.set(processedWord, lemma);
                            } catch (e) {
                                lemmaCache.set(processedWord, processedWord);
                            }
                        }
                        
                        // è®©å‡ºä¸»çº¿ç¨‹ï¼Œé¿å…é¡µé¢å¡é¡¿
                        if (i + batchSize < uniqueWords.length) {
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                    }
                } else {
                    // æ²¡æœ‰ NLP åº“ï¼Œç›´æ¥ä½¿ç”¨å¤„ç†åçš„å•è¯
                    for (const processedWord of uniqueWords) {
                        lemmaCache.set(processedWord, processedWord);
                    }
                }
                
                // æ­¥éª¤3ï¼šå°†è¯å½¢è¿˜åŸç»“æœæ˜ å°„å›æ‰€æœ‰åŸå§‹å•è¯
                for (const word of words) {
                    const processedWord = wordToProcessed.get(word);
                    if (!processedWord) continue;
                    
                    const lemma = lemmaCache.get(processedWord) || processedWord;
                    
                    if (lemma && lemma.length > 0) {
                        lemmatized.push({
                            original: word,
                            lemma: lemma
                        });
                    }
                }
                
                return lemmatized;
            }

            // åŸºäºè§„åˆ™çš„è¯å½¢è¿˜åŸï¼ˆä½œä¸ºåå¤‡æ–¹æ¡ˆï¼‰
            applyRulesLemmatization(word) {
                if (!word || word.length < 2) return word;
                
                const lower = word.toLowerCase();
                
                // ä¸è§„åˆ™åŠ¨è¯è¡¨ï¼ˆå¸¸è§çš„ï¼‰
                const irregularVerbs = {
                    'was': 'be', 'were': 'be', 'been': 'be', 'being': 'be', 'am': 'be', 'is': 'be', 'are': 'be',
                    'had': 'have', 'has': 'have', 'having': 'have',
                    'did': 'do', 'does': 'do', 'doing': 'do', 'done': 'do',
                    'went': 'go', 'goes': 'go', 'going': 'go', 'gone': 'go',
                    'said': 'say', 'says': 'say', 'saying': 'say',
                    'made': 'make', 'makes': 'make', 'making': 'make',
                    'took': 'take', 'takes': 'take', 'taking': 'take', 'taken': 'take',
                    'came': 'come', 'comes': 'come', 'coming': 'come',
                    'saw': 'see', 'sees': 'see', 'seeing': 'see', 'seen': 'see',
                    'knew': 'know', 'knows': 'know', 'knowing': 'know', 'known': 'know',
                    'got': 'get', 'gets': 'get', 'getting': 'get', 'gotten': 'get',
                    'gave': 'give', 'gives': 'give', 'giving': 'give', 'given': 'give',
                    'found': 'find', 'finds': 'find', 'finding': 'find',
                    'thought': 'think', 'thinks': 'think', 'thinking': 'think',
                    'told': 'tell', 'tells': 'tell', 'telling': 'tell',
                    'felt': 'feel', 'feels': 'feel', 'feeling': 'feel',
                    'became': 'become', 'becomes': 'become', 'becoming': 'become',
                    'left': 'leave', 'leaves': 'leave', 'leaving': 'leave',
                    'brought': 'bring', 'brings': 'bring', 'bringing': 'bring',
                    'began': 'begin', 'begins': 'begin', 'beginning': 'begin', 'begun': 'begin',
                    'kept': 'keep', 'keeps': 'keep', 'keeping': 'keep',
                    'held': 'hold', 'holds': 'hold', 'holding': 'hold',
                    'wrote': 'write', 'writes': 'write', 'writing': 'write', 'written': 'write',
                    'stood': 'stand', 'stands': 'stand', 'standing': 'stand',
                    'heard': 'hear', 'hears': 'hear', 'hearing': 'hear',
                    'let': 'let', 'lets': 'let', 'letting': 'let',
                    'meant': 'mean', 'means': 'mean', 'meaning': 'mean',
                    'set': 'set', 'sets': 'set', 'setting': 'set',
                    'met': 'meet', 'meets': 'meet', 'meeting': 'meet',
                    'ran': 'run', 'runs': 'run', 'running': 'run',
                    'paid': 'pay', 'pays': 'pay', 'paying': 'pay',
                    'sat': 'sit', 'sits': 'sit', 'sitting': 'sit',
                    'spoke': 'speak', 'speaks': 'speak', 'speaking': 'speak', 'spoken': 'speak',
                    'lay': 'lie', 'lies': 'lie', 'lying': 'lie', 'lain': 'lie',
                    'led': 'lead', 'leads': 'lead', 'leading': 'lead',
                    'read': 'read', 'reads': 'read', 'reading': 'read',
                    'grew': 'grow', 'grows': 'grow', 'growing': 'grow', 'grown': 'grow',
                    'lost': 'lose', 'loses': 'lose', 'losing': 'lose',
                    'fell': 'fall', 'falls': 'fall', 'falling': 'fall', 'fallen': 'fall',
                    'sent': 'send', 'sends': 'send', 'sending': 'send',
                    'built': 'build', 'builds': 'build', 'building': 'build',
                    'spent': 'spend', 'spends': 'spend', 'spending': 'spend',
                    'cut': 'cut', 'cuts': 'cut', 'cutting': 'cut',
                    'won': 'win', 'wins': 'win', 'winning': 'win',
                    'caught': 'catch', 'catches': 'catch', 'catching': 'catch',
                    'broke': 'break', 'breaks': 'break', 'breaking': 'break', 'broken': 'break',
                    'bought': 'buy', 'buys': 'buy', 'buying': 'buy',
                    'put': 'put', 'puts': 'put', 'putting': 'put',
                    'bit': 'bite', 'bites': 'bite', 'biting': 'bite', 'bitten': 'bite',
                    'chose': 'choose', 'chooses': 'choose', 'choosing': 'choose', 'chosen': 'choose',
                    'drew': 'draw', 'draws': 'draw', 'drawing': 'draw', 'drawn': 'draw',
                    'drove': 'drive', 'drives': 'drive', 'driving': 'drive', 'driven': 'drive',
                    'ate': 'eat', 'eats': 'eat', 'eating': 'eat', 'eaten': 'eat',
                    'flew': 'fly', 'flies': 'fly', 'flying': 'fly', 'flown': 'fly',
                    'forgot': 'forget', 'forgets': 'forget', 'forgetting': 'forget', 'forgotten': 'forget',
                    'hid': 'hide', 'hides': 'hide', 'hiding': 'hide', 'hidden': 'hide',
                    'hit': 'hit', 'hits': 'hit', 'hitting': 'hit',
                    'hung': 'hang', 'hangs': 'hang', 'hanging': 'hang',
                    'hurt': 'hurt', 'hurts': 'hurt', 'hurting': 'hurt',
                    'quit': 'quit', 'quits': 'quit', 'quitting': 'quit',
                    'rang': 'ring', 'rings': 'ring', 'ringing': 'ring', 'rung': 'ring',
                    'rose': 'rise', 'rises': 'rise', 'rising': 'rise', 'risen': 'rise',
                    'sang': 'sing', 'sings': 'sing', 'singing': 'sing', 'sung': 'sing',
                    'sank': 'sink', 'sinks': 'sink', 'sinking': 'sink', 'sunk': 'sink',
                    'slept': 'sleep', 'sleeps': 'sleep', 'sleeping': 'sleep',
                    'sold': 'sell', 'sells': 'sell', 'selling': 'sell',
                    'shook': 'shake', 'shakes': 'shake', 'shaking': 'shake', 'shaken': 'shake',
                    'shot': 'shoot', 'shoots': 'shoot', 'shooting': 'shoot',
                    'shut': 'shut', 'shuts': 'shut', 'shutting': 'shut',
                    'stole': 'steal', 'steals': 'steal', 'stealing': 'steal', 'stolen': 'steal',
                    'stuck': 'stick', 'sticks': 'stick', 'sticking': 'stick',
                    'struck': 'strike', 'strikes': 'strike', 'striking': 'strike',
                    'swam': 'swim', 'swims': 'swim', 'swimming': 'swim', 'swum': 'swim',
                    'threw': 'throw', 'throws': 'throw', 'throwing': 'throw', 'thrown': 'throw',
                    'understood': 'understand', 'understands': 'understand', 'understanding': 'understand',
                    'woke': 'wake', 'wakes': 'wake', 'waking': 'wake', 'woken': 'wake',
                    'wore': 'wear', 'wears': 'wear', 'wearing': 'wear', 'worn': 'wear'
                };

                // ä¸è§„åˆ™åè¯è¡¨
                const irregularNouns = {
                    'men': 'man', 'women': 'woman', 'children': 'child', 'feet': 'foot',
                    'teeth': 'tooth', 'mice': 'mouse', 'geese': 'goose', 'people': 'person',
                    'leaves': 'leaf', 'lives': 'life', 'wives': 'wife', 'knives': 'knife',
                    'halves': 'half', 'selves': 'self', 'wolves': 'wolf', 'shelves': 'shelf',
                    'calves': 'calf', 'loaves': 'loaf', 'thieves': 'thief', 'ourselves': 'ourself',
                    'yourselves': 'yourself', 'themselves': 'themself'
                };

                // æ£€æŸ¥ä¸è§„åˆ™å½¢å¼
                if (irregularVerbs[lower]) {
                    return irregularVerbs[lower];
                }
                if (irregularNouns[lower]) {
                    return irregularNouns[lower];
                }

                // è§„åˆ™å¤„ç†
                let result = lower;

                // åŠ¨è¯ -ing å½¢å¼
                if (result.endsWith('ing') && result.length > 4) {
                    const stem = result.slice(0, -3);
                    // running -> run, stopping -> stop (åŒå†™è¾…éŸ³)
                    if (stem.length >= 2 && stem[stem.length - 1] === stem[stem.length - 2] && 
                        !'aeiou'.includes(stem[stem.length - 1])) {
                        result = stem.slice(0, -1);
                    }
                    // lying -> lie, dying -> die (ç‰¹æ®Šçš„ y->i å˜åŒ–)
                    else if (stem.endsWith('y') && stem.length >= 2) {
                        const beforeY = stem[stem.length - 2];
                        if (!'aeiou'.includes(beforeY) && ['ly', 'dy', 'ty'].includes(stem.slice(-2))) {
                            result = stem.slice(0, -1) + 'ie';
                        } else {
                            result = stem;
                        }
                    }
                    // making -> make, writing -> write, reserving -> reserve
                    else if (this.shouldRestoreE(stem)) {
                        result = stem + 'e';
                    }
                    // walking -> walk
                    else if (stem.length >= 2) {
                        result = stem;
                    }
                }
                // åŠ¨è¯ -ed å½¢å¼
                else if (result.endsWith('ed') && result.length > 3) {
                    // cried -> cry, studied -> study
                    if (result.endsWith('ied')) {
                        result = result.slice(0, -3) + 'y';
                    }
                    // stopped -> stop, planned -> plan (åŒå†™è¾…éŸ³å­—æ¯)
                    else {
                        const stem = result.slice(0, -2);
                        if (stem.length >= 2 && stem[stem.length - 1] === stem[stem.length - 2] &&
                            !'aeiou'.includes(stem[stem.length - 1])) {
                            result = stem.slice(0, -1);
                        }
                        // æ£€æŸ¥æ˜¯å¦æ˜¯ "åŸè¯ä»¥eç»“å°¾ + d" çš„å½¢å¼
                        // å¸¸è§çš„ -Ced æ¨¡å¼ï¼Œå…¶ä¸­ C æ˜¯è¾…éŸ³ï¼ŒåŸè¯ä»¥ -Ce ç»“å°¾
                        else if (this.shouldRestoreE(stem)) {
                            result = stem + 'e'; // reserved -> reserve, united -> unite
                        }
                        else {
                            result = stem; // walked -> walk, played -> play
                        }
                    }
                }
                // åŠ¨è¯ -es/-s ç¬¬ä¸‰äººç§°å•æ•°
                else if (result.endsWith('ies') && result.length > 4) {
                    result = result.slice(0, -3) + 'y';
                }
                else if (result.endsWith('es') && result.length > 3) {
                    // matches -> match, pushes -> push
                    const stem = result.slice(0, -2);
                    if (stem.endsWith('ch') || stem.endsWith('sh') || stem.endsWith('x') || 
                        stem.endsWith('z') || stem.endsWith('ss')) {
                        result = stem;
                    }
                    // closes -> close
                    else if (this.isValidWord(stem + 'e')) {
                        result = stem + 'e';
                    }
                    else {
                        result = stem;
                    }
                }
                else if (result.endsWith('s') && result.length > 2 && !result.endsWith('ss')) {
                    result = result.slice(0, -1);
                }
                // å½¢å®¹è¯æ¯”è¾ƒçº§ -er
                else if (result.endsWith('er') && result.length > 3) {
                    const stem = result.slice(0, -2);
                    // bigger -> big
                    if (stem.length >= 2 && stem[stem.length - 1] === stem[stem.length - 2] &&
                        !'aeiou'.includes(stem[stem.length - 1])) {
                        result = stem.slice(0, -1);
                    }
                    // nicer -> nice
                    else if (this.isValidWord(stem + 'e')) {
                        result = stem + 'e';
                    }
                    // happier -> happy
                    else if (result.endsWith('ier')) {
                        result = result.slice(0, -3) + 'y';
                    }
                }
                // å½¢å®¹è¯æœ€é«˜çº§ -est
                else if (result.endsWith('est') && result.length > 4) {
                    const stem = result.slice(0, -3);
                    // biggest -> big
                    if (stem.length >= 2 && stem[stem.length - 1] === stem[stem.length - 2] &&
                        !'aeiou'.includes(stem[stem.length - 1])) {
                        result = stem.slice(0, -1);
                    }
                    // nicest -> nice
                    else if (this.isValidWord(stem + 'e')) {
                        result = stem + 'e';
                    }
                    // happiest -> happy
                    else if (result.endsWith('iest')) {
                        result = result.slice(0, -4) + 'y';
                    }
                    else {
                        result = stem;
                    }
                }
                // å‰¯è¯ -ly
                else if (result.endsWith('ly') && result.length > 3) {
                    const stem = result.slice(0, -2);
                    // happily -> happy
                    if (result.endsWith('ily')) {
                        result = result.slice(0, -3) + 'y';
                    }
                    // gently -> gentle
                    else if (this.isValidWord(stem + 'e')) {
                        result = stem + 'e';
                    }
                    // simply -> simple  
                    else if (stem.endsWith('b') || stem.endsWith('p')) {
                        result = stem + 'le';
                    }
                }

                return result;
            }

            // ç®€å•åˆ¤æ–­æ˜¯å¦å¯èƒ½æ˜¯æœ‰æ•ˆå•è¯ï¼ˆå¯å‘å¼ï¼‰
            isValidWord(word) {
                // ç®€å•çš„å¯å‘å¼ï¼šæ£€æŸ¥å…ƒéŸ³åˆ†å¸ƒ
                const vowels = word.match(/[aeiou]/gi);
                return vowels && vowels.length >= 1 && word.length >= 2;
            }

            // åˆ¤æ–­ç§»é™¤ -ed åæ˜¯å¦åº”è¯¥æ¢å¤æœ«å°¾çš„ e
            // ä¾‹å¦‚: reserved -> reserve, united -> unite, used -> use
            shouldRestoreE(stem) {
                if (stem.length < 2) return false;
                
                const lastChar = stem[stem.length - 1];
                const secondLastChar = stem[stem.length - 2];
                
                // å¦‚æœè¯å¹²ä»¥å…ƒéŸ³ç»“å°¾ï¼Œä¸éœ€è¦æ¢å¤ eï¼ˆå¦‚ played -> playï¼‰
                if ('aeiou'.includes(lastChar)) return false;
                
                // å¦‚æœå€’æ•°ç¬¬äºŒä¸ªå­—ç¬¦æ˜¯ eï¼Œè¯´æ˜åŸè¯å·²ç»æœ‰ e äº†ï¼Œä¸éœ€è¦å†åŠ 
                // å¦‚: registered -> registerï¼ˆä¸æ˜¯ registereï¼‰
                //     entered -> enterï¼ˆä¸æ˜¯ entereï¼‰
                //     offered -> offerï¼ˆä¸æ˜¯ offereï¼‰
                if (secondLastChar === 'e') return false;
                
                // å¸¸è§çš„ä»¥ -Ce ç»“å°¾çš„åŠ¨è¯æ¨¡å¼ï¼ˆC æ˜¯è¾…éŸ³ï¼‰
                // -ve (reserve, serve, save, live, move, love, have, give)
                // -te (unite, create, relate, complete, delete, compete)
                // -se (use, close, choose, raise, cause, release)
                // -ce (produce, reduce, force, announce, practice)
                // -ze (realize, organize, recognize, freeze)
                // -le (smile, file, rule, scale)
                // -re (store, prepare, compare, share, care)
                // -ne (define, combine, determine, phone)
                // -de (provide, include, decide, guide)
                // -ge (change, manage, charge, engage)
                // -ke (like, make, take, shake)
                // -me (name, time, come, assume)
                // -pe (hope, type, escape, shape)
                
                const endsWithEPattern = ['v', 't', 's', 'c', 'z', 'l', 'r', 'n', 'd', 'g', 'k', 'm', 'p'].includes(lastChar);
                
                if (endsWithEPattern) {
                    // è¿›ä¸€æ­¥æ£€æŸ¥ï¼šå¦‚æœå€’æ•°ç¬¬äºŒä¸ªæ˜¯å…ƒéŸ³ï¼ˆéeï¼‰ï¼Œæ›´å¯èƒ½éœ€è¦æ¢å¤ e
                    // reserv(e)d, unit(e)d, us(e)d, clos(e)d
                    if ('aiou'.includes(secondLastChar)) {
                        return true;
                    }
                    // ä¸€äº›ç‰¹æ®Šæ¨¡å¼ï¼š-rve, -rce, -rse, -rge, -nge, -lve ç­‰
                    if (stem.length >= 3) {
                        const thirdLastChar = stem[stem.length - 3];
                        const lastTwo = stem.slice(-2);
                        // serve, force, curse, charge, change, solve ç­‰
                        if (['rv', 'rc', 'rs', 'rg', 'ng', 'lv', 'nc', 'ns', 'dg'].includes(lastTwo)) {
                            return true;
                        }
                        // å¦‚æœæ˜¯ è¾…éŸ³+è¾…éŸ³ ç»“å°¾ï¼ˆä¸å«eï¼‰ï¼Œå¯èƒ½éœ€è¦ eï¼ˆå¦‚ reserv -> reserveï¼‰
                        if (!'aeiou'.includes(thirdLastChar) && !'aeiou'.includes(secondLastChar)) {
                            return true;
                        }
                    }
                }
                
                return false;
            }

            displayWords() {
                let wordPairs = [...this.extractedWords];
                
                // åº”ç”¨é€‰é¡¹
                const lowercase = document.getElementById('opt-lowercase').checked;
                const unique = document.getElementById('opt-unique').checked;
                const sort = document.getElementById('opt-sort').checked;
                const filterShort = document.getElementById('opt-filter-short').checked;
                const minLength = parseInt(document.getElementById('opt-min-length').value) || 3;
                
                // COCA é€‰é¡¹
                const cocaEnable = document.getElementById('opt-coca-enable').checked && this.cocaLoaded;
                const cocaMin = parseInt(document.getElementById('opt-coca-min').value) || 1;
                const cocaMax = parseInt(document.getElementById('opt-coca-max').value) || 60000;
                const cocaShowRank = document.getElementById('opt-coca-show-rank').checked;
                const cocaSortByRank = document.getElementById('opt-coca-sort-by-rank').checked;

                // å°å†™å¤„ç†
                if (lowercase) {
                    wordPairs = wordPairs.map(pair => ({
                        original: pair.original.toLowerCase(),
                        lemma: pair.lemma.toLowerCase()
                    }));
                }

                // è¿‡æ»¤çŸ­è¯ï¼ˆåŸºäºè¯å½¢è¿˜åŸåçš„è¯ï¼‰
                if (filterShort) {
                    wordPairs = wordPairs.filter(pair => pair.lemma.length >= minLength);
                }

                // å»é‡ï¼šæŒ‰è¯å½¢è¿˜åŸåçš„è¯è¿›è¡Œåˆ†ç»„ï¼Œæ”¶é›†æ‰€æœ‰åŸå§‹å½¢å¼å’Œè¯é¢‘
                let groupedWords;
                if (unique) {
                    const lemmaMap = new Map();
                    for (const pair of wordPairs) {
                        const key = pair.lemma;
                        if (!lemmaMap.has(key)) {
                            lemmaMap.set(key, { originals: new Set(), count: 0 });
                        }
                        lemmaMap.get(key).originals.add(pair.original);
                        lemmaMap.get(key).count++;
                    }
                    groupedWords = Array.from(lemmaMap.entries()).map(([lemma, data]) => ({
                        lemma,
                        originals: Array.from(data.originals),
                        count: data.count,
                        cocaRank: this.getCOCARank(lemma)
                    }));
                } else {
                    // ä¸å»é‡æ—¶ï¼Œæ¯ä¸ªè¯å•ç‹¬æ˜¾ç¤º
                    groupedWords = wordPairs.map(pair => ({
                        lemma: pair.lemma,
                        originals: [pair.original],
                        count: 1,
                        cocaRank: this.getCOCARank(pair.lemma)
                    }));
                }

                // COCA è¯é¢‘ç­›é€‰
                let cocaInRangeCount = 0;
                let cocaUnknownCount = 0;
                
                if (cocaEnable) {
                    // ç»Ÿè®¡ COCA èŒƒå›´å†…å’ŒæœªçŸ¥è¯
                    for (const item of groupedWords) {
                        if (item.cocaRank === null) {
                            cocaUnknownCount++;
                        } else if (item.cocaRank >= cocaMin && item.cocaRank <= cocaMax) {
                            cocaInRangeCount++;
                        }
                    }
                    
                    // ç­›é€‰ï¼šåªä¿ç•™ COCA èŒƒå›´å†…çš„è¯
                    groupedWords = groupedWords.filter(item => {
                        if (item.cocaRank === null) return false;
                        return item.cocaRank >= cocaMin && item.cocaRank <= cocaMax;
                    });
                    
                    // æ˜¾ç¤º COCA ç»Ÿè®¡
                    document.getElementById('stat-coca-container').style.display = 'block';
                    document.getElementById('stat-coca-unknown-container').style.display = 'block';
                    document.getElementById('stat-coca-in-range').textContent = cocaInRangeCount.toLocaleString();
                    document.getElementById('stat-coca-unknown').textContent = cocaUnknownCount.toLocaleString();
                } else {
                    // éšè— COCA ç»Ÿè®¡
                    document.getElementById('stat-coca-container').style.display = 'none';
                    document.getElementById('stat-coca-unknown-container').style.display = 'none';
                }

                // æ’åº
                const sortByFreq = document.getElementById('opt-sort-by-freq').checked;
                
                if (sortByFreq) {
                    // æŒ‰ä¹¦ä¸­è¯é¢‘æ’åºï¼ˆå‡ºç°æ¬¡æ•°å¤šçš„åœ¨å‰ï¼‰
                    groupedWords.sort((a, b) => b.count - a.count);
                } else if (cocaEnable && cocaSortByRank) {
                    // æŒ‰ COCA è¯é¢‘æ’åºï¼ˆæ’åè¶Šå°è¶Šå¸¸è§ï¼‰
                    groupedWords.sort((a, b) => {
                        const rankA = a.cocaRank || Infinity;
                        const rankB = b.cocaRank || Infinity;
                        return rankA - rankB;
                    });
                } else if (sort) {
                    groupedWords.sort((a, b) => a.lemma.localeCompare(b.lemma));
                }

                // æ›´æ–°ç»Ÿè®¡
                document.getElementById('stat-unique').textContent = groupedWords.length.toLocaleString();

                // æ˜¾ç¤ºç»“æœ
                const wordList = document.getElementById('word-list');
                wordList.innerHTML = groupedWords.map(item => {
                    // åªæ˜¾ç¤ºä¸è¯å½¢è¿˜åŸåä¸åŒçš„åŸå§‹å½¢å¼
                    const differentOriginals = item.originals.filter(orig => 
                        orig.toLowerCase() !== item.lemma.toLowerCase()
                    );
                    
                    // è¯é¢‘æ˜¾ç¤º
                    const freqHtml = unique
                        ? `<span class="word-freq" style="font-size: 12px; color: #e67e22; margin-left: 8px; background: #fef5e7; padding: 2px 6px; border-radius: 4px;">Ã—${item.count}</span>`
                        : '';
                    
                    // COCA æ’åæ˜¾ç¤º
                    const rankHtml = (cocaEnable && cocaShowRank && item.cocaRank)
                        ? `<span class="word-rank" style="font-size: 12px; color: #667eea; margin-left: 8px; background: #f0f4ff; padding: 2px 6px; border-radius: 4px;">#${item.cocaRank}</span>`
                        : '';
                    
                    const originalsHtml = differentOriginals.length > 0
                        ? `<span class="word-arrow">â†</span>
                           <span class="word-originals">${differentOriginals.map(o => 
                               `<span class="word-original-tag">${this.escapeHtml(o)}</span>`
                           ).join('')}</span>`
                        : '';
                    
                    return `<div class="word-item">
                        <span class="word-lemma">${this.escapeHtml(item.lemma)}</span>
                        ${freqHtml}
                        ${rankHtml}
                        ${originalsHtml}
                    </div>`;
                }).join('');

                // ä¿å­˜å¤„ç†åçš„åˆ—è¡¨ç”¨äºå¯¼å‡ºï¼ˆåŒ…å«è¯é¢‘å’Œ COCA ä¿¡æ¯ï¼‰
                this.displayedWords = groupedWords;
                this.exportWithFreq = unique;
                this.exportWithCOCA = cocaEnable && cocaShowRank;
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            formatWordsForExport() {
                return this.displayedWords.map(item => {
                    const differentOriginals = item.originals.filter(orig => 
                        orig.toLowerCase() !== item.lemma.toLowerCase()
                    );
                    
                    // æ„å»ºå¯¼å‡ºè¡Œ
                    let line = item.lemma;
                    
                    // æ·»åŠ è¯é¢‘ï¼ˆå»é‡æ¨¡å¼ä¸‹ï¼‰
                    if (this.exportWithFreq && item.count > 1) {
                        line += `\tÃ—${item.count}`;
                    }
                    
                    // æ·»åŠ  COCA æ’å
                    if (this.exportWithCOCA && item.cocaRank) {
                        line += `\t#${item.cocaRank}`;
                    }
                    
                    // æ·»åŠ åŸå§‹å½¢å¼
                    if (differentOriginals.length > 0) {
                        line += `\tâ† ${differentOriginals.join(', ')}`;
                    }
                    
                    return line;
                }).join('\n');
            }

            copyToClipboard() {
                const text = this.formatWordsForExport();
                navigator.clipboard.writeText(text).then(() => {
                    const btn = document.getElementById('copy-btn');
                    const originalText = btn.textContent;
                    btn.textContent = 'âœ… å·²å¤åˆ¶ï¼';
                    setTimeout(() => {
                        btn.textContent = originalText;
                    }, 2000);
                }).catch(err => {
                    console.error('å¤åˆ¶å¤±è´¥:', err);
                    alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ã€‚');
                });
            }

            downloadAsTxt() {
                // åªå¯¼å‡ºè½¬æ¢åçš„å•è¯ï¼ˆè¯å½¢è¿˜åŸåçš„è¯ï¼‰ï¼Œæ¯è¡Œä¸€ä¸ª
                const text = this.displayedWords.map(item => item.lemma).join('\n');
                const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `${this.currentFileName}-words.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }

        // åˆå§‹åŒ–
        const extractor = new WordExtractor();
    </script>
</body>
</html>
